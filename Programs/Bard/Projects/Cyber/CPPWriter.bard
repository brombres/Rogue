class CPPWriter : Visitor
  PROPERTIES
    writer      = StringBuilder()
    this_type   : Type
    this_method : Method

    type_info     = Integer[]

    previous_cmd_is_return : Logical

    project_prefix  = "BardXC"
    setting_prefix  = ""
    property_prefix = ""

    dynamic_dispatch_signatures = Table<<String,Method>>()

  METHODS
    method compile( cpp_filepath:String )
      project_prefix = Analyzer.target_rules.prefix

      local h_filepath = "$.h" (cpp_filepath.before_first(".cpp"))
      generate_h_file( h_filepath )
      generate_cpp_file( cpp_filepath, h_filepath )

    method generate_h_file( filepath:String )
      writer.clear
      writeln "#ifndef BARDXC_H"
      writeln "#define BARDXC_H"
      writeln "//============================================================================="
      writeln "//  $" (filepath)
      writeln "//============================================================================="
      writeln

      # Write $[header] defined in Custom.js
      if (Analyzer.target_rules.header_code.count?)
        writeln "//-----------------------------------------------------------------------------"
        writeln "// $[header] code defined in $." ('$',Analyzer.target_rules.filepath)
        writeln "//-----------------------------------------------------------------------------"
        writeln Analyzer.target_rules.header_code->String
        writeln
      endIf

      write_type_definitions

      writeln "//-----------------------------------------------------------------------------"
      writeln "// Requisite Method Prototypes"
      writeln "//-----------------------------------------------------------------------------"
      write_method_prototypes( true )  # requisite only

      writeln
      writeln "#endif // BARDXC_H"


      File(filepath).save( writer->String )

    method generate_cpp_file( cpp_filepath:String, h_filepath:String )
      writer.clear
      writeln "//============================================================================="
      writeln "//  $" (cpp_filepath)
      writeln "//============================================================================="
      writeln
      writeln //#include "$"// (File(h_filepath).filename)
      writeln

      # Write $[code] defined in Custom.js
      if (Analyzer.target_rules.code.count?)
        writeln( "//-----------------------------------------------------------------------------" )
        writeln( "// $[code] defined in $." ('$',Analyzer.target_rules.filepath) )
        writeln( "//-----------------------------------------------------------------------------" )
        writeln( Analyzer.target_rules.code->String )
        writeln
      endIf

      write_setting_declarations;

      writeln "//-----------------------------------------------------------------------------"
      writeln "// General Method Prototypes"
      writeln "//-----------------------------------------------------------------------------"
      write_method_prototypes( false )  # non-requisite only
      writeln

      write_dispatch_functions

      write_method_tables

      write_type_info

      writeln "//-----------------------------------------------------------------------------"
      writeln "// Method Definitions"
      writeln "//-----------------------------------------------------------------------------"
      write_method_definitions

      File(cpp_filepath).save( writer->String )

    method write_type_definitions
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Type Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (type in Types.type_list)
        if (type.is_primitive or (type.is_functional and not type.is_compound) or type.is_native) nextIteration
        if (type is Types.type_Object) nextIteration

        write( "struct " )
        write( project_prefix )
        write( type.x_name )
        writeln
        writeln( "{" )
        writer.indent += 2

        if (not type.is_functional) write project_prefix; writeln "Object header;"

        forEach (p in type.property_list)
          write_c_type_name( p.type.x_type )
          write " "
          write property_prefix
          write p.x_name
          writeln ";"
        endForEach

        writer.indent -= 2
        writeln( "};" )

        writeln
      endForEach

    method write_dispatch_functions
      # Build list of signatures used in dynamic dispatch
      local max_args = 0
      forEach (m in Analyzer.method_list)
        if (m.overridden)
          local sig = m.dispatch_signature
          if (not dynamic_dispatch_signatures.contains(sig))
            dynamic_dispatch_signatures[sig] = m
          endIf
        endIf
      endForEach

      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Dynamic Dispatch Functions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (sig in dynamic_dispatch_signatures.keys)
        local m = dynamic_dispatch_signatures[sig]
        write_c_type_name( m.return_type )
        write " "
        write project_prefix
        write "_dynamic_dispatch"
        write sig
        write "( int index, "
        write_c_type_name( m.type_context )
        write " THIS"
        local i = 1
        forEach (param in m.parameters)
          write ", "
          write_c_type_name( param.type )
          write " arg"
          write ""+i
          ++i
        endForEach
        writeln " )"
        writeln "{"

        writer.indent += 2
        if (m.return_type?) write "return "
        write "(("
        write_c_type_name( m.return_type )
        write " (*)("
        write_c_type_name( m.type_context )
        forEach (param in m.parameters)
          write ","
          write_c_type_name( param.type )
        endForEach
        write ")"
        write ")(THIS->type->methods[index]))( THIS"
        forEach (i of m.parameters)
          write ", arg"
          write ""+i
        endForEach
        writeln " );"

        writer.indent -= 2

        writeln "}"
        writeln
      endForEach

      # Write out aspect dispatch functions
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Aspect Dispatch Functions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (sig in dynamic_dispatch_signatures.keys)
        local m = dynamic_dispatch_signatures[sig]
        write_c_type_name( m.return_type )
        write " "
        write project_prefix
        write "_aspect_dispatch"
        write sig
        write "( int desired_aspect_type_index, int aspect_method_index, "
        write_c_type_name( m.type_context )
        write " THIS"
        local i = 1
        forEach (param in m.parameters)
          write ", "
          write_c_type_name( param.type )
          write " arg"
          write ""+i
          ++i
        endForEach
        writeln " )"
        writeln "{"

        writeln  "  $Type* desired_aspect = &$_types[desired_aspect_type_index];"  (project_prefix,project_prefix)
        writeln  "  void* m;"
        writeln
        writeln  "  $Type** aspect_type_ptr = type->aspect_types;" (project_prefix)
        writeln  "  void*** aspect_method_ptr = type->aspect_methods;"
        writeln  "  while (*aspect_type_ptr != desired_aspect)"
        writeln  "  {"
        writeln  "    ++aspect_type_ptr;"
        writeln  "    ++aspect_method_ptr;"
        writeln  "  }"
        writeln  "  m = (*aspect_method_ptr)[ aspect_method_index ];"

        write "  "
        if (m.return_type?) write "return "
        write "(("
        write_c_type_name( m.return_type )
        write " (*)("
        write_c_type_name( m.type_context )
        forEach (param in m.parameters)
          write ","
          write_c_type_name( param.type )
        endForEach
        write ")"
        write ")m)( THIS"
        forEach (i of m.parameters)
          write ", arg"
          write ""+i
        endForEach
        writeln " );"

        writeln "}"
        writeln
      endForEach



    method write_method_tables
      writeln "//-----------------------------------------------------------------------------"
      writeln "// Method Tables"
      writeln "//-----------------------------------------------------------------------------"

      write   "int "
      write   project_prefix
      write   "_method_count = "
      write   Analyzer.method_list.count
      writeln ";"
      writeln

      write   "void* "
      write   project_prefix
      write   "_methods["
      write   Analyzer.method_list.count
      writeln "] ="
      writeln "{"
      writer.indent += 2;

      local need_comma = false
      forEach (m in Analyzer.method_list)
        if (need_comma) writeln ","
        else need_comma = true

        this_type = m.type_context
        if (m.inline_mapping?)
          write "NULL"

        else
          write( "(void*) " )
          write( project_prefix )
          write( m.type_context.x_type.x_name )
          write( "__" )
          write( m.x_signature )
        endIf
      endForEach
      writeln

      writer.indent -= 2
      writeln "};"
      writeln


      #{
      write   "int* BardXC_dispatch_tables["
      write   Analyzer.method_list.count
      writeln "] ="
      writeln "{"
      writer.indent += 2;

      local need_comma = false
      forEach (m in Analyzer.method_list)
        if (need_comma) writeln ","
        else need_comma = true

        this_type = m.type_context
        if (m.inline_mapping?)
          write "null"

        else
          write( project_prefix )
          write( m.type_context.x_type.x_name )
          write( "__" )
          write( m.x_signature )
        endIf
      endForEach
      writeln

      writer.indent -= 2
      writeln "};"
      writeln
      }#

    method write_int_array( name:String, array:Integer[] )
      write   "int "
      write   project_prefix
      write   "_"
      write   name
      write   "["
      write   array.count
      writeln "] ="
      writeln "{"
      writer.indent += 2

      local need_comma = false
      local starting_count = writer.count
      forEach (n in array)
        if (need_comma) write ","
        need_comma = true
        if (writer.count - starting_count >= 76) writeln; starting_count = writer.count
        write n
      endForEach
      if (starting_count != writer.count) writeln
      writer.indent -= 2
      writeln "};"
      writeln


    method write_type_info
      writeln "//-----------------------------------------------------------------------------"
      writeln "// Type Info"
      writeln "//-----------------------------------------------------------------------------"

      write   "int "
      write   project_prefix
      write   "_type_count = "
      write   Types.type_list.count
      writeln ";"
      writeln

      write   project_prefix
      write   "Type "
      write   project_prefix
      write   "_types["
      write   Types.type_list.count
      writeln "] ="
      writeln "{"

      local need_comma = false
      forEach (type in Types.type_list)
        if (need_comma) writeln ","
        need_comma = true

        write "  {"

        write type_info.count

        write "}  /* "
        write type.name
        write " */"

        # Base Types
        type_info.add( type.base_types.count )
        forEach (base_type in type.base_types)
          type_info.add( base_type.index )
        endForEach

        # Dynamic Dispatch Table
        type_info.add( type.method_list.count )
        forEach (m in type.method_list)
          if (m.referenced or (m.generic_base_method? and m.generic_base_method.referenced))
            type_info.add( m.global_index )
          else
            type_info.add( -1 )
          endIf
        endForEach

        # Aspect Dispatch Tables
        type_info.add( type.aspects.count )
        forEach (a in type.aspects)
          type_info.add( a.index )
          type_info.add( a.method_list.count )
          forEach (m in a.method_list)
            type_info.add( type.must_find_method(m.signature,m.return_type).global_index )
          endForEach
        endForEach
      endForEach

      writeln
      writeln "};"
      writeln

      write_int_array( "type_info", type_info )

    method write_setting_declarations
      writeln "//-----------------------------------------------------------------------------"
      writeln "// Settings"
      writeln "//-----------------------------------------------------------------------------"
      forEach (type in Types.type_list)
        if (type.settings_list.count?)
          forEach (setting in type.settings_list)
            write_c_type_name( setting.type )

            write   " "
            write   project_prefix
            write   type.x_name
            write   "_setting_"
            write  setting.x_name
            write  " = "
            if (setting.type.is_reference)    write "NULL"
            elseIf (setting.type.is_compound) write "{}"
            else                              write "0"
            writeln ";"
          endForEach
          writeln
        endIf
      endForEach

    method write_method_prototypes( requisite_only:Logical )
      forEach (m in Analyzer.method_list)
        this_type = m.type_context
        if (m.inline_mapping?) nextIteration
        if (requisite_only != (m.is_requisite or m.attributes.is_native)) nextIteration
        #if (this_type.is_compound and m.attributes.is_automatic) nextIteration # create() method

        this_method = m

        if (not requisite_only) write "static "
        write_c_type_name( m.return_type )
        write " "
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )

        write "( "
        write_c_type_name( m.type_context )
        write " THIS"

        local parameter_count = m.parameters.count
        forEach (param in m.parameters)
          write( ", " )
          write_c_type_name( param.type )
          write " "
          write param.x_name
        endForEach
        write " );"

        if (m.attributes.is_native) write( "  // NATIVE" )
        writeln

        #{
        if (not m.attributes.is_native)
          writeln( "{" )

          if (not m.type_context.is_aspect or m.full_signature == "init_settings()")
            m = m.x_method
            if (m.referenced)
              indent = 2
              needs_indent = true

              # Write all local variable declarations
              if (m.locals.count > m.parameters.count)
                write( "var " );
                local first = true
                forEach (i in m.parameters.count..<m.locals.count)
                  if (first) first = false
                  else       write ", "
                  write m.locals[i].x_name
                endForEach
                writeln ";"
              endIf

#writeln( "console.log('$');" (m.context_signature) )
              visit( m )

            endIf
          endIf

          indent -= 2
          writeln( "}" )
        endIf
        }#
      endForEach

    method write_method_definitions
      forEach (m in Analyzer.method_list)
        this_type = m.type_context
        if (m.inline_mapping? or m.attributes.is_native) nextIteration

        this_method = m

        if (not m.is_requisite) write "static "

        write_c_type_name( m.return_type )
        write " "
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )

        write "( "
        write_c_type_name( m.type_context )
        write " THIS"

        local parameter_count = m.parameters.count
        forEach (param in m.parameters)
          write( ", " )
          write_c_type_name( param.type )
          write " "
          write param.x_name
        endForEach
        writeln " )"
        writeln "{"
        writer.indent += 2

        m.body.dispatch( this )

        if (not previous_cmd_is_return and m.return_type?)
          if (m.is_initializer or m.attributes.auto_return_this)
            writeln( "return THIS;" )
          else
            write( project_prefix )
            writeln( "_throw_missing_return();" );
          endIf
        endIf

        writer.indent -= 2
        writeln "}"

        writeln
      endForEach

    method write( st:String )
      writer.print(st)

    method write( n:Integer )
      writer.print(n)

    method write_literal( st:String )
      if (st is null)
        writer.print( "null" )
      else
        writer.print( '"' )
        forEach (ch in st)
          if (ch >= 32 and ch <= 126)
            which (ch)
              case '\\': writer.print( "\\\\" )
              case '"':  writer.print( "\\\"" )
              others:    writer.print( ch )
            endWhich
          else
            if (ch < 256)
              which (ch)
                case '\0': writer.print("\\0")
                case    8: writer.print("\\b")
                case   12: writer.print("\\f")
                case '\n': writer.print("\\n")
                case '\r': writer.print("\\r")
                case '\t': writer.print("\\t")
                case   11: writer.print("\\v")
                others
                  writer.print( "\\x" )
                  writer.print( ch->Integer.to_hex_string(2) )
              endWhich
            else
              writer.print( "\\u" )
              writer.print( ch->Integer.to_hex_string(4) )
            endIf
          endIf
        endForEach
        writer.print( '"' )
      endIf

    method writeln( st:String )
      write( st )
      writeln

    method writeln
      writer.println

    method write_c_type_name( type:Type )
      if (type?)
        type = type.x_type
        write project_prefix
        if (type.is_reference) write "Object"
        else write type.x_name
        if (type.is_reference) write "*"
      else
        write "void"
      endIf

    method write_cast( to_type:Type )
      write "("
      write project_prefix
      to_type = to_type.x_type
      write to_type.x_name
      if (to_type.is_reference) write "*"
      write ")"

    method generate_temporary_local_name->String
      return "temp_" + Analyzer.unique_id

    method visit( cmd:CmdStatementList )
      previous_cmd_is_return = false
      forEach (statement in cmd) 
        previous_cmd_is_return = false
        statement.dispatch( this )
        if (statement notInstanceOf CmdControlStructure)
          write( ";" )
        endIf
        writeln
      endForEach

    method visit( cmd:CmdLocalDeclaration )->Cmd
      write_c_type_name( cmd.local_info.type )
      write " "
      write( cmd.local_info.x_name )
      return cmd

      #{
    method visit( cmd:CmdTron )->Cmd
      write_code( cmd.t, Op.trace_on )
      return cmd

    method visit( cmd:CmdTroff )->Cmd
      write_code( cmd.t, Op.trace_off )
      return cmd
      }#

    method visit( cmd:CmdReturnNil )->Cmd
      previous_cmd_is_return = true
      if (this_method.is_initializer or this_method.attributes.auto_return_this)
        write( "return THIS" )

      else
        write( "return" )
      endIf
      return cmd

    method visit( cmd:CmdReturnThis )->Cmd
      previous_cmd_is_return = true
      writeln( "return THIS;" );
      return cmd

    method visit( cmd:CmdReturnValue )->Cmd
      write( "return " )
      cmd.operand.dispatch( this )
      previous_cmd_is_return = true
      return cmd

    method visit( cmd:CmdSpecializeReference )->Cmd
      cmd.operand = cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertIntegerToReal )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertRealToInteger )->Cmd
      write "(("
      write project_prefix
      write "Integer)"
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:CmdConvertCharacterToInteger )->Cmd
      write "(("
      write project_prefix
      write "Integer)"
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:CmdConvertByteToInteger )->Cmd
      write "(("
      write project_prefix
      write "Integer)"
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:CmdConvertIntegerToCharacter )->Cmd
      write "(("
      write project_prefix
      write "Character)"
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:CmdConvertIntegerToByte )->Cmd
      write "(("
      write project_prefix
      write "Byte)"
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:CmdConvertLogicalToInteger )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdIf )->Cmd
      write( "if (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      writer.indent += 2
      cmd.body.dispatch( this )
      writer.indent -= 2
      writeln( "}" )

      forEach (index of cmd.elseIf_conditions)
        local condition = cmd.elseIf_conditions[index]
        write( "else if (" )
        condition.dispatch( this )
        writeln( ")" )
        writeln( "{" )
        writer.indent += 2
        cmd.elseIf_bodies[index].dispatch( this )
        writer.indent -= 2
        writeln( "}" )
      endForEach

      if (cmd.else_body?)
        writeln( "else" )
        writeln( "{" )
        writer.indent += 2
        cmd.else_body.dispatch( this )
        writer.indent -= 2
        writeln( "}" )
      endIf

      if (cmd.control_id_used_in_nested_code)
        write( "escape_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      previous_cmd_is_return = false

      return cmd

    method visit( cmd:CmdContingent )->Cmd
      # Main body
      writeln( "{" )
      writer.indent += 2

      cmd.body.dispatch( this )

      writer.indent -= 2
      writeln( "}" )

      # Satisfied clause
      write( "satisfied_" )
      write cmd.control_id
      writeln( ":" )

      writeln( "{" )
      writer.indent += 2

      if(cmd.satisfied_body?) cmd.satisfied_body.dispatch( this )
      write   "goto escape_"
      write   cmd.control_id
      writeln ";"

      writer.indent -= 2
      writeln( "}" )

      # Unatisfied clause
      write( "unsatisfied_" )
      write cmd.control_id
      writeln( ":" )

      writeln( "{" )
      writer.indent += 2

      if(cmd.unsatisfied_body?) cmd.unsatisfied_body.dispatch( this )

      writer.indent -= 2
      writeln( "}" )

      write( "escape_" )
      write cmd.control_id
      writeln( ":" )

      return cmd

    method visit( cmd:CmdNecessary )->Cmd
      write( "if ( !(" )
      cmd.operand.dispatch( this )
      write( ") ) goto unsatisfied_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdSufficient )->Cmd
      write( "if (" )
      cmd.operand.dispatch( this )
      write( ") goto satisfied_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeContingent )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdAnonymousBlock )->Cmd
      writeln( "{" )
      writer.indent += 2
      cmd.body.dispatch( this )
      writer.indent -= 2
      writeln( "}" )
      return cmd

    method visit( cmd:CmdWhile )->Cmd
      write( "while (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      writer.indent += 2

      if (cmd.control_id_used_in_nested_code)
        write( "next_iteration_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      cmd.body.dispatch( this )

      writer.indent -= 2
      writeln( "}" )

      if (cmd.control_id_used_in_nested_code)
        write( "escape_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      previous_cmd_is_return = false
      return cmd

    method visit( cmd:CmdEscapeWhile )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdLoop )->Cmd
      writeln( "for (;;)" )
      writeln( "{" )
      writer.indent += 2

      if (cmd.control_id_used_in_nested_code)
        write( "next_iteration_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      cmd.body.dispatch( this )

      writer.indent -= 2
      writeln( "}" )

      if (cmd.control_id_used_in_nested_code)
        write( "escape_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      previous_cmd_is_return = false

      return cmd

      #{
    method visit( cmd:CmdTry )->Cmd
      cmd.control_id = next_control_id

      local ip_start = code.count
      cmd.body.dispatch( this )
      local ip_limit = code.count
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      local m = Analyzer.context.this_method
      m.exception_handlers.add( ExceptionHandler(ip_start,ip_limit) )

      local catch_index = 0
      forEach (cur_catch in cmd.catches)
        Analyzer.context.push_local_scope
        Analyzer.add_local( cur_catch.local_info )
        local label_name = "catch_$_$_$" (cmd.control_id,m.exception_handlers.count-1,catch_index)
        define_label( label_name )
        m.exception_handlers.last.catches.add( ExceptionHandlerCatch(cur_catch.local_info,label_name) )
        cur_catch.body.dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
        Analyzer.context.pop_local_scope
        ++catch_index
      endForEach

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdThrow )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.throw_exception )
      return cmd
      }#

    method visit( cmd:CmdEscapeLoop )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeForEach )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeIf )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeTry )->Cmd
      write( "goto escape_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdNextIteration )->Cmd
      write( "goto continue_" )
      write( cmd.target_id )
      return cmd

    method format_string( value:Real, decimal_digits:Integer )->String
      return StringBuilder().print(value,decimal_digits)->String

    method visit( cmd:CmdLiteralReal )->Cmd
      local fractional_part = Math.abs(cmd.value) - Math.floor( Math.abs(cmd.value) )
      forEach (decimal_digits in 1..9)
        local magnitude = 10.0 ^ decimal_digits
        if (fractional_part == (fractional_part*magnitude)->Integer / magnitude)
          write( format_string( cmd.value, decimal_digits) )
          return cmd
        endIf
      endForEach

      if (cmd.value == pi)
        write project_prefix
        write( "_pi" );
      else
        write( format_string( cmd.value, decimal_digits) )  # KLUDGE
      endIf

      #throw cmd.t.error( "TODO: real " + cmd.value )
      #write( "TODO:int64_bits_to_real(0x..." )
      #write( (cmd.value as Int64).to_String(16) )
      #write( ")" )

      return cmd

    method visit( cmd:CmdLiteralString )->Cmd
      write_literal( cmd.value )
      return cmd

    method visit( cmd:CmdLiteralNull )->Cmd
      write( "NULL" )
      return cmd

    method visit( cmd:CmdLiteralInteger )->Cmd
      write( ""+cmd.value )
      return cmd

    method visit( cmd:CmdLiteralByte )->Cmd
      write( ""+cmd.value )
      return cmd

    method write_literal_array_instantiation( of_type:Type, xc_type_name:String, elements:CmdArgs, index:Integer )
      write xc_type_name
      if (index >= 0)
        write "_set("
        write_literal_array_instantiation( of_type, xc_type_name, elements, index-1 )
        write ","
        write index
        write ","
        elements[index].dispatch( this )
        write ")"
      else
        write "_create("
        write of_type.index
        write ","
        write elements.count
        write ")"
      endIf

    method visit( cmd:CmdLiteralArray )->Cmd
      if (cmd.array_type.is_reference)
        write_literal_array_instantiation( cmd.array_type, "BardXCReferenceArray", cmd.elements, cmd.elements.count-1 )
      else
        throw cmd.t.error( "TODO: CPPWriter visit(CmdLiteralArray) of type " + cmd.array_type )
      endIf
      return cmd

    method visit( cmd:CmdLiteralCharacter )->Cmd
      which (cmd.value)
        case 10:   write "'\\n'"
        case '\\': write "'\\\\'"
        case '\'': write "'\\''"
        others
          if (cmd.value >= 32 and cmd.value <= 126) write "'$'" (cmd.value)
          else write "(($Character)$)" (project_prefix,cmd.value->Integer)
      endWhich
      return cmd

    method visit( cmd:CmdLiteralLogical )->Cmd
      if (cmd.value) write( "true" )
      else           write( "false" )
      return cmd

    method visit( cmd:CmdReadLocal )->Cmd
      write cmd.local_info.x_name
      return cmd

    method visit( cmd:CmdWriteLocal )->Cmd
      #if (cmd.local_info.type.is_compound)
      #else
      write( cmd.local_info.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )
      #endIf
      return cmd

    method visit( cmd:CmdWriteLocalDefault )->Cmd
      write( cmd.local_info.x_name )
      write( " = " )
      local v = cmd.local_info
      local type = v.type
      local opcode = -1
      which (type.classification)
        case Type.reference_type: write( "NULL" )
        case Type.real_type:      write( "0" )
        case Type.integer_type:   write( "0" )
        case Type.character_type: write( "0" )
        case Type.byte_type:      write( "0" )
        case Type.logical_type:   write( "false" )
        case Type.compound_type
          throw cmd.t.error("TODO: visit(CmdWriteLocalDefault) with compound type")
        others
        throw cmd.t.error( "CmdWriteLocalDefault not implemented for type " + type + "." )
      endWhich

      return cmd

    method visit( cmd:CmdInstanceOf )->Cmd
      write   project_prefix
      write   "Type_instance_of("
      cmd.operand.dispatch( this )
      write( "," )
      write( cmd.target_type.x_type.index )
      write( ")" )
      return cmd

    method visit( cmd:CmdAssign )->Cmd
      cmd.operand.dispatch( this )
      write( " = " )
      cmd.new_value.dispatch( this )
      return cmd

    method visit( cmd:CmdIncrementLocal )->Cmd
      write( "++" )
      write( cmd.local_info.x_name )
      return cmd

    method visit( cmd:CmdIncrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "++" )
      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( cmd.setting.x_name )

      return cmd

    method visit( cmd:CmdDecrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "--" )
      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( cmd.setting.x_name )

      return cmd

    method visit( cmd:CmdIncrementProperty )->Cmd
      if (cmd.context?)
        write   "++("
        write_cast( cmd.property.type )
        if (cmd.context?) cmd.context.dispatch( this )
        else              write_this
        write   ")->"
        write( property_prefix )
        write( cmd.property.x_name )
      else
        write   "++("
        write_cast( cmd.property.type )
        write   "THIS)->"
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdDecrementLocal )->Cmd
      write   "--"
      write   cmd.local_info.x_name
      return  cmd


    method visit( cmd:CmdDecrementProperty )->Cmd
      if (cmd.context?)
        write( "--(" )
        write_cast( cmd.property.type )
        if (cmd.context?) cmd.context.dispatch( this )
        else              write_this
        write( ")->" )
        write( property_prefix )
        write( cmd.property.x_name )
      else
        write   "--("
        write_cast( cmd.property.type )
        write   "THIS)->"
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdNewObject )->Cmd
      local m = cmd.init_method.x_method
      if (cmd.of_type.new_object_inline_mappings?)
        local mapping = cmd.of_type.new_object_inline_mappings[ m.signature ]
        if (mapping?)
          write_inline_code( cmd.t, mapping, null, cmd.args )
          return cmd
        endIf
      endIf

      write( project_prefix )
      write( m.type_context.x_type.x_name )
      write( "__" )
      write( m.x_signature )
      write( "( " )

      local m = cmd.of_type.x_type.find_method( "init_defaults()" )

      if (m?)
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
      endIf

      write   project_prefix
      write   "_create_object("
      write   cmd.of_type.x_type.index
      write   ")"

      if (m?) write( " )" )

      if (cmd.args?)
        forEach (arg in cmd.args)
          write( ", " )
          arg.dispatch( this )
        endForEach
      endIf
      write( " )" )

      return cmd

    method this_reference->String
      if (this_type.is_compound)
        return "THIS"
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        return "THIS"
      else
        return "THIS"
      endIf

    method write_this
      if (this_type.is_compound)
        write( "THIS" )
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        write( "THIS" )
      else
        write( "THIS" )
      endIf

    method write_context( context:Cmd )
      if (context?)
        context.dispatch( this )
      else
        write_this
      endIf

    method visit( cmd:CmdThis )->Cmd
      write_this
      return cmd

    method visit( cmd:CmdReadSingleton )->Cmd
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      else
        write( project_prefix )
        write( cmd.of_type.x_type.x_name )
        write( "_singleton" )
      endIf
      return cmd

    method visit( cmd:CmdWriteSingleton )->Cmd
      throw cmd.t.error( "TODO" )

    method visit( cmd:CmdReadSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( setting_prefix )
      write( cmd.setting.x_name )

      return cmd


    method visit( cmd:CmdReadProperty )->Cmd
      write "("
      write_cast( cmd.property.type )
      write_context( cmd.context )
      write ")->"
      write( property_prefix )
      write( cmd.property.x_name )

      return cmd


    method visit( cmd:CmdWriteSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( setting_prefix )
      write( cmd.setting.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method visit( cmd:CmdWriteProperty )->Cmd
      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      write "("
      write_cast( cmd.property.type )

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
      else
        write_this
      endIf

      write( ")->" )

      write( property_prefix )

      write( cmd.property.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method write_inline_code( t:Token, code:String, context:Cmd, args:CmdArgs )
      local marker = code.locate( '$' )
      while (marker >= 0)
        local i = marker + 1
        local arg_index = code[i].to_number 

        ++i
        while (i < code.count and code[i].is_number)
          arg_index = arg_index * 10 + code[i].to_number
          ++i
        endWhile

        write( code.leftmost(marker) )

        if (arg_index == 0)
          if (context?) context.dispatch( this )
          else          write_this
        elseIf (arg_index <= args.count)
          args[arg_index-1].dispatch( this )
        else
          throw t.error( "Error mapping inline code: index $ is out of range (must be 0..$)." (arg_index,args.count) )
        endIf

        code = code.substring(i)
        marker = code.locate( '$' )
      endWhile
      write( code )

    method write_function_call( m:Method, context:Cmd, args:CmdArgs )
      local buffer = StringBuilder()
      buffer.print( m.type_context.x_type.x_name )
      buffer.print( "__" )
      buffer.print( m.x_signature )
      local signature = buffer.to_String

      which (signature)
        case "Math__floor__Real"
          write( "floor( " )
          args.first.dispatch( this )
          write( " )" )

        case "Math__sqrt__Real"
          write( "sqrt( " )
          args.first.dispatch( this )
          write( " )" )

        case "String__count"
          write "(("
          write project_prefix
          write "String*)"
          write_context( context )
          write( ")->count" )

        case "String__get__Integer"
          write "(("
          write project_prefix
          write "String*)"
          write_context( context )
          write( ")->characters[" )
          args.first.dispatch( this )
          write( "]" )

        others
          write( project_prefix )
          write( signature )

          if (context?)
            if (m.name == "create" and (args is null or args.count == 0))
              write( "()" )
              return
            else
              write( "( " )
              local context_type = context.type
              context.dispatch( this )
            endIf
          else
            write( "( " )
            write_this
          endIf

          if (args?)
            forEach (arg in args)
              write( ", " )
              arg.dispatch( this )
            endForEach
          endIf
          write(" )")
      endWhich

      #local m_index = cmd.method_info.global_index
      #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )


    method visit( cmd:CmdStaticCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        if (cmd.context?) cmd.context.dispatch( this )
        else              write_this
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd


    method visit( cmd:CmdSingletonCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        write( project_prefix )
        write( cmd.singleton_type.x_name )
        write( "_singleton" )
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd

    method visit( cmd:CmdDynamicCall )->Cmd
      local m = cmd.method_info.x_method

      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context

      if (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )

      else
        local context_type : Type
        contingent
          necessary (cmd.context?)
          context_type = cmd.context.type
          necessary (context_type.is_aspect)
        satisfied
          # Aspect Call
          write project_prefix
          write "_aspect_dispatch"
          write m.dispatch_signature
          write "("
          write context_type.index
          write ","
        unsatisfied
          # VTABLE Call
          write project_prefix
          write "_dynamic_dispatch"
          write m.dispatch_signature
          write "("
        endContingent
        write m.local_index
        write ","

        write_context( cmd.context )

        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf

        write ")"
      endIf

      #{
      if (cmd.context?)
        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf


      local context_type : Type
      contingent
        necessary (cmd.context?)
        context_type = cmd.context.type
        necessary (context_type.is_aspect)
      satisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.aspect_call_with_n_parameters,cmd.method_info.parameters.count) )
        write_code( cmd.t, context_type.index )
      unsatisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.dynamic_call_with_n_parameters,cmd.method_info.parameters.count) )
      endContingent
      write_code( cmd.t, cmd.method_info.local_index )
      }#

      return cmd

    method visit( cmd:CmdConcatenateStrings )->Cmd
      if (cmd.lhs.type.instance_of(Types.type_String) and cmd.rhs.type.instance_of(Types.type_String))
        write( "(" )
        cmd.lhs.dispatch( this )
        write( " + " )
        cmd.rhs.dispatch( this )
        write( ")" )
      else
        cmd.builder = cmd.builder.dispatch( this )
      endIf
      return cmd

    method visit( cmd:CmdAdd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " + " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdSubtract )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " - " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMultiply )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " * " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdDivide )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " / " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMod )->Cmd
      write( project_prefix )
      if (cmd.lhs.type.is_Real) write( "_mod_real( " )
      else                      write( "_mod_integer( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdPower )->Cmd
      write( "Math.pow( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdBitwiseAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " & " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " | " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdNegate )->Cmd
      write( "-" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalize )->Cmd
      write( "!!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseNot )->Cmd
      write( "~" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseSHL )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " << " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHR )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >>> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHRX )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " && " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " || " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalNot )->Cmd
      write( "!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIs )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareEQ )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareNE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIsNot )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " < " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " <= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " > " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCreateArray )->Cmd
      which (cmd.element_type.x_type.classification)
        case Type.reference_type: write( "new Array( " )
        case Type.real_type:      write( "new Float64Array( " )
        case Type.integer_type:   write( "new Int32Array( " )
        case Type.character_type: write( "new Uint16Array( " )
        case Type.byte_type:      write( "new Unit8Array( " )
        case Type.logical_type:   write( "new Uint8Array( " )
        case Type.compound_type:  throw Error("TODO")
      endWhich
      cmd.size_expression.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdArrayCount )->Cmd
      cmd.operand.dispatch( this )
      write( ".length" )
      return cmd

    method visit( cmd:CmdReadArrayElement )->Cmd
      if (cmd.element_type.is_Logical) write( "!!" )
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "]" )
      return cmd

    method visit( cmd:CmdWriteArrayElement )->Cmd
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "] = " )
      cmd.new_value.dispatch( this )
      return cmd
endClass

#{
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Type Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (type in Types.type_list)
        if (type.is_primitive) nextIteration

        #{
        }#

        if (type.is_native) nextIteration

        write( "struct " )
        write project_prefix
        writeln( type.x_name )
        writeln( "{" )
        writer.indent += 2

        if (type.property_list.count?)
          forEach (p in type.property_list) write_property_def( "p_", p )
          writeln
        endIf

        writer.indent -= 2
        writeln( "};" )
        writeln

        #{
        local must_create_table = true
        if (not type.is_functional)
          forEach (m in type.method_list)
            m = m.x_method
            if (m.referenced and (m.prior_method? or m.overridden))
              if (must_create_table)
                write project_prefix
                write( type.x_name )
                writeln( ".prototype.dispatch_table = [];" )
                must_create_table = false
              endIf

              write project_prefix
              write( type.x_name )
              write( ".prototype.dispatch_table[" )
              write( "" + m.local_index )
              write( "] = " )
              write project_prefix
              write( m.type_context.x_type.x_name )
              write( "__" )
              write( m.x_signature )
              writeln( ";" )
            endIf
          endForEach
        endIf
        }#

      endForEach

      #{
      forEach (m in Analyzer.method_list)
        if (not m.is_requisite) nextIteration

        writer.print( "function " )
        write project_prefix
        writer.print( m.type_context.x_type.x_name )
        writer.print( "__" )
        writer.print( m.x_signature )

        local parameter_count = m.parameters.count
        writer.print( "( THIS" )

        if (parameter_count? or this_type.is_functional)
          forEach (param in m.parameters)
            writer.print( ", " )
            writer.print( param.x_name )
          endForEach
        endIf
        writer.print( " )" )

        #if (m.return_type?)
        #  writer.print( " // ->" )
        #  writer.print( m.return_type.x_type.x_name )
        #endIf

        writeln

        if (not m.attributes.is_native)
          writeln( "{" )

          if (not m.type_context.is_aspect or m.full_signature == "init_settings()")
            m = m.x_method
            if (m.referenced)
              indent = 2
              needs_indent = true

#writeln( "console.log('$');" (m.context_signature) )
              visit( m )

              if (not previous_cmd_is_return and m.return_type?)
                if (m.is_initializer) writeln( "return THIS;" )
                else                  writeln( "Bard_throw_missing_return();" );
              endIf
            endIf
          endIf

          writer.indent -= 2
          writeln( "}" )
        endIf
        writeln
      endForEach
      }#

#---------------------------------------------------------------------------------------------------

class CPPWriter : Visitor
  PROPERTIES
    show_source = false : Logical

    this_type    : Type
    this_method  : Method

    writer       : Printer

    id_table     = Table<<String,String>>()

    indent       : Integer
    needs_indent : Logical
    previous_cmd_is_return : Logical

    project_prefix  = "Bard"
    setting_prefix  = ""
    property_prefix = ""

    dynamic_dispatch_signatures = Table<<String,Method>>()

  METHODS
    method compile( filepath:String )
      project_prefix = Analyzer.target_rules.prefix

      filepath = filepath.before_first(".bard").before_first(".h").before_first(".cpp")

      local cpp_filepath = filepath + ".cpp"
      local h_filepath = filepath + ".h"

      # TestApp.h -> TEST_APP_H
      local last_was_uppercase = false
      local buffer = StringBuilder()
      forEach (ch in h_filepath)
        if (ch.is_uppercase and buffer.count? and not last_was_uppercase) 
          buffer.print( '_' ).print(ch)
          last_was_uppercase = true
        elseIf (ch.is_letter)
          buffer.print( ch.to_uppercase )
          last_was_uppercase = ch.is_uppercase
        else
          buffer.print( '_' )
          last_was_uppercase = false
        endIf
      endForEach
      local ifdef_name = buffer->String

      # Build list of signatures used in dynamic dispatch
      local max_args = 0
      forEach (m in Analyzer.method_list)
        if (m.overridden)
          local sig = m.dispatch_signature
          if (not dynamic_dispatch_signatures.contains(sig))
            dynamic_dispatch_signatures[sig] = m
          endIf
        endIf
      endForEach

      # Write .h --------------------------------------------------------------
      writer = File(h_filepath).writer

      writeln( "#ifndef " + ifdef_name )
      writeln( "#define " + ifdef_name )
      writeln( "//=============================================================================" )
      writeln( "// $" (h_filepath) )
      writeln( "//=============================================================================" )
      writeln

      write_type_definitions

      writeln( "#endif //" + ifdef_name )
      writer.close

      # Write .cpp ------------------------------------------------------------
      writer = File(cpp_filepath).writer

      writeln( "//=============================================================================" )
      writeln( "// $" (cpp_filepath) )
      writeln( "//=============================================================================" )
      writeln
      writeln //#include "Bard.h"//
      writeln //#include "$"// (File(h_filepath).filename)
      writeln

      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Regular Method Prototypes" )
      writeln( "//-----------------------------------------------------------------------------" )
      write_method_prototypes( false )
      writeln
      writeln

      # Write out dynamic dispatch functions
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Dynamic Dispatch Functions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (sig in dynamic_dispatch_signatures.keys)
        local m = dynamic_dispatch_signatures[sig]
        if (m.return_type?) 
          write project_prefix
          write m.return_type.dispatch_name
          if (m.return_type.is_reference) write "*"
        else
          write "void"
        endIf
        write " "
        write project_prefix
        write "_dynamic_dispatch"
        write sig
        write "( int index, "
        write_c_type_name( m.type_context )
        write " THIS"
        local i = 1
        forEach (param in m.parameters)
          write ", "
          write_c_type_name( param.type )
          write " arg"
          write ""+i
          ++i
        endForEach
        writeln " )"
        writeln "{"

        indent += 2
        if (m.return_type?) write "return "
        write "(("
        write_c_type_name( m.return_type )
        write " (*)("
        write_c_type_name( m.type_context )
        forEach (param in m.parameters)
          write ","
          write_c_type_name( param.type )
        endForEach
        write ")"
        write ")(THIS->type->methods[index]))( THIS"
        forEach (i of m.parameters)
          write ", arg"
          write ""+i
        endForEach
        writeln " );"

        indent -= 2

        writeln "}"
        writeln
      endForEach

      # Write out aspect dispatch functions
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Aspect Dispatch Functions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (sig in dynamic_dispatch_signatures.keys)
        local m = dynamic_dispatch_signatures[sig]
        if (m.return_type?) 
          write project_prefix
          write m.return_type.dispatch_name
          if (m.return_type.is_reference) write "*"
        else
          write "void"
        endIf
        write " "
        write project_prefix
        write "_aspect_dispatch"
        write sig
        write "( int desired_aspect_type_index, int aspect_method_index, "
        write_c_type_name( m.type_context )
        write " THIS"
        local i = 1
        forEach (param in m.parameters)
          write ", "
          write_c_type_name( param.type )
          write " arg"
          write ""+i
          ++i
        endForEach
        writeln " )"
        writeln "{"

        writeln @|  BardVMType* desired_aspect = THIS->type->vm->types[desired_aspect_type_index];
                 |  BardVMNativeMethod* m;
                 |  
                 |  BardVMType**    aspect_type_ptr = type->aspect_types;
                 |  BardVMMethod*** aspect_call_table_ptr = type->aspect_call_tables;
                 |  while (*aspect_type_ptr != desired_aspect)
                 |  {
                 |    ++aspect_type_ptr;
                 |    ++aspect_call_table_ptr;
                 |  }
                 |  m = (*aspect_call_table_ptr)[ aspect_method_index ];

        write "  "
        if (m.return_type?) write "return "
        write "(("
        write_c_type_name( m.return_type )
        write " (*)("
        write_c_type_name( m.type_context )
        forEach (param in m.parameters)
          write ","
          write_c_type_name( param.type )
        endForEach
        write ")"
        write ")m)( THIS"
        forEach (i of m.parameters)
          write ", arg"
          write ""+i
        endForEach
        writeln " );"

        writeln "}"
        writeln
      endForEach

      #{
      # Write out method definitions as global functions.
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Method Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (m in Analyzer.method_list)
        this_type = m.type_context
        if (m.inline_mapping?) nextIteration
        if (this_type.is_compound and m.attributes.is_automatic) nextIteration # create() method

        this_method = m
        if (m.attributes.is_native) write( "// NATIVE " )
        write( "function " )
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )

        local parameter_count = m.parameters.count
        write( "( THIS" )

        if (parameter_count? or this_type.is_functional)
          forEach (param in m.parameters)
            write( ", " )
            write( param.x_name )
          endForEach
        endIf
        write " )"

        writeln

        if (not m.attributes.is_native)
          writeln( "{" )

          if (not m.type_context.is_aspect or m.full_signature == "init_settings()")
            m = m.x_method
            if (m.referenced)
              indent = 2
              needs_indent = true

              # Write all local variable declarations
              if (m.locals.count > m.parameters.count)
                write( "var " );
                local first = true
                forEach (i in m.parameters.count..<m.locals.count)
                  if (first) first = false
                  else       write ", "
                  write m.locals[i].x_name
                endForEach
                writeln ";"
              endIf

#writeln( "console.log('$');" (m.context_signature) )
              visit( m )

              if (not previous_cmd_is_return and m.return_type?)
                if (m.is_initializer)
                  writeln( "return THIS;" )
                else
                  write( project_prefix )
                  writeln( "_throw_missing_return();" );
                endIf
              endIf
            endIf
          endIf

          indent -= 2
          writeln( "}" )
        endIf
        writeln
      endForEach


      # Write out type definitions
      indent = 0
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Type Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (type in Types.type_list)
        if (type.is_compound or type.is_primitive) nextIteration

        if (type.settings_list.count?)
          write( "var " )
          write( project_prefix )
          write( type.x_name )
          writeln( "Settings = new function()" )
          writeln( "{" )
          indent += 2
          forEach (setting in type.settings_list)
            write( "this." )
            write( setting_prefix )
            write( setting.x_name )
            write( " = " )
            write_default_value_for_type( type )
            writeln( ";" )
          endForEach
          indent -= 2
          writeln( "};" )
          writeln
        endIf

        if (not type.is_native)
          write( "function " )
          write( project_prefix )
          write( type.x_name )
          writeln( "()" )
          writeln( "{" )
          indent += 2

          write( "this.type_name = " );
          write_literal( type.name )
          writeln( ";" )
          writeln

          if (type.property_list.count?)
            forEach (p in type.property_list) write_property_def( "this.", p )
            writeln
          endIf

          indent -= 2
          writeln( "}" )
          writeln
        endIf

        local must_create_table = true
        if (not type.is_functional)
          forEach (m in type.method_list)
            m = m.x_method
            if (m.inline_mapping?) nextIteration
            if (m.referenced and (m.prior_method? or m.overridden))
              if (must_create_table)
                write( project_prefix )
                write( type.x_name )
                writeln( ".prototype.dispatch_table = [];" )
                must_create_table = false
              endIf

              write( project_prefix )
              write( type.x_name )
              write( ".prototype.dispatch_table[" )
              write( "" + m.local_index )
              write( "] = " )
              write( project_prefix )
              write( m.type_context.x_type.x_name )
              write( "__" )
              write( m.x_signature )
              writeln( ";" )
            endIf
          endForEach
        endIf

        writeln
      endForEach

      # Singleton setup
      indent = 0
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Singletons" )
      writeln( "//-----------------------------------------------------------------------------" )

      forEach (type in Types.type_list)
        write( "var " )
        write( project_prefix )
        write( type.x_name )
        write( "_singleton" )
        write( " = " )
        if (type.is_primitive or type.is_compound or type.is_native)
          write_default_value_for_type( type )
        else
          write( " new " )
          write( project_prefix )
          write( type.x_name )
          write( "()" )
        endIf
        writeln(";")
      endForEach
      writeln

      writeln( "// Init settings" )
      forEach (type in Types.type_list)
        local m = type.x_type.find_method( "init_settings()" )
        if (m?)
          m = m.x_method
          if (m.referenced)
            write( project_prefix )
            write( type.x_name )
            writeln( "__init_settings();" )
          endIf
        endIf
      endForEach
      writeln

      writeln( "// Init defaults on true singletons" )
      forEach (type in Types.type_list)
        if (type.attributes.is_singleton)
          local m = type.x_type.find_method( "init_defaults()" )
          if (m?)
            m = m.x_method
            if (m.referenced)
              write_static_call( m )
              write( project_prefix )
              write( type.x_name )
              write( "_singleton" )
              writeln( " );" )
            endIf
          endIf
        endIf
      endForEach
      writeln

      writeln( "// Call init() on non-main true singletons" )
      forEach (type in Types.type_list)
        if (type.attributes.is_singleton and type isNot Types.main_type)
          local m = type.x_type.find_method( "init()" )
          if (m?)
            m = m.x_method
            if (m.referenced)
              write_static_call( m )
              write( project_prefix )
              write( type.x_name )
              write( "_singleton" )
              writeln( " );" )
            endIf
          endIf
        endIf
      endForEach
      writeln

      write( "function " )
      write( project_prefix )
      write( "_init_main_object()" )
      writeln( "{" )
      indent += 2
      local has_init_defaults = write_static_call( Types.main_type.x_type.find_method("init_defaults()") );
      local has_init = write_static_call( Types.main_type.x_type.find_method("init()") );

      write( project_prefix )
      write( Types.main_type.x_name )
      write( "_singleton" )

      if (has_init) write( " )" )
      if (has_init_defaults) write( " )" )

      writeln( ";" )
      indent -= 2
      writeln( "}" )

      writeln
      }#

      writer.close

    method write_c_type_name( type:Type )
      if (type?)
        type = type.x_type
        write project_prefix
        if (type.is_reference) write "Object"
        else write type.x_name
        if (type.is_reference) write "*"
      else
        write "void"
      endIf

    method write_static_call( m:Method )->Logical
      if (m is null) return false
      write( project_prefix )
      write( m.type_context.x_name )
      write( "__" )
      write( m.x_signature )
      write( "( " )
      return true

    method write_default_value_for_type( type:Type )
      which (type.classification)
        case Type.reference_type: write( "null" )
        case Type.real_type:      write( "0" )
        case Type.integer_type:   write( "0" )
        case Type.character_type: write( "0" )
        case Type.byte_type:      write( "0" )
        case Type.logical_type:   write( "false" )
        case Type.compound_type
          write( "{" )
          local first = true
          forEach (sub_property in type.property_list)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( sub_property.x_name )
            write( "':" )
            write_default_value_for_type( sub_property.type )
          endForEach
          write( "}" )
        others
          throw Error("TODO")
      endWhich

    method write_property_def( base_name:String, property:Property )
      write( base_name )
      write( property_prefix )
      write( property.x_name )
      write( " = " )
      write_default_value_for_type( property.type )
      writeln( ";" )
      #{
      local classification = property.type.classification
      if (classification == Type.compound_type)
        base_name += property.x_name + "_"
        forEach (sub_property in property.type.property_list)
          write_property_def( base_name, sub_property )
        endForEach
      else
        write( base_name )
        write( property.x_name )
        write( " = " )
        write_default_value_for_type( property.type )
        writeln( ";" )
      endIf
      }#

    method generate_temporary_local_name->String
      return "temp_" + Analyzer.unique_id

    method x_name( st:String )->String
      # Returns "st" as a valid identifier - the "cross compile name" or "x name".
      local result = id_table[ st ]
      if (result?) return result

      if (st.ends_with("()")) st = st.leftmost(-2)
      result = Analyzer.convert_string_to_valid_identifier( st )
      id_table[st] = result
      return result

      #{
    method collect_real( r:Real )->Integer
      if (real_table.contains(r)) return real_table[r]

      local index = real_table.count
      real_table[r] = index
      real_list.add( r )
      return index

    method collect_string( st:String )->Integer
      if (string_table.contains(st)) return string_table[st]

      local index = string_table.count
      string_table[st] = index
      string_list.add( st )
      return index

    method write( r:Real )
      local data = Int64( r as Int64 )
      write( data.right_shifted(32) as Integer )
      write( data as Integer )

    method write( st:String )
      write( st.count )
      forEach (ch in st) write( ch )

    method write_method_tables( type:Type )
      write( type.method_list.count )
      forEach (m in type.method_list)
        write( m.global_index )
      endForEach

      local aspect_count = 0
      forEach (base_type in type.base_types)
        if (base_type.is_aspect) ++aspect_count
      endForEach

      write( aspect_count )
      forEach (base_type in type.base_types)
        if (base_type.is_aspect)
          write( base_type.index )
          write( base_type.method_list.count )
          forEach (m in base_type.method_list)
            write( type.must_find_method(m.signature,m.return_type).global_index )
          endForEach
        endIf
      endForEach

    method write( m:Method )
      write( m.type_context.index )
      write( id_table[m.name] )
      write( m.parameters.count )
      if (m.return_type?) write( m.return_type.index )
      else                write( -1 )
      write( m.locals.count )

      forEach (v in m.locals)
        write( v.type.index )
      endForEach
      write( m.ip )
      write( m.ip_limit )
      write( m.line_info_index )

      write( m.attributes.flags )
      write( m.attributes.tags.count )
      forEach (tag in m.attributes.tags) write( id_table[tag] )

      write( m.exception_handlers.count )
      forEach (cur_handler in m.exception_handlers)
        write( cur_handler.ip_start )
        write( cur_handler.ip_limit )
        write( cur_handler.catches.count )
        forEach (cur_catch in cur_handler.catches)
          write( cur_catch.local_info.type.index )
          write( cur_catch.handler_ip )
          write( cur_catch.local_info.slot_index )
        endForEach
      endForEach

    method next_control_id->String
      return Analyzer.unique_id
      }#

    method visit( cmd:CmdStatementList )
      Analyzer.context.push_local_scope
      previous_cmd_is_return = false
      forEach (statement in cmd) 
        previous_cmd_is_return = false
        statement.dispatch( this )
        if (statement notInstanceOf CmdControlStructure and statement notInstanceOf CmdLocalDeclaration)
          write( ";" )
        endIf
        #{
        if (show_source)
          write( " /*" )
          write( statement.type_name )
          write( ": " )
          write( statement.to_String )
          write( "*/" )
        endIf
        }#
        writeln
      endForEach
      Analyzer.context.pop_local_scope

    method visit( cmd:CmdLocalDeclaration )->Cmd
      #write( "var " )
      #write( cmd.local_info.x_name )
      return cmd

      #{
    method visit( cmd:CmdTron )->Cmd
      write_code( cmd.t, Op.trace_on )
      return cmd

    method visit( cmd:CmdTroff )->Cmd
      write_code( cmd.t, Op.trace_off )
      return cmd
      }#

    method visit( cmd:CmdReturnNil )->Cmd
      previous_cmd_is_return = true
      if (this_method.is_initializer)
        write( "return THIS" )

      elseIf (this_type.is_compound)
        write( "TODO:compound return" )
        #write_code( cmd.t, opcode_with_embedded_n( Op.compound_return_nil_fp_adjust_n, this_type.slot_count) )

      else
        write( "return" )
      endIf
      return cmd

    method visit( cmd:CmdReturnThis )->Cmd
      previous_cmd_is_return = true
      writeln( "return THIS;" );
      return cmd

    method visit( cmd:CmdReturnValue )->Cmd
      write( "return " )
      cmd.operand.dispatch( this )
      previous_cmd_is_return = true
      return cmd

    method visit( cmd:CmdSpecializeReference )->Cmd
      cmd.operand = cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertIntegerToReal )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertRealToInteger )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "|0)" )
      return cmd

    method visit( cmd:CmdConvertCharacterToInteger )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertByteToInteger )->Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( cmd:CmdConvertIntegerToCharacter )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertIntegerToByte )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "&255)" )
      return cmd

    method visit( cmd:CmdConvertLogicalToInteger )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "&1)" )
      return cmd

    method visit( cmd:CmdIf )->Cmd
      write( "if (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )

      forEach (index of cmd.elseIf_conditions)
        local condition = cmd.elseIf_conditions[index]
        write( "else if (" )
        condition.dispatch( this )
        writeln( ")" )
        writeln( "{" )
        indent += 2
        cmd.elseIf_bodies[index].dispatch( this )
        indent -= 2
        writeln( "}" )
      endForEach

      if (cmd.else_body?)
        writeln( "else" )
        writeln( "{" )
        indent += 2
        cmd.else_body.dispatch( this )
        indent -= 2
        writeln( "}" )
      endIf

      previous_cmd_is_return = false

      return cmd

      #{
    method visit( cmd:CmdContingent )->Cmd
      cmd.control_id = next_control_id

      cmd.body.dispatch( this )

      if(cmd.satisfied_body?)
        define_label( "satisfied_" + cmd.control_id )
        cmd.satisfied_body.dispatch( this )
      endIf

      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      if(cmd.unsatisfied_body?)
        define_label( "unsatisfied_" + cmd.control_id )
        cmd.unsatisfied_body.dispatch( this )
      endIf

      if(not cmd.satisfied_body?)   define_label( "satisfied_" + cmd.control_id )
      if(not cmd.unsatisfied_body?) define_label( "unsatisfied_" + cmd.control_id )
      define_label("end_" + cmd.control_id)

      return cmd

    method visit( cmd:CmdNecessary )->Cmd

    method visit( cmd:CmdSufficient )->Cmd

    method visit( cmd:CmdEscapeContingent )->Cmd
      }#

    method visit( cmd:CmdAnonymousBlock )->Cmd
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )
      return cmd

    method visit( cmd:CmdWhile )->Cmd
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        cmd.control_id
        writeln( ":" )
      endIf
      write( "while (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )
      previous_cmd_is_return = false
      return cmd

      #{
    method visit( cmd:CmdEscapeWhich )->Cmd
      return cmd

    method visit( cmd:CmdEscapeWhile )->Cmd
      }#

    method visit( cmd:CmdLoop )->Cmd
      writeln( "for (;;)" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )

      previous_cmd_is_return = false

      return cmd

      #{
    method visit( cmd:CmdTry )->Cmd
      cmd.control_id = next_control_id

      local ip_start = code.count
      cmd.body.dispatch( this )
      local ip_limit = code.count
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      local m = Analyzer.context.this_method
      m.exception_handlers.add( ExceptionHandler(ip_start,ip_limit) )

      local catch_index = 0
      forEach (cur_catch in cmd.catches)
        Analyzer.context.push_local_scope
        Analyzer.add_local( cur_catch.local_info )
        local label_name = "catch_$_$_$" (cmd.control_id,m.exception_handlers.count-1,catch_index)
        define_label( label_name )
        m.exception_handlers.last.catches.add( ExceptionHandlerCatch(cur_catch.local_info,label_name) )
        cur_catch.body.dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
        Analyzer.context.pop_local_scope
        ++catch_index
      endForEach

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdThrow )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.throw_exception )
      return cmd

    method visit( cmd:CmdEscapeLoop )->Cmd
      }#

    method visit( cmd:CmdEscapeForEach )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

      #{
    method visit( cmd:CmdEscapeIf )->Cmd

    method visit( cmd:CmdEscapeTry )->Cmd

    method visit( cmd:CmdNextIteration )->Cmd
      }#

    method format_string( value:Real, decimal_digits:Integer )->String
      return StringBuilder().print(value,decimal_digits)->String

    method visit( cmd:CmdLiteralReal )->Cmd
      local fractional_part = Math.abs(cmd.value) - Math.floor( Math.abs(cmd.value) )
      forEach (decimal_digits in 1..9)
        local magnitude = 10.0 ^ decimal_digits
        if (fractional_part == (fractional_part*magnitude)->Integer / magnitude)
          write( format_string( cmd.value, decimal_digits) )
          return cmd
        endIf
      endForEach

      if (cmd.value == pi)
        write( "Math.PI" );
      else
        write( format_string( cmd.value, decimal_digits) )  # KLUDGE
      endIf

      #throw cmd.t.error( "TODO: real " + cmd.value )
      #write( "TODO:int64_bits_to_real(0x..." )
      #write( (cmd.value as Int64).to_String(16) )
      #write( ")" )

      return cmd

    method visit( cmd:CmdLiteralString )->Cmd
      write_literal( cmd.value )
      return cmd

    method visit( cmd:CmdLiteralNull )->Cmd
      write( "null" )
      return cmd

    method visit( cmd:CmdLiteralInteger )->Cmd
      write( ""+cmd.value )
      return cmd

    method visit( cmd:CmdLiteralByte )->Cmd
      write( ""+cmd.value )
      return cmd

    method visit( cmd:CmdLiteralArray )->Cmd
      write( "[" )

      local first = true
      forEach (element in cmd.elements)
        if (first) first = false
        else       write(",")
        element.dispatch( this )
      endForEach

      write( "]" )

      return cmd

    method visit( cmd:CmdLiteralCharacter )->Cmd
      write( ""+cmd.value->Integer )
      return cmd

    method visit( cmd:CmdLiteralLogical )->Cmd
      if (cmd.value) write( "true" )
      else           write( "false" )
      return cmd

    method visit( cmd:CmdReadLocal )->Cmd
      write( cmd.local_info.x_name )
      return cmd

    method visit( cmd:CmdWriteLocal )->Cmd
      #if (cmd.local_info.type.is_compound)
      #else
        write( cmd.local_info.x_name )
        write( " = " )
        cmd.new_value.dispatch( this )
      #endIf
      return cmd

    method visit( cmd:CmdWriteLocalDefault )->Cmd
      write( cmd.local_info.x_name )
      write( " = " )
      local v = cmd.local_info
      local type = v.type
      local opcode = -1
      which (type.classification)
        case Type.reference_type: write( "null" )
        case Type.real_type:      write( "0" )
        case Type.integer_type:   write( "0" )
        case Type.character_type: write( "0" )
        case Type.byte_type:      write( "0" )
        case Type.logical_type:   write( "false" )
        case Type.compound_type
          throw Error("TODO")
          #write_code( cmd.t, opcode_with_embedded_a_b(Op.clear_local_compound_slot_a_size_b,-v.slot_index,type.slot_count) )
        others
        throw cmd.t.error( "CmdWriteLocalDefault not implemented for type " + type + "." )
      endWhich

      return cmd

    method visit( cmd:CmdInstanceOf )->Cmd
      cmd.operand.dispatch( this )
      write( ".instance_of(" )
      write( project_prefix )
      write( "Types.type_" )
      write( cmd.target_type.x_type.x_name )
      write( ")" )
      return cmd

      #{
    method generate_local_op_assign( cmd:CmdOpAssignLocal, opcode:String, mask:Integer )
      write( cmd.local_info.x_name )
      write( " " )
      write( opcode )
      if (mask?)
        write( " (" )
        cmd.new_value.dispatch( this )
        write( " ) & " )
        write( ""+mask )
      else
        write( " " )
        cmd.new_value.dispatch( this )
      endIf

    method write_local_op_assign( cmd:CmdOpAssignLocal, opcode:String )->Cmd
      which (cmd.local_info.type.classification)
        case Type.real_type
          generate_local_op_assign( cmd, opcode, 0 )

        case Type.integer_type
          generate_local_op_assign( cmd, opcode, 0 )

        case Type.character_type
          generate_local_op_assign( cmd, opcode, 65535 )

        case Type.byte_type
          generate_local_op_assign( cmd, opcode, 255 )

        others
        throw cmd.t.error( "Variable type " + cmd.local_info.type.name + " does not support '" + cmd.name + "' operation." )
      endWhich

      return cmd
      }#

    method visit( cmd:CmdAssign )->Cmd
      cmd.operand.dispatch( this )
      write( " = " )
      cmd.new_value.dispatch( this )
      return cmd

      #{
    method visit( cmd:CmdAddAssignLocal )->Cmd
      return write_local_op_assign( cmd, "+=" )

    method visit( cmd:CmdConcatenateStrings )->Cmd
      cmd.builder = cmd.builder.dispatch( this )
      return cmd

    method visit( cmd:CmdSubtractAssignLocal )->Cmd
      return write_local_op_assign( cmd, "-=" )

    method visit( cmd:CmdMultiplyAssignLocal )->Cmd
      return write_local_op_assign( cmd, "*=" )

    method visit( cmd:CmdDivideAssignLocal )->Cmd
      return write_local_op_assign( cmd, "/=" )

    method visit( cmd:CmdModAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " = " )
      write( project_prefix )
      if (cmd.local_info.type.is_Real) write( "_mod_real( " )
      else                             write( "_mod_integer( " )
      write( cmd.local_info.x_name )
      write( ", " )
      cmd.new_value.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdPowerAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " = Math.pow( " )
      write( cmd.local_info.x_name )
      write( ", " )
      cmd.new_value.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdBitwiseAndAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " &= " )
      cmd.new_value.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseOrAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " |= " )
      cmd.new_value.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseXorAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " ^= " )
      cmd.new_value.dispatch( this )
      return cmd

    method visit( cmd:CmdAccessAssignLocal )->Cmd
      write( cmd.local_info.x_name )
      write( " = " )
      write( cmd.local_info.x_name )
      write( "." )
      cmd.access.dispatch( this )
      return cmd

    method visit( cmd:CmdAccessAssignSetting )->Cmd
      write("ZOMBIE(")
      cmd.access.dispatch( this )
      write(")")
      #{
      write( "." )
      write setting_prefix
      write( cmd.setting.x_name )
      write_code_with_arg_n( cmd.t, Op.resolve_write_s_, cmd.setting.index )
      write_code( cmd.t, cmd.setting.type_context.index )
      }#

      return cmd
      }#

    method visit( cmd:CmdIncrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.character_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " + 1 ) & 655335" )

        case Type.byte_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " + 1 ) & 255" )

        others
          write( "++" )
          write( cmd.local_info.x_name )
      endWhich
      return cmd

    method visit( cmd:CmdIncrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "++" )
      write( project_prefix )
      write( "Types.type_" )
      write( cmd.setting.type_context.x_name )
      write( ".settings." )
      write( setting_prefix )
      write( cmd.setting.type.x_type.x_name )

      which (cmd.setting.type.classification)
        case Type.character_type
          write( project_prefix )
          write( "Types.type_" )
          write( cmd.setting.type_context.x_name )
          write( ".settings." )
          write( setting_prefix )
          write( cmd.setting.type.x_type.x_name )
          write( " &= 65535" )

        case Type.byte_type
          write( project_prefix )
          write( "Types.type_" )
          write( cmd.setting.type_context.x_name )
          write( ".settings." )
          write( setting_prefix )
          write( cmd.setting.type.x_type.x_name )
          write( " &= 255" )

      endWhich

      return cmd

    method visit( cmd:CmdDecrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "--" )
      write( project_prefix )
      write( "Types.type_" )
      write( cmd.setting.type_context.x_name )
      write( ".settings." )
      write( setting_prefix )
      write( cmd.setting.type.x_type.x_name )

      which (cmd.setting.type.classification)
        case Type.character_type
          write( project_prefix )
          write( "Types.type_" )
          write( cmd.setting.type_context.x_name )
          write( ".settings." )
          write( setting_prefix )
          write( cmd.setting.type.x_type.x_name )
          write( " &= 65535" )

        case Type.byte_type
          write( project_prefix )
          write( "Types.type_" )
          write( cmd.setting.type_context.x_name )
          write( ".settings." )
          write( setting_prefix )
          write( cmd.setting.type.x_type.x_name )
          write( " &= 255" )

      endWhich

      return cmd

    method visit( cmd:CmdIncrementProperty )->Cmd
      if (cmd.context?)
        which (cmd.property.type.classification)
          case Type.character_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " + 1) & 65535" )

          case Type.byte_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " + 1) & 255" )

          others
            write( "++" )
            if (cmd.context?) cmd.context.dispatch( this )
            else              write_this
            write( "." )
            write( property_prefix )
            cmd.property.x_name
        endWhich
      else
        write( "++THIS." )
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdDecrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.character_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " - 1 ) & 655335" )

        case Type.byte_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " - 1 ) & 255" )

        others
          write( "--" )
          write( cmd.local_info.x_name )
      endWhich
      return cmd


    method visit( cmd:CmdDecrementProperty )->Cmd
      if (cmd.context?)
        which (cmd.property.type.classification)
          case Type.character_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " - 1) & 65535" )

          case Type.byte_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " - 1) & 255" )

          others
            write( "--" )
            if (cmd.context?) cmd.context.dispatch( this )
            else              write_this
            write( "." )
            write( property_prefix )
            cmd.property.x_name
        endWhich
      else
        write( "--THIS." )
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdNewObject )->Cmd
      local m = cmd.init_method.x_method
      if (cmd.of_type.new_object_inline_mappings?)
        local mapping = cmd.of_type.new_object_inline_mappings[ m.signature ]
        if (mapping?)
          write_inline_code( cmd.t, mapping, null, cmd.args )
          return cmd
        endIf
      endIf

      write( project_prefix )
      write( m.type_context.x_type.x_name )
      write( "__" )
      write( m.x_signature )
      write( "( " )

      local m = cmd.of_type.x_type.find_method( "init_defaults()" )

      if (m?)
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
      endIf

      write( "new " )
      write( project_prefix )
      write( cmd.of_type.x_type.x_name )
      write( "()" )

      if (m?) write( " )" )

      if (cmd.args?)
        forEach (arg in cmd.args)
          write( ", " )
          arg.dispatch( this )
        endForEach
      endIf
      write( " )" )

      return cmd

    method this_reference->String
      if (this_type.is_compound)
        return "THIS"
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        return "THIS"
      else
        return "THIS"
      endIf

    method write_this
      if (this_type.is_compound)
        write( "THIS" )
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        write( "THIS" )
      else
        write( "THIS" )
      endIf

    method write_context( context:Cmd )
      if (context?)
        context.dispatch( this )
      else
        write_this
      endIf

    method visit( cmd:CmdThis )->Cmd
      write_this
      return cmd

    method visit( cmd:CmdReadSingleton )->Cmd
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      else
        write( project_prefix )
        write( cmd.of_type.x_type.x_name )
        write( "_singleton" )
      endIf
      return cmd

    method visit( cmd:CmdWriteSingleton )->Cmd
      throw cmd.t.error( "TODO" )

    method visit( cmd:CmdReadSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( setting_prefix )
      write( cmd.setting.x_name )

      return cmd


    method visit( cmd:CmdReadProperty )->Cmd
      write_context( cmd.context )

      write(".")
      write( property_prefix )
      write( cmd.property.x_name )

      return cmd


    method visit( cmd:CmdWriteSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "_setting_" )
      write( setting_prefix )
      write( cmd.setting.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method visit( cmd:CmdWriteProperty )->Cmd
      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
      else
        write_this
      endIf
      write( "." )
      write( property_prefix )

      write( cmd.property.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method write_inline_code( t:Token, code:String, context:Cmd, args:CmdArgs )
      local marker = code.locate( '$' )
      while (marker >= 0)
        local i = marker + 1
        local arg_index = code[i].to_number 

        ++i
        while (i < code.count and code[i].is_number)
          arg_index = arg_index * 10 + code[i].to_number
          ++i
        endWhile

        write( code.leftmost(marker) )

        if (arg_index == 0)
          if (context?) context.dispatch( this )
          else          write_this
        elseIf (arg_index <= args.count)
          args[arg_index-1].dispatch( this )
        else
          throw t.error( "Error mapping inline code: index $ is out of range (must be 0..$)." (arg_index,args.count) )
        endIf

        code = code.substring(i)
        marker = code.locate( '$' )
      endWhile
      write( code )

    method write_function_call( m:Method, context:Cmd, args:CmdArgs )
      local buffer = StringBuilder()
      buffer.print( m.type_context.x_type.x_name )
      buffer.print( "__" )
      buffer.print( m.x_signature )
      local signature = buffer.to_String

      which (signature)
        case "Math__floor__Real"
          write( "Math.floor( " )
          args.first.dispatch( this )
          write( " )" )

        case "Math__sqrt__Real"
          write( "Math.sqrt( " )
          args.first.dispatch( this )
          write( " )" )

        case "Properties__add__Real", "Properties__add__Logical", "Properties__add__Properties", "Properties__add__String"
          write_context( context )
          write ".push("
          args.first.dispatch( this )
          write ")"

        case "Properties__get__Integer", "Properties__get__String"
          write_context( context )
          write "["
          args.first.dispatch( this )
          write "]"

        case "Properties__set__Integer_Properties",
             "Properties__set__Integer_Integer",
             "Properties__set__Integer_Logical",
             "Properties__set__Integer_Real",
             "Properties__set__Integer_String",
             "Properties__set__String_Properties",
             "Properties__set__String_Integer",
             "Properties__set__String_Logical",
             "Properties__set__String_Real",
             "Properties__set__String_String"
          write_context( context )
          write "["
          args[0].dispatch( this )
          write "] = "
          args[1].dispatch( this )

        case "Properties__to_String"
          write "JSON.stringify("
          write_context( context )
          write ")"

        case "PropertyList__create"
          write "[]"

        case "PropertyTable__create"
          write "{}"

        case "String__count"
          write_context( context )
          write( ".length" )

        case "String__get__Integer"
          write_context( context )
          write( ".charCodeAt( " )
          args.first.dispatch( this )
          write( " )" )

        others
          write( project_prefix )
          write( signature )

          if (context?)
            if (m.name == "create" and (args is null or args.count == 0))
              write( "()" )
              return
            else
              write( "( " )
              local context_type = context.type
              context.dispatch( this )
            endIf
          else
            write( "( " )
            write_this
          endIf

          if (args?)
            forEach (arg in args)
              write( ", " )
              arg.dispatch( this )
            endForEach
          endIf
          write(" )")
      endWhich

      #local m_index = cmd.method_info.global_index
      #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )


    method visit( cmd:CmdStaticCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        if (cmd.context?) cmd.context.dispatch( this )
        else              write_this
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd


    method visit( cmd:CmdSingletonCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        write( project_prefix )
        write( cmd.singleton_type.x_name )
        write( "_singleton" )
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd

    method visit( cmd:CmdDynamicCall )->Cmd
      local m = cmd.method_info.x_method

      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context

      if (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )

      else
        if (m.type_context.is_reference)
          write( project_prefix )
          write( "_dispatch_" + m.parameters.count )
          write( "( " )
          write( m.local_index + ", " )

          if (cmd.context?) cmd.context.dispatch(this)
          else              write_this

          if (cmd.args? and cmd.args.count?)
            forEach (arg in cmd.args)
              write( ", " )
              arg.dispatch( this )
            endForEach
          endIf
          write(" )")
        else
          throw Error("TODO")
        endIf
      endIf

      #{
      if (cmd.context?)
        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf


      local context_type : Type
      contingent
        necessary (cmd.context?)
        context_type = cmd.context.type
        necessary (context_type.is_aspect)
      satisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.aspect_call_with_n_parameters,cmd.method_info.parameters.count) )
        write_code( cmd.t, context_type.index )
      unsatisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.dynamic_call_with_n_parameters,cmd.method_info.parameters.count) )
      endContingent
      write_code( cmd.t, cmd.method_info.local_index )
      }#

      return cmd

    method visit( cmd:CmdConcatenateStrings )->Cmd
      if (cmd.lhs.type.instance_of(Types.type_String) and cmd.rhs.type.instance_of(Types.type_String))
        write( "(" )
        cmd.lhs.dispatch( this )
        write( " + " )
        cmd.rhs.dispatch( this )
        write( ")" )
      else
        cmd.builder = cmd.builder.dispatch( this )
      endIf
      return cmd

    method visit( cmd:CmdAdd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " + " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdSubtract )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " - " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMultiply )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " * " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdDivide )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " / " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMod )->Cmd
      write( project_prefix )
      if (cmd.lhs.type.is_Real) write( "_mod_real( " )
      else                      write( "_mod_integer( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdPower )->Cmd
      write( "Math.pow( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdBitwiseAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " & " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " | " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdNegate )->Cmd
      write( "-" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalize )->Cmd
      write( "!!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseNot )->Cmd
      write( "~" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseSHL )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " << " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHR )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >>> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHRX )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " && " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " || " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalNot )->Cmd
      write( "!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIs )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareEQ )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareNE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIsNot )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " < " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " <= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " > " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCreateArray )->Cmd
      which (cmd.element_type.x_type.classification)
        case Type.reference_type: write( "new Array( " )
        case Type.real_type:      write( "new Float64Array( " )
        case Type.integer_type:   write( "new Int32Array( " )
        case Type.character_type: write( "new Uint16Array( " )
        case Type.byte_type:      write( "new Unit8Array( " )
        case Type.logical_type:   write( "new Uint8Array( " )
        case Type.compound_type:  throw Error("TODO")
      endWhich
      cmd.size_expression.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdArrayCount )->Cmd
      cmd.operand.dispatch( this )
      write( ".length" )
      return cmd

    method visit( cmd:CmdReadArrayElement )->Cmd
      if (cmd.element_type.is_Logical) write( "!!" )
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "]" )
      return cmd

    method visit( cmd:CmdWriteArrayElement )->Cmd
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "] = " )
      cmd.new_value.dispatch( this )
      return cmd
endClass

      }#
