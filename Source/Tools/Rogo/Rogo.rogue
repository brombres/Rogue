#$ ROGUEC       = roguec
#$ ROGUEC_ARGS  = --whatever
#$ CPP          = g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof
#$ CPP_ARGS     = -a -b -c
#$ LINK         = true              # Links following LIBRARIES with this Build file
#$ LINK         = -lalpha -lbeta    # Links following LIBRARIES and includes these additional flags
#$ LINK         = false             # Linking turned off for following LIBRARIES
#$ LIBRARIES    = libalpha
#$ LIBRARIES    = libbeta(library-name)
#$ LIBRARIES    = libfreetype6-dev(freetype2)
#$ DEPENDENCIES = Library/Rogue/**/*.rogue

#$ LIBRARIES    = name(package)
#$ LIBRARIES    = name(package:<package> install:<install-cmd> link:<link-flags> which:<which-name>)

# Build.rogue source replacements - the libraries should also be declared in #$ LIBRARIES:
#   $LIBRARY_FLAGS(lib1,lib2) -> -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...

# Command Line Option
#
# --build=<filepath>
#   Compiles and runs the .rogue file at the given filepath.
#
# --create
#   Creates a default Build.rogue file.

global rogo_folder    : String
global cache_filepath : String
global config         : Value
global cache          : Value
global is_cache_modified : Logical
global link_setting = false
#global link_args = ""
global package_manager = "apt"
global package_manager_install = "sudo apt-get install"
global package_manager_list    : String

local buildfiles = Files( "." )

local should_create = false
local buildfile : String
local cmd_line_args = String[]
forEach (arg in System.command_line_arguments)
  if (arg == "--build" or arg.begins_with("--build="))
    local cur_buildfile = arg.after_first( '=' )
    if (cur_buildfile.count == 0)
      Console.error.println ''ERROR: expected filename after "--build=".''
      System.exit 1
    endIf
    if (not File.exists(cur_buildfile))
      if (File.exists(cur_buildfile + ".rogue"))
        cur_buildfile += ".rogue"
      else
        Console.error.println ''ERROR: no such file "$".'' (cur_buildfile)
        System.exit 1
      endIf
    endIf
    buildfiles = Files( File.folder(cur_buildfile), File.filename(cur_buildfile) )
    buildfile = cur_buildfile

  else
    if (arg == "--create") should_create = true
    cmd_line_args.add( arg )
  endIf
endForEach

if (buildfile) rogo_folder = File.folder( File.absolute_filepath(buildfile) ) + "/.rogo"
else           rogo_folder = ".rogo"

File.create_folder( rogo_folder )
cache_filepath = "$/Cache-$.json" (rogo_folder,System.os)
config         = @{ roguec:"roguec", filepath:cache_filepath }
cache          = JSON.load_table( File(cache_filepath) )

local compiler_invocation : String
native @|#if defined(DEFAULT_CXX)
        |  $compiler_invocation = RogueString_create_from_utf8( DEFAULT_CXX );
        |#else
           which (System.os)
             case "Windows"
               compiler_invocation = "cl /EHsc /nologo"
             others
               compiler_invocation = "g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof"
           endWhich
native @|#endif

config//cpp = compiler_invocation

if (not buildfile)
  # These add()s only succeed for files that actually exist.
  buildfiles.add( "Build.rogue" )
  buildfiles.add( "BuildCore.rogue" )
  buildfiles.add( "BuildLocal.rogue" )
endIf

if (not buildfiles.count)
  if (should_create)
    println "Creating Build.rogue with default Rogo framework."
    cmd_line_args.clear

    File.save( "Build.rogue",
      @|# To run this build file, install Rogue from github.com/AbePralle/Rogue and type "rogo" at the command line.
       |
       |# Rogo is a "build your own build system" facilitator. At its core Rogo just recompiles build files if
       |# needed and then runs the build executable while forwarding any command line arguments. This file contains
       |# a default framework which uses introspection to turn command line arguments into parameterized routine calls.
       |
       |# Example: to handle the command "rogo abc xyz 5", define "routine rogo_abc_xyz( n:Int32 )".
       |
       |# "rogo_default" will run in the absence of any other command line argument.
       |
       |# The following "comment directives" can be used in this file to control how RogueC compiles it and to
       |# manage automatic dependency installation and linking.
       |
       |# Each of the following should be on a line beginning with the characters #$ (preceding whitespace is fine).
       |# Sample args are given.
       |
       |#   ROGUEC       = roguec       # Path to roguec compiler to compile this file with
       |#   ROGUEC_ARGS  = --whatever   # Additional options to pass to RogueC
       |#   CPP          = g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof   # C++ compiler path and/or invocation
       |#   CPP_ARGS     = -a -b -c          # Additional C++ args
       |#   LINK         = true              # Links following LIBRARIES with this Build file
       |#   LINK         = -lalpha -lbeta    # Links following LIBRARIES and includes these additional flags
       |#   LINK         = false             # Linking turned off for following LIBRARIES - info can still be obtained from #$LIBRARY_FLAGS()
       |#   LINK(macOS)  = ...               # Options applying only to System.os=="macOS" (use with any OS and any comment directive)
       |#   LIBRARIES    = libalpha
       |#   LIBRARIES    = libbeta(library-name)
       |#   LIBRARIES    = libfreetype6-dev(freetype2)
       |#   DEPENDENCIES = Library/Rogue/**/*.rogue
       |#
       |#   LIBRARIES    = name(package)
       |#   LIBRARIES    = name(package:<package> install:<install-cmd> link:<link-flags>)
       |#
       |# The following macro is replaced within this file (Build.rogue) - the libraries should also be declared in #$ LIBRARIES:
       |#
       |#   $LIBRARY_FLAGS(lib1,lib2)                              # sample macro
       |#     ->
       |#   -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...   # sample replacement
       |
       |# description()s are optional - Rogo uses introspection to determine which commands are available.
       |# 'rogo help default' displays the description for "default", etc.
       |description( "default", "The default action is performed when no other actions are specified. Use 'rogo default' to explicitly perform the default option." )
       |description( "help",    "Displays a list of all actions that can be performed by Rogo." )
       |
       |routine rogo_default
       |  rogo_help
       |endRoutine
       |
       |routine execute( commands:String, &suppress_error )->Logical
       |  forEach (cmd in LineReader(commands))
       |    print( "> " ).println( cmd )
       |    if (System.run(cmd) != 0)
       |      if (suppress_error) return false
       |      else                throw Error( "Build failed." )
       |    endIf
       |  endForEach
       |  return true
       |endRoutine
       |
       |#------------------------------------------------------------------------------
       |# Introspection-based Launcher Framework
       |#------------------------------------------------------------------------------
       |routine syntax( command:String, text:String )
       |  Build.rogo_syntax[ command ] = text
       |endRoutine
       |
       |routine description( command:String, text:String )
       |  Build.rogo_descriptions[ command ] = text
       |endRoutine
       |
       |routine help( command:String, description=null:String, syntax=null:String )
       |  if (description) Global.description( command, description )
       |  if (syntax)      Global.syntax( command, syntax )
       |endRoutine
       |
       |try
       |  Build.launch
       |catch (err:Error)
       |  Build.rogo_error = err
       |  Build.on_error
       |endTry
       |
       |class Build [singleton]
       |  PROPERTIES
       |    rogo_syntax         = StringTable<<String>>()
       |    rogo_descriptions   = StringTable<<String>>()
       |    rogo_prefix         = ?:{ $moduleName.count:$moduleName "::" || "" } + "rogo_" : String
       |    rogo_command        = "default"
       |    rogo_args           = @[]
       |    rogo_error          : Error
       |
       |    LOCAL_DEFS_FILE     = "Local.mk"
       |
       |  METHODS
       |    method launch
       |      rogo_args.add( forEach in System.command_line_arguments )
       |      read_defs
       |      on_launch
       |      parse_args
       |      dispatch_command
       |
       |    method dispatch_command
       |      local m = find_command( rogo_command )
       |      require m
       |
       |      local args = @[]
       |      forEach (arg in rogo_args)
       |        which (arg)
       |          case "true":  args.add( true )
       |          case "false": args.add( false )
       |          case "null":  args.add( NullValue )
       |          others:       args.add( arg )
       |        endWhich
       |      endForEach
       |      if (m.parameter_count == 1 and args.count > 1) args = @[ args ] # Wrap args in a ValueList.
       |      m.call( Global, args )
       |
       |    method find_command( name:String )->MethodInfo
       |      return <<Global>>.find_method( rogo_prefix + name )
       |
       |    method on_error
       |      Console.error.println "=" * 79
       |      Console.error.println rogo_error
       |      Console.error.println "=" * 79
       |      on_exit
       |      System.exit 1
       |
       |    method on_command_found
       |      noAction
       |
       |    method on_command_not_found
       |      println "=" * 79
       |      println "ERROR: No such command '$'." (rogo_args.first)
       |      println "=" * 79
       |      println
       |      rogo_command = "help"
       |      rogo_args.clear
       |      on_command_found
       |
       |    method on_launch
       |      noAction
       |
       |    method on_exit
       |      noAction
       |
       |    method parse_args
       |      block
       |        if (rogo_args.count)
       |          local parts = String[]
       |          parts.add( forEach in rogo_args )
       |          rogo_args.clear
       |
       |          while (parts.count)
       |            local cmd = _join( parts )
       |            if (find_command(cmd))
       |              rogo_command = cmd
       |              on_command_found
       |              escapeBlock
       |            endIf
       |            rogo_args.insert( parts.remove_last )
       |          endWhile
       |
       |          on_command_not_found
       |        endIf
       |
       |        # Use default command
       |        on_command_found
       |      endBlock
       |
       |    method read_defs
       |      read_defs( LOCAL_DEFS_FILE )
       |
       |    method read_defs( defs_filepath:String )
       |      # Attempt to read defs from Local.mk
       |      local overrides = String[]
       |      if (File.exists(defs_filepath))
       |        forEach (line in LineReader(File(defs_filepath)))
       |          if (line.contains("="))
       |            local name  = line.before_first('=').trimmed
       |            local value = line.after_first('=').trimmed
       |            if (value.begins_with('"') or value.begins_with('\''))
       |              value = value.leftmost(-1).rightmost(-1)
       |            endIf
       |            local p = <<Build>>.find_property( name )
       |            if (p)
       |              overrides.add( "$ = $" (name,value) )
       |              <<Build>>.set_property( this, p, Value(value) )
       |            endIf
       |          endIf
       |        endForEach
       |      endIf
       |
       |    method _join( value:Value )->String
       |      local args = String[]
       |      args.add( forEach in value )
       |      return args.join( "_" )
       |endClass
       |
       |
       |routine rogo_help( command="":String )
       |  command = Build._join( Build.rogo_args )
       |  if (command.count)
       |    local syntax = get_syntax( command )
       |    local success = false
       |    if (syntax)
       |      println "SYNTAX"
       |      println "  " + syntax
       |      println
       |      success = true
       |    endIf
       |    local description = get_description( command )
       |    if (description)
       |      println "DESCRIPTION"
       |      forEach (line in LineReader(description.word_wrapped(76)))
       |        print( "  " ).println( line )
       |      endForEach
       |      println
       |      success = true
       |    endIf
       |    if (success)
       |      return
       |    else
       |      println "=" * 79
       |      println "ERROR: No such command '$'." (command)
       |      println "=" * 79
       |      println
       |    endIf
       |  endIf
       |
       |  println "USAGE"
       |  local lines = String[]
       |  forEach (m in <<Global>>.methods)
       |    if (m.name.begins_with(Build.rogo_prefix))
       |      lines.add( "  " + get_syntax(m.name.after_first(Build.rogo_prefix)) )
       |    endIf
       |  endForEach
       |  lines.sort( (a,b)=>(a<b) )
       |  println (forEach in lines)
       |  println
       |endRoutine
       |
       |
       |routine get_syntax( m_name:String )->String
       |  if (Build.rogo_syntax.contains(m_name))
       |    return "rogo " + Build.rogo_syntax[ m_name ]
       |  else
       |    local m = <<Global>>.find_method( Build.rogo_prefix + m_name )
       |    if (not m) return null
       |    local line = "rogo $" (m_name.replacing('_',' '))
       |    line += " <$>" (m.parameter_name(forEach in 0..<m.parameter_count))
       |    return line
       |  endIf
       |endRoutine
       |
       |
       |routine get_description( m_name:String )->String
       |  if (Build.rogo_descriptions.contains(m_name))
       |    return Build.rogo_descriptions[ m_name ]
       |  else
       |    return null
       |  endIf
       |endRoutine
    )
    buildfiles.add( "Build.rogue" )

  else
    local w = (Console.width - 1).or_smaller( 79 )
    loop (w) do Console.error.print( '=' )
    Console.error.println
    local mesg = "ROGO ERROR\n\n"
    mesg += @|No standard build file exists (Build.rogue, BuildCore.rogue, BuildLocal.rogue)
    mesg += @| and no alternate specified with --build=<filename>.
             |
             |
    mesg += @|Type 'rogo --create' to create Build.rogue with a default framework.
    Console.error.println( mesg.word_wrapped(w) )
    loop (w) do Console.error.print( '=' )
    Console.error.println
    System.exit 1
  endIf
endIf

local exe : String
if (buildfile is null)
  buildfile = buildfiles[0]
  exe = "$$Build" (rogo_folder,File.separator)
else
  exe = "$$$" (rogo_folder,File.separator,File.filename(buildfile).before_first('.'))
endIf
local base_name = exe   # e.g. Build
if (System.os == "Windows") exe += ".exe"
else                        exe += "-" + System.os  # e.g. Build-macOS

configure_os

local needs_recompile = buildfiles.any_newer_than( exe )
block
  local dependencies = StringLookupList()
  scan_and_rewrite( File(forEach in buildfiles), dependencies, &skip_rewrite, &dependencies_only )

  local i = 0
  while (i < dependencies.count)
    local pattern = dependencies[ i ]
    local listing = File.listing( ".", FilePattern(pattern), &files )
    forEach (dependency in listing)
      if (File.filename(dependency).begins_with("Build") and not buildfiles.contains(dependency))
        scan_and_rewrite( dependency, dependencies, &skip_rewrite )
      endIf
    endForEach
    ++i
  endWhile

  forEach (pattern in dependencies)
    local listing = File.listing( ".", FilePattern(pattern), &files )
    forEach (dependency in listing)
      if (File.is_newer_than(dependency,exe))
        needs_recompile = true
        escapeBlock
      endIf
    endForEach
  endForEach
endBlock

if (needs_recompile)
  println "Recompiling $..." (buildfile)

  # Collect info for config
  scan_and_rewrite( File(forEach in buildfiles), &skip_rewrite )

  # Select ROGUEC(macOS) or ROGUEC(Linux) etc. based on the OS and copy to ROGUEC, etc.
  local os_arg = "($)" (System.os.to_lowercase)
  local os_arg_plus_package_manager = "($-$)" (System.os.to_lowercase,package_manager)
  forEach (key in config.keys)
    if (key.contains(os_arg) or key.contains(os_arg_plus_package_manager))
      config[ key.before_first('(') ] = config[ key ]
    endIf
  endForEach

  # Now that we have the config info, rewriting to handle $ LIBRARY(name) etc. Places copies in .rogo/
  scan_and_rewrite( File(forEach in buildfiles), &skip_directives )

  local roguec = config//roguec
  if (not File.exists(roguec)) roguec = "roguec"  # use system default
  local roguec_args = config//roguec_args->String
  local cmd =  "$ --target=C++,Console,$" (roguec,System.os)
  cmd += " $$$" (rogo_folder,File.separator,File.filename(forEach in buildfiles))
  cmd += " --api --debug --main --output=$ $" (base_name,roguec_args)
  println cmd
  if (0 != System.run(cmd))
    Console.error.println "ERROR compiling $." (buildfile)
    System.exit 1
  endIf

  cmd = "$ $ $.cpp" (config//cpp,config//cpp_args,base_name)

  local is_windows = (System.os == "Windows")

  forEach (library in config//libraries)
    install_library( library )
    if (library//link)
      cmd += " $" (library_flags(library))
    endIf
  endForEach

  cmd += " $$" (?:{is_windows:"/Fe"||"-o "},exe)
  local link_args = config//link
  if (link_args != "") cmd += " " + link_args

  println cmd
  if (0 != System.run(cmd)) System.exit( 1 )
  File.delete( File.filename(exe).before_last(".exe") + ".obj" )
endIf

System.exit( System.run(''$ $'' (exe,cmd_line_args.map<<String>>( (arg)=>prep_arg(arg) ).join(" "))) )

routine prep_arg( arg:String )->String
  # Quotes and escapes string if necessary
  if (not (arg.contains(' ') or arg.contains('"') or arg.contains('\\'))) return arg
  local quoted = StringBuilder()
  quoted.print( '"' )
  forEach (ch in arg)
    which (ch)
      case '"':  quoted.print( "\\\"" )
      case '\\': quoted.print( "\\\\" )
      others:    quoted.print( ch )
    endWhich
  endForEach
  quoted.print( '"' )
  return quoted
endRoutine

routine require_command_line
  if (System.environment["IDE"])
    throw Error( "$:$: error:Run 'make $' from the command line to install necessary libraries."...
    ($sourceFilepath,$sourceLine,select{System.environment["TARGET"]||""}.to_lowercase) )
  endIf
endRoutine


routine save_cache
  is_cache_modified = false
  cache.save( File(cache_filepath), &formatted )
endRoutine

routine configure_os
  which (System.os)
    case "macOS"
      configure_macos
    case "Linux"
      configure_linux
  endWhich
endRoutine

routine configure_macos
  if (0 != System.run("which brew > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "\nHomebrew must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install Homebrew." )
      endIf
    else
      throw Error( "Missing required dependency 'brew' (Homebrew)." )
    endIf

  endIf

  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|brew install pkg-config
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf

  endIf
endRoutine

routine configure_linux
  if (0 != System.run("which apt-get > /dev/null 2>&1"))
    if (0 == System.run("which yum > /dev/null 2>&1"))
      package_manager = "yum"
      package_manager_install = "sudo yum install"
      package_manager_list    = "rpm -ql"
    endIf
  endIf

  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = package_manager_install + " pkg-config"
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf
  endIf
endRoutine

routine install_library( library:Value )
  local lib = cache//library_flags[ library//name ]
  if (lib) return

  which (System.os)
    case "macOS"
      install_macos_library( library )
    case "Linux"
      install_linux_library( library )
    others
      throw Error( ''Rogo does not know how to install a library for "$".'' (System.os) )
  endWhich
endRoutine

routine run( cmd:String )->String
  println(cmd).flush
  local result = Process.run( cmd )
  if (result.exit_code != 0) return null
  return result.output_string.trimmed
endRoutine

routine find_macos_library( library:Value )->Logical
  local name = library//name->String
  local package = library//package->String

  local result = run( "  pkg-config --cflags " + package )
  if (result)
    local flags = String[]

    # cflags
    flags.add( result )

    # static library path
    local candidates : String[]
    result = run( "  pkg-config --libs-only-L " + package )
    if (result and result.begins_with("-L"))
      candidates = File.listing( result.from(2) )
    else
      result = run( "  brew list -v " + name )
      if (result)
        candidates = result.split( '\n' )
      endIf
    endIf

    if (candidates)
      candidates.keep( $.ends_with(".a") )
      if (candidates.count) flags.add( candidates.first )  # .a file to link in
    else
      return false
    endIf

    local all_flags = flags.join( ' ' )
    println "  Library flags: $" (all_flags)
    cache.ensure_table("library_flags")[ name ] = all_flags
    save_cache
    return true
  endIf

  # "Library" may be executable package - use 'which' to check.
  if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
    cache.ensure_table("library_flags")[ name ] = ""  # package exists but has no flags
    save_cache
    return true
  endIf

  return false
endRoutine

routine install_macos_library( library:Value )
  local library_name = library//name->String
  println "Checking for library $..." (library_name)

  if (not find_macos_library(library))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    run( "brew install $" (install_cmd) )  # this could succeed in principal but return non-zero with a warning, as with zlib
    if (not find_macos_library(library))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf
  endIf
endRoutine

routine find_linux_library( library:Value )->Logical
  local name = library//name->String
  local package = library//package->String

  # Try pkg-config first
  local result = run( "  pkg-config --cflags --libs " + package )
  if (result)
    local flags = result
    println "  Library flags: $" (flags)
    cache.ensure_table("library_flags")[ name ] = flags
    save_cache
    return true
  endIf

  # Next try rpm -ql for Yum+RPM Linux
  if (package_manager_list)
    println "  No found with pkg-config; checking with rpm"
    result = run( "  $ $" (package_manager_list,package) )
    if (result)
      println "  Located"
      cache.ensure_table("library_flags")[ name ] = ""  # library exists but has no flags
      save_cache
      return true
    endIf
  endIf

  # "Library" may be executable package - use 'which' to check.
  if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
    cache.ensure_table("library_flags")[ name ] = ""  # package exists but has no flags
    save_cache
    return true
  endIf

  return false
endRoutine

routine install_linux_library( library:Value )
  local library_name = library//name->String

  println "Checking for library $..." (library//name->String)

  if (not find_linux_library(library))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    local cmd = "$ $" (package_manager_install,install_cmd)
    print "> "
    println cmd
    if (System.run(cmd) or not find_linux_library(library))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf
  endIf
endRoutine

routine library_flags( library:Value )->String
  if (not cache//library_flags.contains(library//name))
    install_library( library )
  endIf

  return cache//library_flags[library//name]->String
endRoutine

routine scan_and_rewrite( file:File, dependencies=null:StringLookupList, &skip_rewrite, &skip_directives, &dependencies_only )
  # Note: the organization and usage of this method has become inelegant over time. Could use a refactoring.
  if (not file.exists) return

  local writer : PrintWriter
  if (not skip_rewrite) writer = PrintWriter( File("$/$"(rogo_folder,file.filename)).writer )
  forEach (original_line in LineReader(file))
    local line = original_line.trimmed
    if (not skip_directives)
      if (line.begins_with("#$"))
        local cmd = line.rightmost( -2 )
        local args = cmd.after_first( "=" ).trimmed
        cmd = cmd.before_first( "=" ).trimmed.to_lowercase

        local base_cmd = cmd.before_first('(')
        which (base_cmd)
          case "config", "roguec"
            if (not dependencies_only)
              if (args.begins_with('"')) args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              config[ cmd ] = args
            endIf

          case "libraries"
            if (args.count and not dependencies_only)
              local parser = JSONParser( Scanner(args) )
              parser.consume_spaces
              while (parser.has_another)
                local name = parse_filepath( parser )
                local entry = @{ name:name, link:link_setting }
                config.ensure_list( cmd ).add( entry )
                parser.consume_spaces
                entry//package = name.before_first( "-dev" )  # default of e.g. libpng-dev is libpng
                entry["which"] = name
                if (parser.consume('('))
                  parser.consume_spaces
                  while (parser.has_another)
                    if (parser.consume(')')) escapeWhile
                    local key = parser.parse_identifier
                    parser.consume_spaces
                    if (parser.consume(':'))
                      parser.consume_spaces
                      local value = parse_filepath( parser )
                      entry[ key ] = value
                    else
                      # An identifier with no mapped value is treated as the package name
                      entry//package = key
                    endIf
                    parser.consume_spaces
                    parser.consume( ',' )
                    parser.consume_spaces
                  endWhile
                endIf
                parser.consume_spaces
              endWhile
            endIf

          case "dependencies"
            if (dependencies)
              if (args.begins_with('"'))       args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              dependencies.add( args )
              is_cache_modified = true
            endIf

          others
            if (not dependencies_only)
              if (base_cmd == "link")
                if (cmd == "link" or cmd == "link($)" (System.os.to_lowercase))
                  if (args == "true" or args == "false")
                    # LINK true or LINK false
                    link_setting = (args == "true")
                  else
                    # LINK <args> implies LINK true
                    link_setting = true
                    if (config[cmd]?) config[cmd] += " " + args
                    else              config[cmd] = args
                  endIf
                endIf

              else
                # Join into single space-separated string
                if (config.contains(cmd))
                  config[ cmd ] = "$ $" (config[ cmd ],args)
                else
                  config[ cmd ] = args
                endIf
              endIf
            endIf

        endWhich
      endIf
    endIf

    if (not skip_rewrite)
      line = original_line
      local dollar = line.locate( '$' )
      while (dollar.exists)
        if (line.contains_at("$LIBRARY_FLAGS(",dollar.value))
          local close_paren = line.locate( ')', dollar.value + 1 )
          if (close_paren.exists)
            local replacement = ""
            forEach (library_name in line.from(dollar.value,close_paren.value-1).after_first('(').split(','))
              library_name = library_name.trimmed
              block
                forEach (lib in config//libraries)
                  if (lib//name == library_name)
                    if (replacement.count > 0) replacement += " "
                    replacement += library_flags( lib )
                    escapeBlock
                  endIf
                endForEach
              endBlock
            endForEach
            line = "$$$" (line.before(dollar.value),replacement,line.after(close_paren.value))
          endIf
        endIf
        dollar = line.locate( '$', dollar.value+1 )
      endWhile
      writer.println( line )
    endIf
  endForEach
  if (not skip_rewrite) writer.close

endRoutine

routine parse_filepath( parser:JSONParser )->String
  if (parser.next_is('"')) return parser.parse_string

  local buffer = StringBuilder()
  while (parser.has_another and not " \n()".contains(parser.peek)) buffer.print( parser.read )

  if (buffer.count == 0) buffer.print( parser.read )

  return buffer->String
endRoutine
