$include "Augment.rogue"

class RequisiteItem( t:Token, type:Type, signature=null:String );

class Program [requisite singleton]
  PROPERTIES
    code_prefix  = "Rogue"
    program_name = "Rogue_program"

    unique_integer : Int32

    template_list   = Template[]
    template_lookup = Table<<String,Template>>()

    augment_lookup = Table<<String,Augment[]>>()
    #requisite_list = RequisiteItem[]

    all_requisite = false # Make everything requisite

    first_filepath           = ""
    m_on_launch              : Method
    global_properties        = Property[]

    native_header = String[]
    native_code   = String[]

    methods_by_signature = Table<<String,Method[]>>()

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_null        : Type
    type_Real64        : Type
    type_Real32       : Type
    type_Int64        : Type
    type_Int32     : Type
    type_Character   : Type
    type_Byte        : Type
    type_Logical     : Type

    type_Object      : Type
    type_String      : Type
    type_NativeArray : Type
    type_GenericList : Type
    type_Global      : Type
    type_Exception   : Type

    type_StringBuilder : Type

    literal_string_lookup = Table<<String,Int32>>() : Table<<String,Int32>>
    literal_string_list   = String[]

    string_buffer = StringBuilder()
    ids_by_module = Table<<String,String[]>>()

  METHODS
    method add_literal_string( value:String )->Int32
      if (not value) return 0

      local entry = literal_string_lookup.find( value )
      if (entry)
        return entry.value
      else
        local index = literal_string_list.count
        literal_string_lookup[value] = index
        literal_string_list.add( value )
        return index
      endIf

    method add_module_id( module_name:String, id_name:String )
      local list = ids_by_module[ module_name ]
      if (not list)
        list = String[]
        ids_by_module[ module_name ] = list
      endIf
      list.add( id_name )

    method add_template( template:Template )
      local existing_template = template_lookup[ template.name ]

      contingent
        local param_count = template.type_parameter_count
        sufficient (not existing_template)
        necessary (param_count != existing_template.type_parameter_count)

        if (not existing_template.alternates_by_param_count)
          existing_template.alternates_by_param_count = Table<<Int32,Template>>()
        endIf
        necessary (not existing_template.alternates_by_param_count.contains(param_count))

        existing_template.alternates_by_param_count[ param_count ] = template
        escapeContingent

      satisfied
        template_list.add( template )
        template_lookup[ template.name ] = template

      unsatisfied
        # We have an illegal standard class.  Could be two overloaded routines.
        if (template.is_routine and existing_template.is_routine)
          # Merge the routines and worry about exact duplicate routines later
          existing_template.tokens.add( template.tokens )
        else
          if (existing_template.is_routine)
            throw template.t.error( "A routine named $ already exists." (template.name) )
          else
            throw template.t.error( "A class named $ already exists." (template.name) )
          endIf
        endIf

      endContingent


    method configure
      type_null          = create_built_in_type( "null",      Attribute.is_native | Attribute.is_class )
      type_Real64        = create_built_in_type( "Real64",      Attribute.is_primitive )
      type_Real32        = create_built_in_type( "Real32",     Attribute.is_primitive )
      type_Int64         = create_built_in_type( "Int64",      Attribute.is_primitive )
      type_Int32         = create_built_in_type( "Int32",   Attribute.is_primitive )
      type_Character     = create_built_in_type( "Character", Attribute.is_primitive )
      type_Byte          = create_built_in_type( "Byte",      Attribute.is_primitive )
      type_Logical       = create_built_in_type( "Logical",   Attribute.is_primitive )

      type_Object        = create_built_in_type( "Object", Attribute.is_native | Attribute.is_class )
      type_String        = create_built_in_type( "String", Attribute.is_native | Attribute.is_class | Attribute.is_foreign )
      type_StringBuilder = create_built_in_type( "StringBuilder", Attribute.is_class )
      type_NativeArray   = create_built_in_type( "NativeArray", Attribute.is_native | Attribute.is_class )
      type_GenericList   = create_built_in_type( "GenericList", Attribute.is_class )
      type_Global        = create_built_in_type( "Global", Attribute.is_class )
      type_Exception     = create_built_in_type( "Exception", Attribute.is_class )

      type_Object.simplify_name = true
      type_String.simplify_name = true
      type_StringBuilder.simplify_name = true

      type_null.organized = true
      type_null.defined   = true

      # Ensure that "" is the first literal string
      literal_string_list.add( "" )
      literal_string_lookup[ "" ] = 0

    method create_unique_id->String
      return "_auto_" + next_unique_integer

    method get_launch_method( t:Token )->Method
      local type_global = get_type_reference( t, "Global" )
      if (not m_on_launch)
        m_on_launch = Method( t, type_global, "on_launch" )
        m_on_launch.statements.add( Program.m_on_launch.begin_label(t,"insert",false) )
      endIf
      return m_on_launch

    method next_unique_integer->Int32
      ++unique_integer
      return unique_integer - 1

    method find_template( name:String )->Template
      local template : Template

      which (name.last)
        case '?'
          if (find_type(name.leftmost(-1))) return template_lookup[ "Optional" ]
          else return null
        case ']'
          template = template_lookup[ "List" ]
        others
          template = template_lookup[ name.before_first('<') ]
      endWhich

      if (template) return template

      return null

    method find_type( name:String )->Type
      local type = type_lookup[ name ]
      if (type) return type

      local template = find_template( name )
      if (template)
        type = Type( template.t, name )
        type.attributes.add( template.attributes )
        type_lookup[name] = type
        return type
      endIf

      return null

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type) return type

      type = Type( t, name )
      type_lookup[name] = type

      return type

    method get_callback_type_signature( parameter_types:Type[] )->String
      string_buffer.clear.print( "(" )
      if (parameter_types)
        local first = true
        forEach (type in parameter_types)
          if (first) first = false
          else       string_buffer.print( ',' )
          string_buffer.print( type.name )
        endForEach
      endIf
      string_buffer.print( ')' )
      return string_buffer->String

    method get_callback_type_reference( t:Token, parameter_types:Type[], return_type:Type )->Type
      local name = "Function" + get_callback_type_signature( parameter_types )
      if (return_type) name += "->" + return_type.name

      local type = get_type_reference( t, name )
      if (type.defined) return type

      type.defined = true
      type.callback_parameter_types = parameter_types
      type.callback_return_type = return_type
      type.attributes.add( Attribute.is_class )
      local m_call = type.add_method( t, "call" )
      if (parameter_types)
        forEach (i of parameter_types) m_call.add_parameter( t, "param"+(i+1), parameter_types[i] )
      endIf
      if (return_type)
        m_call.return_type = return_type
        m_call.statements.add( CmdReturn(t,return_type.create_default_value(t)) )
      endIf

      return type

    method is_type_defined( name:String )->Logical
      local type = type_lookup[ name ]
      if (not type) return false
      return type.defined

    method create_built_in_type( name:String, attributes=0:Int32 )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes.add( attributes )
      return type

    method resolve
      if (m_on_launch) type_Global.add_method( m_on_launch )
      else             m_on_launch = type_Global.add_method( type_Global.t, "on_launch" )
      m_on_launch.statements.add( m_on_launch.begin_label(m_on_launch.t,"append",false) )
      m_on_launch.make_requisite

      forEach (p in global_properties)
        if (not p.type)
          if (p.initial_value)
            p.type = p.initial_value.implicit_type( Scope(type_Global,null) )
            if (not p.type)
              local mesg = "Cannot infer the type of the global property from its initial value.  Assign a type by appending ': TypeName' to the end of the declaration."
              throw p.t.error( mesg )
            endIf
          else
            local mesg = "Cannot determine the type of the global property - either assign an initial value (global $ = ...) or assign a type (global $ : Int32)." (p.name,p.name)
            throw p.t.error( mesg )
          endIf
        endIf
        type_Global.add_property( p )
      endForEach

      type_null.resolve
      type_Real64.resolve
      type_Real32.resolve
      type_Int64.resolve
      type_Int32.resolve
      type_Character.resolve
      type_Byte.resolve
      type_Logical.resolve
      type_Global.resolve
      type_Exception.resolve

      type_Object.resolve
      type_NativeArray.resolve
      type_GenericList.resolve
      type_String.resolve

      # Go through requisite directives, resolving and marking as requisite each named type
      # and method
      #{
      forEach (req in requisite_list)
        req.type.resolve
        req.type.attributes.add( Attribute.is_requisite )
        if (req.signature)
          if (req.signature == "*")
            forEach (r in req.type.global_method_list) r.attributes.add( Attribute.is_requisite )
            forEach (m in req.type.method_list)  m.attributes.add( Attribute.is_requisite )
          else
            local m = req.type.find_method( req.signature )
            if (m) m.attributes.add( Attribute.is_requisite )
            else     throw req.t.error( "No such method $ in type $." (req.signature,req.type.name) )
          endIf
        endIf
      endForEach
      }#

      if (all_requisite)
        forEach (t in type_lookup)
          t.resolve
          t.attributes.add( Attribute.is_requisite )
          forEach (r in t.global_method_list) r.attributes.add( Attribute.is_requisite )
          forEach (m in t.method_list)  m.attributes.add( Attribute.is_requisite )
        endForEach
        forEach (templ in template_list)
          if (not templ.type_parameters)
            templ.attributes.add( Attribute.is_requisite )
            local t = get_type_reference( templ.t, templ.name )
            t.resolve
            forEach (r in t.global_method_list) r.attributes.add( Attribute.is_requisite )
            forEach (m in t.method_list)  m.attributes.add( Attribute.is_requisite )
          endIf
        endForEach
      endIf

      local resolve_types = true
      while (resolve_types)
        resolve_types = false

        # Reference and resolve all requisite type templates
        forEach (templ in template_list)
          if ((templ.attributes.flags & Attribute.is_requisite) and not templ.type_parameters)
            get_type_reference( templ.t, templ.name ).resolve
          endIf
        endForEach

        local i = 0
        while (i < type_list.count)
          type_list[i].resolve
          ++i
        endWhile

        # Give plug-ins a chance to generate new classes before we're done
        forEach (plugin in RogueC.plugins)
          if (plugin.generate_additional_types) resolve_types = true
        endForEach
      endWhile

      cull_unused_code

      reorder_compounds

    method reorder_compounds
      # Source code for compounds and exception types is generated in the same order that they
      # appear in the type_list.  If compound B is defined before A *and* B has properties of
      # type A then it results in an error.  Reorder compounds and exceptions so that such
      # dependencies occur earlier in the list.

      # Compounds
      local compounds = Type[]

      local write_i = 0
      forEach (read_i of type_list)
        local type = type_list[ read_i ]
        if (type.is_compound)
          collect_compound_dependencies( type, compounds )
        else
          type_list[ write_i ] = type
          type.index = write_i
          ++write_i
        endIf
      endForEach
      type_list.discard_from( write_i )

      forEach (type in compounds)
        type.index = type_list.count
        type_list.add( type )
      endForEach

      # Exceptions
      forEach (type in type_list)
        if (type.instance_of(Program.type_Exception) and type isNot Program.type_Exception)
          if (type.base_class.index > type.index)
            local i1 = type.base_class.index
            local i2 = type.index
            type_list.swap( i1, i2 )
            type.index = i1
            type.base_class.index = i2
          endIf
        endIf
      endForEach


    method collect_compound_dependencies( type:Type, compounds:Type[] )
      if (type.index == -1) return  # already collected
      type.index = -1

      forEach (p in type.property_list)
        if (p.type.is_compound) collect_compound_dependencies( p.type, compounds )
      endForEach
      compounds.add( type )

    method cull_unused_code
      forEach (type in type_list)
        if (type.is_requisite) type.trace_used_code
      endForEach

      trace_overridden_methods

      forEach (type in type_list)
        type.cull_unused_methods
      endForEach

      local write_i = 0
      forEach (read_i of type_list)
        local type = type_list[ read_i ]
        if (not type.should_cull)
          type_list[ write_i ] = type
          type.index = write_i
          ++write_i
        endIf
      endForEach
      type_list.discard_from( write_i )

    method trace_overridden_methods
      # When we have "s = Circle() : Shape; println s.area()", only Shape.area()
      # is initially visible through code tracing.  We track all of the overrides for
      # a method but we don't want to trace them unless the type context is in use.
      # We can't figure it all out in a single pass so we'll keep making passes until
      # there are no more changes.
      local traced_new_methods = true
      while (traced_new_methods)
        traced_new_methods =  false

        forEach (type in type_list)
          if (type.is_used)
            if (type.is_aspect)
              # trace aspect types and methods
              forEach (m in type.method_list)
                if (m.is_used and m.incorporating_classes)
                  forEach (ic in m.incorporating_classes)
                    if (ic.is_used)
                      local im = ic.find_method( m.signature )
                      if (not im.is_used)
                        traced_new_methods = true
                        im.trace_used_code
                      endIf
                    endIf
                  endForEach
                endIf
              endForEach
            else
              # Trace overriding methods
              forEach (m in type.method_list)
                if (m.is_used)
                  #{  Realized there's no need to trace overridden methods, only overriding methods.
                  if (m.overridden_method and not m.overridden_method.is_used)
                    traced_new_methods = true
                    m.overridden_method.trace_used_code
                  endIf
                  }#

                  forEach (overriding_m in m.overriding_methods)
                    if (not overriding_m.is_used and overriding_m.type_context.is_used)
                      traced_new_methods = true
                      overriding_m.trace_used_code
                    endIf
                  endForEach
                endIf
              endForEach
            endIf
          endIf
        endForEach

      endWhile

      # Each aspect method has a list of incorporating_classes that is used to generate
      # the aspect dispatch methods.  To begin with the list only contains classes that
      # directly incorporate the aspect.  Collect a list of used aspects and then
      # make sure each method's incorporating_classes list includes all classes
      # instanceOf that aspect that employ a given method.
      local class_list = type_list.choose( function(type)=type.is_class and type.is_used )
      local aspect_list = type_list.choose( function(type)=type.is_aspect and type.is_used )

      # Clear each aspect method's list of incorporating classes before rebuilding
      forEach (aspect in aspect_list)
        forEach (aspect_m in aspect.method_list)
          if (aspect_m.is_used and aspect_m.incorporating_classes) aspect_m.incorporating_classes.clear
        endForEach
      endForEach

      forEach (aspect in aspect_list)
        forEach (type in class_list)
          if (type.instance_of(aspect))
            forEach (aspect_m in aspect.method_list)
              if (aspect_m.is_used)
                local class_m = type.find_method( aspect_m.signature )
                if (class_m and class_m.is_used and aspect_m.incorporating_classes)
                  aspect_m.incorporating_classes.add( type )
                endIf
              endIf
            endForEach
          endIf
        endForEach
      endForEach

endClass
