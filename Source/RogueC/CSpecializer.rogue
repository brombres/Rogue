module Rogue

class CSpecializer : Visitor
  PROPERTIES
    writer         : CWriter
    autoname_index = 0

    current_statements : ListRewriter<<Cmd>>
    insert_in_init     : Logical
    control_stack      = ControlStructure[]

  METHODS
    method visit_type( type:Type )
      if (not type.is_aspect)
        prior.visit_type( type )
      endIf

    method add_local( t:Token, base:String, type:Type, initial_value=null:Cmd )->Local
      local v = Local( t, autoname(base), initial_value, type )
      v.c_name = "$_$" (v.name,this_procedure.locals.count)
      this_procedure.locals.add( v )
      assert control_stack.count
      control_stack.last.locals.add( v )
      return v

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method insert( cmd:Cmd )
      if (insert_in_init)
        control_stack.last.initialization.add( cmd )
      else
        current_statements.write( cmd )
      endIf

    method on( cmd:CallDynamicMethod )->Cmd
      # Anchor the object context if necessary
      local context = cmd.context
      if (Program.gc_auto)
        if ((context.type.is_reference or context.type.contains_reference) and not context.is_anchored)
          context = visit( context )
          local v = context.intermediate_v
          if (not v or not v.is_anchored)
            v = add_local( context.t, "anchored_context", context.type, DummyInitialValue )
            insert( SetLocal(context.t,v,context,&initial_assignment) )
          endIf
          cmd.context = GetLocal(context.t,v)
        endIf
      endIf
      return on( cmd->(as CallProcedure) )

    method on( cmd:CallProcedure )->Cmd
      visit_children( cmd )

      # Anchor any args that need it
      if (Program.gc_auto)
        forEach (arg at i in cmd.args)
          if ((arg.type.is_reference or arg.type.contains_reference) and not arg.is_anchored)
            local v = add_local( arg.t, "anchored_arg_"+i, arg.type )
            insert( SetLocal(arg.t,v,arg,&initial_assignment) )
            cmd.args[i] = GetLocal(arg.t,v)
          endIf
        endForEach
      endIf

      if (cmd.info.throws?)
        # Decompose call
        if (cmd.info.return_type?)
          local v = add_local( cmd.t, "call", cmd.info.return_type, DummyInitialValue )
          insert( SetLocal(cmd.t,v,cmd,&initial_assignment) )
          insert( ReturnOnException(cmd.t) )
          return GetLocal( cmd.t, v )
        else
          insert( cmd )
          return ReturnOnException( cmd.t )
        endIf
      else
        return cmd
      endIf

    method on( cmd:ControlStructure )->Cmd
      control_stack.add( cmd )
      handle( cmd )
      control_stack.remove_last
      return cmd

    method on( cmd:CreateObject )->Cmd
      visit_children( cmd )

      local v = add_local( cmd.t, "obj", cmd.of_type, DummyInitialValue )
      insert( CreateObjectAndSetLocal(cmd.t,cmd.of_type,v) )
      if (cmd.m_init)
        insert( validate(CallDynamicMethod(cmd.t,GetLocal(cmd.t,v),cmd.m_init,cmd.args)) )
      endIf
      return GetLocal(cmd.t,v)

    method on_visit( cmd:If )
      control_stack.add( cmd )
      temporarily insert_in_init = true
        cmd.condition = visit( cmd.condition )
      endTemporarily
      cmd.statements = visit( cmd.statements )
      cmd.cmd_else = visit(cmd.cmd_else)->(as If)
      control_stack.remove_last

    method on_visit( cmd:InlineWhich )
      visit_children( cmd )

      forEach (wcase in cmd.cases)
        # which{ a || b }
        # ->
        # local temp = a
        # which{ temp:temp || b }
        if (not wcase.value)
          if (wcase.condition instanceOf GetLocal)
            wcase.value = wcase.condition.cloned
          else
            local v = add_local( cmd.t, "case", wcase.condition.type, DummyInitialValue )
            insert( SetLocal(cmd.t,v,wcase.condition,&initial_assignment) )
            wcase.condition = GetLocal( cmd.t, v )
            wcase.value     = GetLocal( cmd.t, v )
          endIf
        endIf
      endForEach

    method on_visit( cmd:Iterator )
      control_stack.add( cmd )
      temporarily insert_in_init = true
        cmd.condition = visit( cmd.condition )
      endTemporarily
      cmd.initialization = visit( cmd.initialization )
      cmd.statements = visit( cmd.statements )
      cmd.upkeep = visit( cmd.upkeep )
      cmd.control = visit( cmd.control )
      control_stack.remove_last

    method on_visit( cmd:LiteralString )
      local str = cmd.value
      if (not Program.unique_strings.contains(str))
        use builder = StringBuilder.pool
          builder.print( "str_" )
          forEach (i in 0..<str.count.or_smaller(20))
            local ch = str[i]
            if (ch.is_letter or ch.is_number) builder.print( ch )
            else builder.print( '_' )
          endForEach
          local c_name = builder->String
          if (Program.c_name_strings.contains(c_name))
            local n = 1
            while (Program.c_name_strings.contains(c_name))
              local c_name_2 = c_name + "_" + n
              if (not Program.c_name_strings.contains(c_name_2))
                c_name = c_name_2
                escapeWhile
              endIf
              ++n
            endWhile
          endIf
          Program.unique_strings[ str ] = c_name;
          Program.c_name_strings[ c_name ] = str;
        endUse
      endIf

    method on( cmd:LogicalAnd )->Cmd
      if (cmd.left.needs_decomposition or cmd.right.needs_decomposition)
        local t = cmd.t

        local left = cmd.left
        left.intermediate_v = cmd.intermediate_v
        cmd.left = visit( left )
        local v = left.intermediate_v
        if (not v)
          v = cmd.intermediate_v
          if (v)
            insert( SetLocal(t,v,cmd.left) )
          else
            v = add_local( t, "and", cmd.left.type, DummyInitialValue )
            insert( SetLocal(t,v,cmd.left,&initial_assignment) )
          endIf
        endIf
        cmd.intermediate_v = v
        cmd.right.intermediate_v = v

        local statements = Statements( t, SetLocal(t,v,cmd.right) )
        insert( visit( If(t, GetLocal(t,v), LocalScope(t,statements), null) ) )

        contingent
          necessary statements.count
          local cmd_set_local = statements.last->(as SetLocal)
          necessary (cmd_set_local)
          local cmd_get_local = cmd_set_local.new_value->(as GetLocal)
          necessary (cmd_get_local)
          necessary (cmd_set_local.info is cmd_get_local.info)
          statements.remove_last
        endContingent

        return GetLocal(t,v)
      endIf
      return cmd

    method on( cmd:LogicalOr )->Cmd
      local decompose_left  = cmd.left.needs_decomposition
      local decompose_right = cmd.right.needs_decomposition
      if (decompose_left or decompose_right)
        local t = cmd.t

        local left = cmd.left
        left.intermediate_v = cmd.intermediate_v
        cmd.left = visit( left )
        local v = left.intermediate_v
        if (not v)
          v = cmd.intermediate_v
          if (v)
            insert( SetLocal(t,v,cmd.left) )
          else
            v = add_local( t, "or", cmd.left.type, DummyInitialValue )
            insert( SetLocal(t,v,cmd.left,&initial_assignment) )
          endIf
        endIf
        cmd.intermediate_v = v
        cmd.right.intermediate_v = v

        local statements = Statements( t, SetLocal(t,v,cmd.right) )
        insert( visit( If(t, LogicalNot(t,GetLocal(t,v)), LocalScope(t,statements), null) ) )

        contingent
          necessary statements.count
          local cmd_set_local = statements.last->(as SetLocal)
          necessary (cmd_set_local)
          local cmd_get_local = cmd_set_local.new_value->(as GetLocal)
          necessary (cmd_get_local)
          necessary (cmd_set_local.info is cmd_get_local.info)
          statements.remove_last
        endContingent

        return GetLocal(t,v)
      endIf
      return cmd

    method on_visit( cmd:Procedure )
      autoname_index = 0

      cmd.c_result_name = "_auto_result"

      forEach (p at i in cmd.parameters)
        block p = p->(as Local)
          p.c_name = "$_$" (p.name,i)
        endBlock
      endForEach

      local di = cmd.parameters.count
      forEach (v at i in cmd.locals) v.c_name = "$_$"(v.name,i+di)

      visit_children( cmd )

    method on_visit( cmd:Return )
      visit_children( cmd )

    method on_visit( cmd:Statements )
      temporarily current_statements = cmd.list.rewriter
        forEach (statement in current_statements)
          statement = visit( statement )
          contingent
            necessary (statement)
            necessary (statement not instanceOf GetLocal)
            current_statements.write( statement )
          endContingent
        endForEach
      endTemporarily

    method on( cmd:SetLocal )->Cmd
      local cmd_create = cmd.new_value->(as CreateObject)
      if (not cmd_create)
        visit_children( cmd )
        return cmd
      endIf

      local args = visit( cmd_create.args )
      local cmd_create2 = validate( CreateObjectAndSetLocal(cmd_create.t,cmd_create.of_type,cmd.info) )
      if (cmd_create.m_init)
        insert( cmd_create2 )
        return validate( CallDynamicMethod(cmd.t, GetLocal(cmd.t,cmd.info), cmd_create.m_init, args) )
      else
        return cmd_create2
      endIf

    method on_visit( cmd:Throw )
      visit_children( cmd )
endClass

augment Cmd
  METHODS
    method intermediate_v->Local
      return null

    method set_intermediate_v( v:Local )
      noAction
endAugment

augment ControlStructure
  PROPERTIES
    c_escape_label_name : String

  METHODS
    method c_escape_label_name( cgen:CGenerator )->String
      if (not @c_escape_label_name)
        @c_escape_label_name = cgen.autoname("escape")
      endIf
      return @c_escape_label_name

endAugment

augment CreateObjectAndSetLocal
  METHODS
    method intermediate_v->Local
      return info
endAugment

augment GetLocal
  METHODS
    method intermediate_v->Local
      return info
endAugment

augment Local
  PROPERTIES
    c_name : String
endAugment

augment LogicalAnd
  PROPERTIES
    intermediate_v : Local

  METHODS
    method intermediate_v->Local
      return @intermediate_v

    method set_intermediate_v( @intermediate_v )
endAugment

augment LogicalOr
  PROPERTIES
    intermediate_v : Local

  METHODS
    method intermediate_v->Local
      return @intermediate_v

    method set_intermediate_v( @intermediate_v )
endAugment

augment Procedure
  PROPERTIES
    c_name        : String
    c_result_name : String
    c_signature   : String  # for dynamic dispatch

  METHODS
    method c_name->String
      throw UnsupportedOperationError()

    method c_signature->String
      if (@c_signature) return @c_signature

      use builder = StringBuilder.pool
        builder.print( name )
        if (parameters.count)
          builder.print '_'
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_signature = builder
        return @c_signature
      endUse

endAugment

augment Program
  PROPERTIES
    c_name_strings = StringTable<<String>>()
    unique_c_names = Set<<String>>()

  METHODS
    method to_c_name( name:String )->String
      loop
        if (name.ends_with("[]"))
          name = name.leftmost(-2) + "List"
          nextIteration
        elseIf (name.ends_with('?'))
          name = "Optional" + name.leftmost(-1)
          nextIteration
        else
          escapeLoop
        endIf
      endLoop

      if (name.contains(':'))
        name .= replacing( ":<<:",  "SHL" )
        name .= replacing( ":>>:",  "SHR" )
        name .= replacing( ":>>>:", "SHRX" )
      endIf

      use builder = StringBuilder.pool
        local iterator = name.iterator
        while (iterator.has_another)
          local ch = iterator.read
          if (ch.is_letter or ch.is_number)
            builder.print ch
          elseIf (ch == '>')
            if (iterator.peek == '>') iterator.read
            else                      builder.print "GT"
          elseIf (ch == '<')
            if (iterator.peek == '<') builder.print '_'; iterator.read
            else                      builder.print "GT"
          elseIf (ch == '+')
            if (iterator.peek == '+') builder.print "INC"; iterator.read
            else                      builder.print "PLUS"
          elseIf (ch == '-')
            if (iterator.peek == '-') builder.print "DEC"; iterator.read
            else                      builder.print "MINUS"
          else
            which (ch)
              case '?': builder.print "Q"
              case '*': builder.print "TIMES"
              case '/': builder.print "DIVIDE"
              case '%': builder.print "MOD"
              case '^': builder.print "POWER"
              case '&': builder.print "AND"
              case '|': builder.print "OR"
              case '~': builder.print "XOR"
              case '!': builder.print "NOT"
              others:   builder.print '_'
            endWhich
          endIf
        endWhile
        return builder->String
      endUse

    method unique_c_name( c_name:String )->String
      if (unique_c_names.contains(c_name))
        local i = 2
        local cni = c_name + i
        while (unique_c_names.contains(cni))
          ++i
          cni = c_name + i
        endWhile
        unique_c_names.add( cni )
        return cni
      else
        unique_c_names.add( c_name )
        return c_name
      endIf
endAugment

augment Property
  PROPERTIES
    c_name : String

  METHODS
    method c_name->String
      if (@c_name) return @c_name

      if (attributes.is_global)
        @c_name = "$__g_$"(type_context.c_name,name)
      else
        @c_name = name
      endIf
      return @c_name

endAugment

augment Type
  PROPERTIES
    c_name : String   # e.g. RogueString
    c_ref_name : String   # e.g. RogueString*

  METHODS
    method c_ref_name->String
      if (@c_ref_name) return @c_ref_name
      @c_ref_name = c_name
      if (is_reference) @c_ref_name += "*"
      return @c_ref_name

    method c_name->String
      if (@c_name) return @c_name
      if (is_aspect)
        @c_name = "RogueObject"
      else
        @c_name = Program.unique_c_name( module_context.c_name + Program.to_c_name(name) )
      endIf
      return @c_name

endAugment

augment
  METHODS
    method GlobalMethod.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( type_context.c_name ).print( "__" )
        builder.print( Program.to_c_name(name) )
        if (parameters.count)
          builder.print '_'
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

    method Method.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( type_context.c_name ).print( "__" )
        builder.print( Program.to_c_name(name) )
        if (parameters.count)
          builder.print '_'
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

    method Module.c_name->String
      return name

    method Routine.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( module_context.c_name ).print( "__" )
        builder.print( Program.to_c_name(name) )
        if (parameters.count)
          builder.print "_"
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

endAugment

