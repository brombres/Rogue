#------------------------------------------------------------------------------
# Program
#------------------------------------------------------------------------------
augment Program
  PROPERTIES
    intptr_name : String
    intptr_size : Int32
    int_name : String
    int_size : Int32

  METHODS
    method init
      block
        $if defined(INTPTR_SIZE)
          local ptr_size = INTPTR_SIZE  # may be defined when compile platform is different architecture
        $else
          local ptr_size = native("sizeof(intptr_t)")->Int32
        $endIf
        if ptr_size == 4
          intptr_name = "Int32"
        elseIf ptr_size == 8
          intptr_name = "Int64"
        else
          throw Error("Unsupported platform pointer size")
        endIf
        $if defined(INT_SIZE)
          local int_size = INT_SIZE  # may be defined when compile platform is different architecture
        $else
          local int_size = native("sizeof(int)")->Int32
        $endIf
        if int_size == 4
          int_name = "Int32"
        elseIf int_size == 8
          int_name = "Int64"
        else
          throw Error("Unsupported platform int size")
        endIf
      endBlock

    method configure
      Preprocessor.define( "IntPtr", Tokenizer().tokenize(("compiler-generated"), intptr_name ) )
      Preprocessor.define( "Int", Tokenizer().tokenize(("compiler-generated"), int_name ) )

    method validate_cpp_name( name:String )->String
      local begins_with_code_prefix = false
      if (name.begins_with(code_prefix))
        begins_with_code_prefix = true
        name = name.from( code_prefix.count )
      endIf

      # Convert "_*type" to "__*type"
      if (name.ends_with("type"))
        forEach (i in 0..(name.count-5))
          if (name[i] != '_') escapeForEach
        endForEach
        name = "_" + name
      endIf

      # Type? -> OptionalType
      local i1 = name.locate('?')
      while (i1?)
        name = "Optional" + name.leftmost(i1.value) + name.from(i1.value+1)
        i1 = name.locate('?')
      endWhile

      # Convert ABC->XYZ to ABCRETURNSXYZ
      i1 = name.locate( "->" )
      while (i1?)
        name = "$RETURNS$" (name.leftmost(i1.value),name.from(i1.value+2))
        i1 = name.locate( "->" )
      endWhile

      # Type<<Specialization>> -> Type_Specialization_
      i1 = name.locate("<<")
      while (i1?)
        local i2 = locate_matching_close_specialize( name, i1 )
        if (not i2?) escapeWhile

        local before = name.from(0,i1.value-1)
        local after  = name.from(i2.value+2)
        local middle = name.from(i1.value+2,i2.value-1)

        name = "$_$_$" (before,middle,after)

        i1 = name.locate("<<")
      endWhile

      #   Table_of_String,Int32[] -> Table_of_String,Int32_List
      i1 = name.locate("[]")
      while (i1?)
        name = "$_List$" (name.from(0,i1.value-1),name.from(i1.value+2))
        i1 = name.locate("[]")
      endWhile

      string_buffer.clear
      if (begins_with_code_prefix) string_buffer.print( Program.code_prefix )

      local count = name.count
      forEach (i of name)
        local ch = name[i]
        if (ch.is_alphanumeric or ch == '$')
          string_buffer.print( ch )
        else
          which (ch)
            case '!': string_buffer.print( "NOT" )
            case '%': string_buffer.print( "MOD" )
            case '&': string_buffer.print( "AND" )
            case '*': string_buffer.print( "TIMES" )
            case '+': string_buffer.print( "PLUS" )
            case '-'
              if (i+1 < count)
                which (name[i+1])
                  case '>'
                    string_buffer.print( "RETURNS" )
                    ++i
                  others
                    string_buffer.print( "MINUS" )
                endWhich
              endIf
            case '.': string_buffer.print( "_" )
            case '/': string_buffer.print( "SLASH" )
            case '<'
              if (i+1 < count)
                which (name[i+1])
                  case '='
                    string_buffer.print( "LE" )
                    ++i
                  others
                    string_buffer.print( "LT" )
                endWhich
              endIf
            case '=': string_buffer.print( "EQUALS" )
            case '>'
              if (i+1 < count)
                which (name[i+1])
                  case '='
                    string_buffer.print( "GE" )
                    ++i
                  others
                    string_buffer.print( "GT" )
                endWhich
              endIf
            case '^': string_buffer.print( "POWER" )
            case '|': string_buffer.print( "OR" )
            case '~': string_buffer.print( "XOR" )
            others:   string_buffer.print( '_' )
          endWhich
        endIf
      endForEach

      return string_buffer->String

    method locate_matching_close_specialize( st:String, i1:Int32? )->Int32?
      local nesting_level = 1
      forEach (i in i1.value+2..st.count-2)
        if (st[i] == '<' and st[i+1] == '<')
          ++nesting_level
          ++i
        elseIf (st[i] == '>' and st[i+1] == '>')
          --nesting_level
          if (nesting_level == 0) return i
          ++i
        endIf
      endForEach
      return null

    method write_cpp( filepath:String )
      forEach (type in type_list)
        type.assign_cpp_name
      endForEach
      type_Array.cpp_class_name = "RogueArray"
      type_NativeLock.cpp_class_name = "ROGUE_SYNC_OBJECT_TYPE"

      forEach (type in type_list)
        forEach (r in type.global_method_list) r.assign_cpp_name
        forEach (m in type.method_list) m.assign_cpp_name
      endForEach

      local base_cpp_filepath = filepath
      if (RogueC.compile_targets["Cython"] or RogueC.compile_targets["Python"]) base_cpp_filepath += "_module"

      # .H header -------------------------------------------------------------
      println "Writing $.h..." (base_cpp_filepath)
      local writer = CPPWriter( base_cpp_filepath + ".h" )

      # Header
      writer.println "//-----------------------------------------------------------------------------"
      writer.println "//  Generated by the Rogue compiler"
      writer.println "//-----------------------------------------------------------------------------"
      writer.println "#pragma once"

      forEach (plugin in RogueC.plugins)
        plugin.start_header_file( writer )
      endForEach

      # It'd be nice to be able to override these with a C++ -D arg...
      writer.print "#define ROGUE_GC_MODE_MANUAL "
      writer.println select{RogueC.gc_mode == GCMode.MANUAL: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_AUTO_ST "
      writer.println select{RogueC.gc_mode == GCMode.AUTO_ST: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_AUTO_MT "
      writer.println select{RogueC.gc_mode == GCMode.AUTO_MT: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_AUTO_ANY "
      if (RogueC.gc_mode == GCMode.AUTO_ST or RogueC.gc_mode == GCMode.AUTO_MT)
        writer.println "1"
      else
        writer.println "0"
      endIf
      writer.print "#define ROGUE_GC_MODE_BOEHM "
      writer.println select{RogueC.gc_mode == GCMode.BOEHM: "1" || "0"}
      writer.print "#define ROGUE_GC_MODE_BOEHM_TYPED "
      writer.println select{RogueC.gc_mode == GCMode.BOEHM_TYPED: "1" || "0"}
      writer.println

      # GC Threshold
      writer.println "#ifndef ROGUE_GC_THRESHOLD_DEFAULT"
      writer.print(  "  #define ROGUE_GC_THRESHOLD_DEFAULT " ).println( RogueC.gc_threshold )
      writer.println "#endif"
      writer.println

      # Thread mode stuff
      writer.println "#define ROGUE_THREAD_MODE_NONE 0"
      writer.println "#define ROGUE_THREAD_MODE_PTHREADS 1"
      writer.println "#define ROGUE_THREAD_MODE_CPP 2"
      writer.println "#ifndef ROGUE_THREAD_MODE"
      writer.println "  #define ROGUE_THREAD_MODE ROGUE_THREAD_MODE_" + RogueC.thread_mode->String
      writer.println "#endif"

      # Enable Introspection?
      if (Program.using_introspection)
        writer.println(  "#define ROGUE_INTROSPECTION 1" )
        writer.println
      endIf

      # Embed nativeHeader
      writer.println "// NATIVE HEADERS"
      forEach (line in native_header)
        writer.println( line )
      endForEach

      writer.println "#include <cmath>"
      writer.println

      # RogueObject forward declarations
      writer.println "// FORWARD DECLARATIONS"
      forEach (type in type_list)
        if (not type.omit_output and not type.is_primitive)
          writer.print( "struct " ).print( type.cpp_class_name ).print("; // ").println( type.name )
        endIf
      endForEach
      writer.println

      # Compound definitions
      writer.println "// COMPOUND DEFINITIONS"
      forEach (type in type_list)
        if (type.is_compound and not type.omit_output)
          type.print_data_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # Global externs
      writer.println "// GLOBAL PROPERTIES"
      forEach (type in type_list)
        forEach (g in type.global_list)
          writer.print( "extern " )
          if ( g.is_thread_local ) writer.print( "ROGUE_THREAD_LOCAL " )
          writer.print( g.type ).print( " Rogue" )
          writer.print( type.cpp_name ).print( "_" ).print( g.cpp_name ).println( ";" )
        endForEach
      endForEach
      writer.println

      # Class definitions
      writer.println "// CLASS DEFINITIONS"
      forEach (type in type_list)
        if (not type.is_compound and not type.omit_output)
          type.print_data_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # RogueType_X externs.
      writer.println "// ROGUE TYPES"
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print( "extern RogueType* RogueType" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      # Routine prototypes
      writer.println "// ROUTINE PROTOTYPES"
      forEach (type in type_list) type.print_global_method_prototypes( writer )
      writer.println

      # Method prototypes
      writer.println "// METHOD PROTOTYPES"
      forEach (type in type_list) type.print_method_prototypes( writer )
      writer.println

      # Trace routine prototype
      writer.println "// INTERNAL PROTOTYPES"
      writer.println( "void Rogue_trace();" )
      writer.println

      # typedef each unique method signature
      local native_method_signature_list   = String[]
      local native_method_signature_lookup = Table<<String,Method>>()
      forEach (type in type_list)
        if (type.is_used)
          type.determine_cpp_method_typedefs( native_method_signature_list, native_method_signature_lookup )
        endIf
      endForEach

      #if (Program.using_introspection)
      ##IntrospectionCallManager.index_handlers
      #endIf

      # write dynamic dispatch method prototypes
      if (RogueC.all_methods_callable_dynamically)
        forEach (sig in native_method_signature_list)
          local m = native_method_signature_lookup[sig]  # one of the methods using this signature
          if (m.called_dynamically or RogueC.all_methods_callable_dynamically)
            writer.print_export( m )
            if (m.return_type and m.return_type.is_reference) writer.print( "void*" )
            else                                              writer.print( m.return_type )
            writer.print( " Rogue_call_" ).print( m.cpp_typedef )
            writer.print( "( int i, void* THIS" )
            forEach (i of m.parameters)
              local p = m.parameters[i]
              writer.print( ", " )
              if (p.type.is_reference) writer.print( "void*" )
              else                     writer.print(p.type)
              writer.print( " p" ).print( i )
            endForEach
            writer.println( " );" )
          endIf
        endForEach
        writer.println
      endIf

      forEach (plugin in RogueC.plugins)
        plugin.finish_header_file( writer )
      endForEach

      writer.close

      # .CPP/.MM implementation ---------------------------------------------------
      local extension = "cpp"
      if (RogueC.compile_targets["ObjC"]) extension = "mm"
      println "Writing $.$..." (base_cpp_filepath,extension)
      writer = CPPWriter( "$.$" (base_cpp_filepath,extension) )

      local base_filename = base_cpp_filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println "#include <stdio.h>"
      writer.println "namespace std {}"
      writer.println "using namespace std;"
      writer.println ''#include "$.h"'' (base_filename)
      writer.println

      # Embed nativeCode
      forEach (line in native_code)
        writer.println( line )
      endForEach

      forEach (plugin in RogueC.plugins)
        plugin.start_code_file( writer )
      endForEach

      forEach (sig in native_method_signature_list)
        writer.print( "typedef " ).print( sig.before_first("(*)") ).print( "(*" )
        writer.print( native_method_signature_lookup[sig].cpp_typedef ).print(")")
        writer.print( sig.after_first("(*)") ).println( ";" )
      endForEach
      writer.println

      # write dynamic dispatch methods
      forEach (sig in native_method_signature_list)
        local m = native_method_signature_lookup[sig]  # one of the methods using this signature
        if (m.called_dynamically or (RogueC.all_methods_callable_dynamically ...
                                     and not m.is_global ...
                                     and m.type_context.is_reference))
          writer.println( "// " + m )
          writer.print( "extern ")
          if (m.return_type and m.return_type.is_reference) writer.print( "void*" )
          else                                              writer.print( m.return_type )
          writer.print( " Rogue_call_" ).print( m.cpp_typedef )
          writer.print( "( int i, void* THIS" )
          forEach (i of m.parameters)
            local p = m.parameters[i]
            writer.print( ", " )
            if (p.type.is_reference) writer.print( "void*" )
            else                     writer.print(p.type)
            writer.print( " p" ).print( i )
          endForEach
          writer.println( " )" )
          writer.println( "{" )
          writer.print( "  " )
          if (m.return_type) writer.print( "return " )
          writer.print( "((" ).print( m.cpp_typedef )
          writer.print( ")(((RogueObject*)THIS)->type->methods[i]))( THIS" )
          forEach (i of m.parameters)
            writer.print( ", p" ).print( i )
          endForEach
          writer.println( " );" )
          writer.println( "}" )
          writer.println
        endIf
      endForEach
      writer.println

      # Global declarations
      # We first do ones which aren't references (and compounds which don't contain references),
      # and then do reference-y ones next.  The idea is to pack all the ones that can be GC
      # roots next to each other.
      local first_thread_local : String
      local last_thread_local : String
      writer.println "// GLOBAL PROPERTIES"
      forEach (type in type_list)
        forEach (g in type.global_list)
          if ( g.is_thread_local and (g.type.is_reference or g.type.has_object_references ) ) nextIteration
          if ( g.is_thread_local ) writer.print( "ROGUE_THREAD_LOCAL " )
          writer.print( g.type ).print( " Rogue" )
          writer.print( type.cpp_name ).print( "_" ).print( g.cpp_name )
          writer.print( " = " ).print_default_value( g.type )
          writer.println( ";" )
        endForEach
      endForEach
      forEach (type in type_list)
        forEach (g in type.global_list)
          if ( g.is_thread_local and (g.type.is_reference or g.type.has_object_references ) )
            writer.print( "ROGUE_THREAD_LOCAL " )
            writer.print( g.type ).print( " Rogue" )
            writer.print( type.cpp_name ).print( "_" ).print( g.cpp_name )
            writer.print( " = " ).print_default_value( g.type )
            writer.println( ";" )
            last_thread_local = "Rogue$_$" (type.cpp_name, g.cpp_name)
            if (first_thread_local is null) first_thread_local = last_thread_local
          endIf
        endForEach
      endForEach
      writer.println

      # Trace Prototypes
      forEach (type in type_list)
        if (type.has_object_references and not type.is_reference_array and not type.is_aspect)

          local trace_name = type.cpp_name
          if (type.is_array and type.element_type.is_compound)
            trace_name = Program.validate_cpp_name( type.name )
          endIf

          writer.print(   "void Rogue" ).print( trace_name ).println( "_trace( void* obj );" )
        endIf
      endForEach
      writer.println

      # Trace Functions
      forEach (type in type_list)
        if (type.has_object_references and not type.is_reference_array and not type.is_aspect)

          local trace_name = type.cpp_name
          if (type.is_array and type.element_type.is_compound)
            trace_name = Program.validate_cpp_name( type.name )
          endIf

          writer.print(   "void Rogue" ).print( trace_name ).println( "_trace( void* obj )" )
          writer.println( "{" )
          writer.indent += 2

          if (type.is_compound)
            local uses_link = false
            forEach (p in type.property_list)
              if (p.type.is_reference)
                uses_link = true
                escapeForEach
              endIf
            endForEach
            if (uses_link) writer.println "void* link;"

            print_property_trace_code( type, writer )

          elseIf (type.is_array)
            # We know this is not a reference array and so it must be an array of
            # compounds containing references.
            writer.println @|RogueArray* array = (RogueArray*) obj;
                            |int count;

            writer.print( type.element_type ).println( "* cur;" )

            writer.println @|
                            |if ( !array || array->object_size < 0 ) return;
                            |array->object_size = ~array->object_size;
                            |
                            |count = array->count;

            writer.print( "cur = ((" ).print( type.element_type.cpp_class_name ).println( "*)(array->as_bytes)) - 1;" )

            writer.println( "while (--count >= 0)" )
            writer.println( "{" )
            writer.print(   "  Rogue" ).print( type.element_type.cpp_name ).println( "_trace( ++cur );" )
            writer.println( "}" )

          else
            # Standard object with reference properties
            local uses_link = false
            forEach (p in type.property_list)
              if (p.type.is_reference)
                uses_link = true
                escapeForEach
              endIf
            endForEach

            if (uses_link) writer.println "void* link;"

            writer.println @|if ( !obj || ((RogueObject*)obj)->object_size < 0 ) return;
                            |((RogueObject*)obj)->object_size = ~((RogueObject*)obj)->object_size;
                            |
            print_property_trace_code( type, writer )
          endIf

          writer.indent -= 2
          writer.println( "}" )
          writer.println

        endIf
      endForEach
      writer.println

      # Type name index in literal string table
      writer.println "const int Rogue_type_name_index_table[] ="
      writer.println "{"
      writer.indent += 2
      forEach (i of type_list)
        local type = type_list[i]
        if (i > 0)
          writer.print ","
          if (i & 15 == 0) writer.println
        endIf
        writer.print( add_literal_string(type.name) )
      endForEach
      writer.println
      writer.indent -= 2
      writer.println "};"

# Property info table
#{
      writer.println "int Rogue_property_info_table[][] ="
      writer.println "{"
      writer.indent += 2

      forEach (type at i in type_list)
        if (i > 0) println ","
        writer.print( "{" ).print( type.property_list.count )
        forEach (p in type.property_list)
          writer.print ","
          writer.print( add_literal_string(p.name) )
          writer.print ","
          writer.print( p.type.index )
        endForEach
        writer.print( "}" )
      endForEach

      writer.println
      writer.indent -= 2
      writer.println "};"
      }#

      # Init Object Fn Table
      writer.println "RogueInitFn Rogue_init_object_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      local first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "init_object()" )
        if (m and not type.omit_output and m.is_used and m.statements.count > 1)
          writer.print "(RogueInitFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Init Fn Table
      writer.println "RogueInitFn Rogue_init_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "init()" )
        if (m and not type.omit_output and m.is_used and m.statements.count > 1)
          # Note: statement.count > 1 because there's a default return.
          writer.print "(RogueInitFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Cleanup Fn Table
      writer.println "RogueCleanUpFn Rogue_on_cleanup_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        local m = type.find_method( "on_cleanup()" )
        if (m and not type.omit_output and m.is_used and m.statements.count)
          writer.print "(RogueCleanUpFn) "
          writer.print m.cpp_name
        else
          writer.print 0
        endIf
      endForEach
      writer.println

      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # to->String Fn Table
      writer.println "RogueToStringFn Rogue_to_string_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        if (type.is_reference)
          local m = type.find_method( "to_String()" )
          if (m and not type.omit_output and m.is_used and m.statements.count)
            writer.print "(RogueToStringFn) "
            writer.print m.cpp_name
          else
            writer.print 0
          endIf
        else
          writer.print 0
        endIf

      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Trace Fn Table
      writer.println "RogueTraceFn Rogue_trace_fn_table[] ="
      writer.println "{"
      writer.indent += 2
      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        if (type.has_object_references and not type.is_aspect)
          if (type.is_reference_array)
            writer.print "RogueArray_trace"
          else
            local trace_name = type.cpp_name
            if (type.is_array and type.element_type.is_compound)
              trace_name = Program.validate_cpp_name( type.name )
            endIf

            writer.print(   "Rogue" ).print( trace_name ).print( "_trace" )
          endIf
        elseIf (type.is_class)
          writer.print "RogueObject_trace"
        else
          writer.print "0"
        endIf
      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Trace routine
      writer.println "void Rogue_trace()"
      writer.println "{"
      writer.indent += 2

      writer.println "void* link;"
      writer.println "int i;"
      writer.println
      writer.println "// Trace GLOBAL PROPERTIES"
      forEach (type in type_list)
        if (type.has_global_references)
          forEach (g in type.global_list)
            if (g.type.is_reference or g.type.has_object_references)

              if (g.type.is_reference and not g.type.is_array)
                writer.print( "if ((link=Rogue" ).print( type.cpp_name ).print( "_" ).print( g.cpp_name )
                writer.println( ")) ((RogueObject*)link)->type->trace_fn( link );" )

              else
                local trace_class_name = "Object"
                if (g.type.is_array)
                  if (g.type.element_type.is_compound and g.type.element_type.has_object_references)
                    trace_class_name = Program.validate_cpp_name( g.type.name )
                  else
                    trace_class_name = "Array"
                  endIf

                else
                  trace_class_name = Program.validate_cpp_name(g.type.cpp_name)
                endIf

                writer.print( "if ((link=" )
                if (not g.type.is_reference) writer.print( '&' )
                writer.print( "Rogue" ).print( type.cpp_name ).print( "_" ).print( g.cpp_name )
                writer.print( ")) Rogue" ).print( trace_class_name ).println( "_trace( link );" )

              endIf
            endIf
          endForEach
        endIf

      endForEach

      writer.println

      local using_introspection = Program.using_introspection

      writer.println @|// Trace Class objects and singletons
                      |for (i=Rogue_type_count; --i>=0; )
                      |{
                      |  RogueType* type = &Rogue_types[i];

                      if (using_introspection)
        writer.println @|  if (type->type_info) RogueTypeInfo_trace( type->type_info );
      endIf

      writer.println @|  {
                      |    auto singleton = ROGUE_GET_SINGLETON(type);
                      |    if (singleton) type->trace_fn( singleton );
                      |  }
                      |}


      writer.indent -= 2
      writer.println "}"
      writer.println

      #writer.println "*/"

      # dynamic method table
      writer.println( "const void* Rogue_dynamic_method_table[] =" )
      writer.println( "{" )
      writer.indent += 2
      local table_index = 0
      forEach (type in type_list)
        if (type.is_used)
          table_index = type.print_dynamic_method_table_entries( table_index, writer )
        endIf
      endForEach
      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      # Base class info table
      writer.print(   "const int Rogue_type_info_table[] =" )
      writer.println "{"
      writer.indent += 2
      writer.println "// allocator_index, dynamic_method_table_index, base_type_count, base_type_index[base_type_count],"
      writer.println "// global_property_count, global_property_name_indices[global_property_count], global_property_type_indices[global_property_count],"
      writer.println "// property_count, property_name_indices[property_count], property_type_indices[property_count] ..."

      local info = Int32[]
      local items = 0
      forEach (type in type_list)
        info.count = 0
        collect_type_info( type, info )
        #writer.print( "/* $ */" (type.cpp_class_name) )

        writer.print info.count
        writer.print_literal_character( ',', false )  # fix
        forEach (n in info)
          writer.print n
          writer.print_literal_character( ',', false )  # fix

          ++items
          if (items == 25) writer.println; items = 0
        endForEach
        #writer.println; items = 0
      endForEach

      if (items > 0) writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      if (Program.using_introspection)
        # Method names
        #NOTE: Must use exact same algorithm as for generating Rogue_dynamic_method_table!
        #      (that code is in type.print_dynamic_method_table_entries)
        local method_names = Table<<String,Int32>>()
        local method_param_type_sigs = Table<<String,Int32>>()
        local method_param_types = Int32[]
        local method_param_name_sigs = Table<<String,Int32>>()
        local method_param_names = Int32[]
        forEach (type in type_list)
          forEach (m in type.method_list)
            if (not m.is_macro)
              if (m.store_dynamically and m.is_used and not m.is_abstract)
                if (not method_names.contains(m.name))
                  method_names[m.name] = method_names.count
                endIf

                # parameter types
                local sig = ",".join(m.parameters.mapped<<String>>( (l)=>(l.type.name) ))
                if (not method_param_type_sigs.contains(sig))
                  method_param_type_sigs[sig] = method_param_types.count
                  method_param_types.add(m.parameters.mapped<<Int32>>( (l)=>(l.type.index) ))
                endIf

                # parameter names
                sig = ",".join(m.parameters.mapped<<String>>( (l)=>(l.name) ))
                if (not method_param_name_sigs.contains(sig))
                  method_param_name_sigs[sig] = method_param_names.count
                  method_param_names.add(m.parameters.mapped<<Int32>>( (l)=>(Program.add_literal_string(l.name)) ))
                endIf
              endIf
            endIf
          endForEach
        endForEach
        writer.println(  "const char* Rogue_method_name_strings[] =" )
        writer.println "{"
        writer.indent += 2
        forEach (item at index in method_names.reader)
          assert index == item.value
          writer.println '/* $ */ "$",' (item.value, item.key)
        endForEach
        writer.indent -= 2
        writer.println "};"
        writer.println

        writer.println(  "const int Rogue_method_param_names[] =" )
        writer.println "{"
        writer.indent += 2
        block
          local count = 0
          forEach (item in method_param_names)
            writer.print "$," (item)
            count += 1
            if (count >= 25) writer.println; count = 0
          endForEach
          if (count) writer.println
        endBlock
        writer.indent -= 2
        writer.println "};"
        writer.println

        writer.println(  "const int Rogue_method_param_types[] =" )
        writer.println "{"
        writer.indent += 2
        block
          local count = 0
          forEach (item in method_param_types)
            writer.print "$," (item)
            count += 1
            if (count >= 25) writer.println; count = 0
          endForEach
          if (count) writer.println
        endBlock
        writer.indent -= 2
        writer.println "};"
        writer.println

        writer.println "// name_string, arg_count, first_param_name, first_param_type, return_type, introspection call handler index"
        writer.println(  "const int Rogue_method_info_table[][6] =" )
        writer.println "{"
        writer.indent += 2
        forEach (type in type_list)
          forEach (m at index in type.method_list)
            if (index >= type.dynamic_method_table_count) escapeForEach
            if (not m.is_macro)
              if (m.store_dynamically and m.is_used and not m.is_abstract)
                local type_sig = ",".join(m.parameters.mapped<<String>>( (l)=>(l.type.name) ))
                local name_sig = ",".join(m.parameters.mapped<<String>>( (l)=>(l.name) ))
                local handler_index = -1
                if (Program.using_introspection)
                  handler_index = m.introspection_call_handler.index
                endIf

                writer.println '{$,$,$,$,$,$}, // $.$' (method_names[m.name], m.parameters.count, method_param_name_sigs[name_sig], method_param_type_sigs[type_sig], select{m.return_type:m.return_type.index || -1}, handler_index, type.name, m.signature)
              else
                writer.println '{-1,-1,-1,-1,-1,1},'
              endIf
            endIf
          endForEach
        endForEach
        writer.indent -= 2
        writer.println "};"
        writer.println

        # Global property pointers
        writer.println(  "const void* Rogue_global_property_pointers[] =" )
        writer.println "{"
        writer.indent += 2

        first = true
        forEach (type in type_list)
          if (type.is_class or type.is_compound)
            forEach (p in type.global_list)
              if (first) first = false
              else       writer.println ","
              if (p.is_native) writer.print "0"
              else             writer.print( "(void*) &Rogue" ).print( p.type_context.cpp_name ).print( "_" )
              writer.print( p.cpp_name )
            endForEach
          endIf
        endForEach

        writer.println
        writer.indent -= 2
        writer.println( "};" )
        writer.println

        # Property offsets
        writer.println(  "const int Rogue_property_offsets[] =" )
        writer.println "{"
        writer.indent += 2

        first = true
        forEach (type in type_list)
          if (type.is_class or type.is_compound)
            forEach (p in type.property_list)
              if (first) first = false
              else       writer.println ","
              if (p.is_native) writer.print( "0" )
              else writer.print( "(int)(intptr_t)&((" ).print( type.cpp_class_name ).print( "*)0)->" ).print( p.cpp_name )
            endForEach
          endIf
        endForEach

        writer.println
        writer.indent -= 2
        writer.println( "};" )
        writer.println
      endIf


      # Object size table
      writer.print(   "const int Rogue_object_size_table[" ).print( type_list.count ).println( "] =" )
      writer.println "{"
      writer.indent += 2

      first = true
      forEach (type in type_list)
        if (first) first = false
        else       writer.println ","

        writer.print( "(int) sizeof(" ).print( type.cpp_class_name ).print( ")" )
      endForEach

      writer.println
      writer.indent -= 2
      writer.println( "};" )
      writer.println

      if (Program.using_introspection)
        # Attributes table
        writer.print(   "const int Rogue_attributes_table[" ).print( type_list.count ).println( "] =" )
        writer.println "{"
        writer.indent += 2

        first = true
        forEach (type in type_list)
          if (first) first = false
          else       writer.println ","

          writer.print( type.attributes.flags )
        endForEach

        writer.println
        writer.indent -= 2
        writer.println( "};" )
        writer.println
      endIf

      # Allocators
      writer.print( "int Rogue_allocator_count = " ).print( 1 ).println( ";" )
      writer.print( "RogueAllocator Rogue_allocators[" ).print( 1 ).println( "];" )
      writer.println

      # Types
      writer.print( "int Rogue_type_count = " ).print( type_list.count ).println( ";" )
      writer.print( "RogueType Rogue_types[" ).print( type_list.count ).println( "];" )
      writer.println

      # RogueType_X declarations.
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print( "RogueType* RogueType" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      writer.print( "int Rogue_literal_string_count = " ).print( Program.literal_string_list.count ).println( ";" )
      writer.print( "RogueString* Rogue_literal_strings[" ).print( Program.literal_string_list.count ).println( "];" );
      writer.println

      forEach (type in type_list) type.print_global_method_definitions( writer )
      writer.println

      forEach (type in type_list) type.print_method_definitions( writer )
      writer.println

      # configure() method
      writer.println( "void Rogue_configure( int argc, const char* argv[] )" )
      writer.println( "{" )
      writer.indent += 2

      writer.println @|if (Rogue_configured) return;
                      |Rogue_configured = 1;
                      |
                      |Rogue_argc = argc;
                      |Rogue_argv = argv;
                      |
                      |Rogue_thread_register();
                      |Rogue_configure_gc();
                      |Rogue_configure_types();
                      |set_terminate( Rogue_terminate_handler );
                      |


      # Create types
      forEach (type in type_list)
        if (not type.omit_output or (type.is_native and not type.is_array))
          writer.print("RogueType").print(type.cpp_name).print(" = &Rogue_types[ ").print(type.index).println(" ];")
          # TODO
        endIf
      endForEach
      writer.println

      forEach (i of Program.literal_string_list)
        writer.print(   "Rogue_literal_strings[" ).print(i)
        writer.print("] = (RogueString*) RogueObject_retain( RogueString_create_from_utf8( ")
        local st = Program.literal_string_list[i]
        writer.print_literal_string( st )
        writer.print( ", " ).print( st.byte_count )
        writer.println( " ) );" )
      endForEach
      writer.println

      # End of configure()
      writer.indent -= 2
      writer.println( "}" )
      writer.println

      # init_thread()
      writer.println( "void Rogue_init_thread()" )
      writer.println( "{" )
      writer.indent += 2
      if (first_thread_local)
        writer.println("ROGUE_THREAD_LOCALS_INIT($, $);" (first_thread_local, last_thread_local))
      endIf
      forEach (type in type_list)
        if (type.is_used)
          local m = type.find_global_method( "init_class_thread_local()" )
          if (m and m.type_context is type)
            writer.print( m.cpp_name ).println( "();" )
          endIf
        endIf
      endForEach
      writer.indent -= 2
      writer.println( "}" )
      writer.println

      # deinit_thread()
      writer.println( "void Rogue_deinit_thread()" )
      writer.println( "{" )
      writer.indent += 2
      if (first_thread_local)
        writer.println("ROGUE_THREAD_LOCALS_DEINIT($, $);" (first_thread_local, last_thread_local))
      endIf
      writer.indent -= 2
      writer.println( "}" )
      writer.println

      if (RogueC.gc_mode == GCMode.BOEHM_TYPED)
        write_boehm_type_info writer
      endIf

      # launch()
      writer.println @|#ifdef ROGUE_AUTO_LAUNCH
                      |__attribute__((constructor))
                      |#endif
      writer.println( "void Rogue_launch()" )
      writer.println( "{" )
      writer.indent += 2

      # Call configure; if it has already been called, this won't do anything.
      writer.println( "Rogue_configure(0, NULL);" )

      # Call all init_class() methods
      forEach (type in type_list)
        if (type.is_used)
          local m = type.find_global_method( "init_class()" )
          if (m and m.type_context is type)
            writer.print( m.cpp_name ).println( "();" )
          endIf
        endIf
      endForEach
      writer.println

      # Call thread-local initialization
      writer.println( "Rogue_init_thread();" );
      writer.println

      # Copy command line args to System class
      writer.println @|RogueSystem_executable_filepath = RogueString_create_from_utf8(
                      |    Rogue_argc ? Rogue_argv[0] : "Rogue", -1 );
                      |
                      |for (int i=1; i<Rogue_argc; ++i)
                      |{
                      |  RogueString_List__add__String( RogueSystem_command_line_arguments,
                      |      RogueString_create_from_utf8( Rogue_argv[i], -1 ) );
                      |}
      writer.println

      # Instantiate all essential singletons
      writer.println "// Instantiate essential singletons"
      forEach (type in type_list)
        if (not type.omit_output and type.is_singleton and type.is_essential)
          writer.print( "ROGUE_SINGLETON( " ).print( type.cpp_name ).println( " );" )
        endIf
      endForEach
      writer.println


      # Call Global.on_launch()
      writer.println @|RogueGlobal__on_launch( (RogueClassGlobal*) (ROGUE_SINGLETON(Global)) );
                      |Rogue_collect_garbage();

      writer.indent -= 2
      writer.println( "}" )
      writer.println

      # Rogue_update_tasks() method
      writer.println @|bool Rogue_update_tasks()
                      |{
                      |  // Returns true if any tasks are still active
                      |  try
                      |  {

      local uses_tasks = Program.is_type_used("TaskManager")
      if (uses_tasks)
        writer.println @|    RogueClassTaskManager* task_manager = (RogueClassTaskManager*) ROGUE_SINGLETON(TaskManager);
                        |    bool result = RogueTaskManager__update( task_manager );
                        |    Rogue_collect_garbage();
                        |    return result;
      else
        writer.println @|    Rogue_collect_garbage();
                        |    return false;
      endIf

      writer.println @|  }
                      |  catch (RogueException* err)
                      |  {
                      |    printf( "Uncaught exception\n" );
                      |    RogueException__display( err );
                      |    return false;
                      |  }
                      |}
                      |


      # Optional main()
      if (RogueC.generate_main)
        writer.println
        writer.println( @|int main( int argc, const char* argv[] )
                         |{
                         |  try
                         |  {
                         |    Rogue_configure( argc, argv );
                         |    Rogue_launch();
                         |
                         |    while (Rogue_update_tasks()) {}
                         |
                         |    Rogue_quit();
                         |  }
                         |  catch (RogueException* err)
                         |  {
                         |    printf( "Uncaught exception\n" );
                         |    RogueException__display( err );
                         |  }
                         |
                         |  return 0;
                         |}
        )
      endIf

      forEach (plugin in RogueC.plugins)
        plugin.finish_code_file( writer )
      endForEach

      writer.close

    method _write_boehm_type_info( writer:CPPWriter, type:Type, type_name=null:String, leader=null:String )
      if (not type_name) type_name = type.cpp_class_name
      if (leader) leader = leader + "."
      else leader = ""
      forEach (p in type.property_list)
        if (p.type.is_reference)
          writer.println( "GC_set_bit(bitmap, GC_WORD_OFFSET($, $$));" (type_name, leader, p.cpp_name) )
        elseIf (p.type.is_compound)
          _write_boehm_type_info( writer, p.type, type_name, leader + p.cpp_name )
        endIf
      endForEach

    method write_boehm_type_info( writer:CPPWriter )
      writer.println @|#if ROGUE_GC_MODE_BOEHM_TYPED
                      |void Rogue_init_boehm_type_info()
                      |{
      writer.indent += 2
      writer.println @|int largest = 0;
                      |for (int i = 0; i < sizeof(Rogue_object_size_table) / sizeof(Rogue_object_size_table[0]); ++i)
                      |{
                      |  if (Rogue_types[i].object_size > largest) largest = Rogue_types[i].object_size;
                      |}
                      |int bitmap_size = sizeof(GC_word)*( ((largest/sizeof(GC_word)) + GC_WORDSZ - 1) / GC_WORDSZ );
                      |GC_word * bitmap = (GC_word*)alloca(bitmap_size);

      forEach (type in type_list)
        if (type.is_used)
          #NOTE: The decision of whether or not to write type info should be matched
          #      with the writing of the type_info field "gc_alloc_type".
          if (type.has_object_references)
            writer.println "memset(bitmap, 0, bitmap_size);"
            _write_boehm_type_info( writer, type )
            writer.println "Rogue_types[$].gc_type_descr = GC_make_descriptor(bitmap, Rogue_types[$].object_size / sizeof(GC_word));" ...
                           (type.index, type.index)
          endIf
        endIf
      endForEach
      writer.indent -= 2
      writer.println @|}
                      |#endif
      writer.println

    method collect_type_info( type:Type, info:Int32[] )
      info.add( 0 )  # allocator 0

      if (type.is_primitive)
        info.add( 0 )
      else
        info.add( type.dynamic_method_table_index )
      endIf

      local flat_base_types = Type[]
      if (type.base_class) type.base_class.collect_base_types( flat_base_types )
      forEach (base_type in type.base_types)
        base_type.collect_base_types( flat_base_types )
      endForEach

      info.add( flat_base_types.count )
      forEach (base_type in flat_base_types) info.add( base_type.index )

      info.add( type.global_list.count )
      forEach (p in type.global_list) info.add( Program.add_literal_string(p.name) )
      forEach (p in type.global_list) info.add( p.type.index )

      info.add( type.property_list.count )
      forEach (p in type.property_list) info.add( Program.add_literal_string(p.name) )
      forEach (p in type.property_list) info.add( p.type.index )

      if (RogueC.gc_mode == GCMode.BOEHM_TYPED)
        # Write the gc_alloc_type field
        # These same conditions should be used in write_boehm_type_info()
        if (not type.has_object_references)
          info.add( 1 ) # ROGUE_GC_ALLOC_TYPE_ATOMIC
        else
          info.add( 2 ) # ROGUE_GC_ALLOC_TYPE_TYPED
        endIf
        #NOTE: We could consider using ROGUE_GC_ALLOC_TYPE_UNTYPED (0) for, e.g.,
        #      objects which are entirely made of references, though the collector
        #      actually catches a number of such cases.
      endIf

      if (type.is_aspect or type.is_compound or type.is_class)
        info.add( type.dynamic_method_table_count )
      else
        info.add( 0 )
      endIf

    method print_property_trace_code( type:Type, writer:CPPWriter )
      forEach (p in type.property_list)

        if (p.type.is_reference or p.type.has_object_references)

          if (p.type.is_reference and not p.type.is_array)
            writer.print( "if ((link=((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
            writer.println( ")) ((RogueObject*)link)->type->trace_fn( link );" )

          else
            if (p.type.is_compound)
              writer.print( "Rogue" ).print( p.type.cpp_name ).print( "_trace( &" )
              writer.print( "((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
              writer.println( " );" )

            else
              local trace_class_name = "Object"
              if (p.type.is_array)
                if (p.type.element_type.is_compound and p.type.element_type.has_object_references)
                  trace_class_name = Program.validate_cpp_name( p.type.name )
                else
                  trace_class_name = "Array"
                endIf

              else
                trace_class_name = Program.validate_cpp_name(p.type.cpp_name)
              endIf

              writer.print( "if ((link=" )
              writer.print( "((" ).print( type.cpp_class_name ).print( "*)obj)->" ).print( p.cpp_name )
              writer.print( ")) Rogue" ).print( trace_class_name ).println( "_trace( link );" )
            endIf

          endIf
        endIf

      endForEach
endAugment


#------------------------------------------------------------------------------
# CPPWriter
#------------------------------------------------------------------------------
class CPPWriter
  PROPERTIES
    filepath : String
    buffer   = StringBuilder()
    indent   = 0
    needs_indent = true
    line_number = 1

    trace_token : Token

    temp_buffer = StringBuilder()

  METHODS
    method init( filepath )

    method close
      local path = File.path( filepath )
      if (path.count) File.create_folder( path )
      File.save( filepath, buffer->String )

    method print_indent
      if (needs_indent)
        needs_indent = false
        forEach (1..indent) buffer.print(' ')
      endIf

    method print( value:Int64 )->CPPWriter
      print_indent
      buffer.print( value )
      return this

    method print( value:Int32 )->CPPWriter
      print_indent
      buffer.print( value )
      return this

    method print( value:Real64 )->CPPWriter
      print_indent

      buffer.print( value )

      return this

    method print( value:Real32 )->CPPWriter
      print_indent
      buffer.print( value )
      return this

    method print( value:Character )->CPPWriter
      # Do we need to check for newlines here?
      print_indent
      buffer.print( value )
      return this

    method print( value:String )->CPPWriter
      local needs_newline = false
      if (value.contains('\n'))
        forEach (line in LineReader(value))
          if (needs_newline)
            println
          endIf
          if (line.count) print_indent
          buffer.print( line )
          needs_newline = true
        endForEach
      else
        print_indent
        buffer.print( value )
      endIf
      return this

    method print_code( code:String )->CPPWriter
      forEach (line in LineReader(code))
        local original_indent = indent
        if (line.begins_with('#')) indent = 0

        println( line )

        indent = original_indent
      endForEach
      return this

    method println->CPPWriter
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Int64 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Int32 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Real64 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:Real32 )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method println( value:String )->CPPWriter
      print( value )
      buffer.print( '\n' )
      ++line_number
      needs_indent = true
      return this

    method print_param ( param:Local )->CPPWriter
      print( param.type )
      if (param.is_alias)
        print(" &")
      endIf
      return this

    method print( type:Type )->CPPWriter
      print_type_name( type )
      if (type and type.is_reference) buffer.print("*")
      return this

    method print_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      return print( "(" ).print( to_type ).print( ")" )
      return this

    method print_open_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      print( "(" )
      return print_cast( from_type, to_type )

    method print_close_cast( from_type:Type, to_type:Type )->CPPWriter
      if (from_type is to_type) return this
      print( ")" )
      return this

    method print_cast( from_type:Type, to_type:Type, cmd:Cmd )->CPPWriter
      if (from_type is to_type)
        cmd.write_cpp( this )
      else
        print( "(" )
        print_cast( from_type, to_type )
        cmd.write_cpp( this )
        print( ")" )
      endIf
      return this

    method print_access_operator( type:Type )->CPPWriter
      if (type.is_reference) return print( "->" )
      else                   return print( "." )

    method print_type_name( type:Type )->CPPWriter
      print_indent
      if (type) buffer.print( type.cpp_class_name )
      else       buffer.print( "void" )
      return this

    method print_type_info( type:Type )->CPPWriter
      print_indent
      buffer.print( "RogueType" ).print( type.cpp_name )
      return this

    method print_default_value( type:Type )->CPPWriter
      if (type.is_compound)
        print( type ).print( "()" )
      else
        buffer.print( "0" )
      endIf
      return this

    method print_hex_pair( value:Int32 )->this
      print "\\x"
      print ((value :>>>: 4).to_digit)
      print ((value & 15).to_digit)
      return this

    method print_literal_character( ch:Character, in_string:Logical )->this
      if (ch >= 32 and ch <= 126)
        which (ch)
          case '"'
            if (in_string) print( "\\\"" )
            else           print( "\"" )
          case '\''
            if (in_string) print( "'" )
            else           print( "\\'" )
          case '\\'
            print( "\\\\" )
          others
            print( ch )
        endWhich
      else
        which (ch)
          case 10
            print "\\n"
          others
            # Must print as separate string to avoid C \x ambiguity.  For instance,
            # "This is \x9CCool" is interpreeted as "This is \x9CC" followed by "ool",
            # so we have to generate "This is ""\x9C""Cool".
            print( "\"\"" )  # end of string so far and beginning of hex escape string
            if (ch <= 0x7F)
              print_hex_pair( ch )
            elseIf (ch <= 0x7FF)
              print_hex_pair(0xC0 | ((ch :>>>: 6) & 0x1F))
              print_hex_pair(0x80 | (ch & 0x3F))
            elseIf (ch <= 0xFFFF)
              print_hex_pair( 0xE0 | ((ch :>>>: 12) & 0xF) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            else
              print_hex_pair( 0xF0 | ((ch :>>>: 18) & 0x7) )
              print_hex_pair( 0x80 | ((ch :>>>: 12) & 0x3F) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            endIf
            print( "\"\"" )  # end of hex escape string and continuation of original string
        endWhich
      endIf

      return this

    method print_literal_string( st:String, &omit_quotes )->this
      if (st is null)
        print( "0" )
        return this
      endIf

      if (not omit_quotes) print( "\"" )

      local stage = 0
      # 0: \ -> 1 ignore next
      #    ? -> 2 first question mark
      # 1: -> 0
      # 2: ? -> print \ -> 0
      #    else  0

      forEach (ch in st)
        which (stage)
          case 0
            if (ch == '\\')    stage = 1
            elseIf (ch == '?') stage = 2
          case 1
            stage = 0
          case 2
            if (ch == '?') print( '\\' )  # Escape the second question mark in a row to avoid accidental trigraphs
            stage = 0
        endWhich
        print_literal_character( ch, true )
      endForEach
      if (not omit_quotes) print( "\"" )

      return this

    method print_native_code( t:Token, type_context:Type, method_context:Method, locals:Local[], code:String, result_type=null:Type )->this
      # $a is a convenience for $(a) with the latter being more flexible
      #
      # $local_var_name
      # $property_name
      # $this
      # $($TypeSpecializer)
      # $retain
      # $release
      forEach (line in LineReader(code))
        local original_indent = indent
        if (line.begins_with('#')) indent = 0

        # Replace $this and other local names ($x, $count, etc) with native
        # variable reads.
        local marker = line.locate( '$' )
        while (marker)
          local name : String

          local i1 = marker.value
          if (i1 > 0) print line.leftmost( i1 )
          local i2 = i1+1
          if (i2 < line.count and line[i2] == '(')
            # We have $(name) or $(name.x)
            ++i2
            while (i2 < line.count and line[i2] != ')') ++i2
            name = line.from( i1+2, i2-1 )
            line = line.from( i2+1 )
          else
            # Just $name
            while (i2 < line.count and line[i2].is_identifier) ++i2
            name = line.from( i1+1, i2-1 )
            line = line.from( i2 )
          endIf

          print_native_marker( t, type_context, method_context, locals, name )

          marker = line.locate( '$' )
        endWhile

        if (line.count)
          if (result_type) print   line
          else             println line
        endIf

        indent = original_indent
      endForEach
      return this

    method print_native_marker( t:Token, type_context:Type, method_context:Method, locals:Local[], name:String )->this
      # name:$(this.type) -> name:this, operation:type
      local operation = name.after_first( '.' )
      name = name.before_first( '.' )

      which (name)
        case "$"
          print "$"

        case "this"
          print_native_code_marker_value( t, name, operation, "THIS", type_context )

        others
          if (name.begins_with('$'))
            # Probably a specializer name like $DataType
            local cur_type = type_context
            while (cur_type)
              if (cur_type.specializers)
                forEach (specializer in cur_type.specializers)
                  if (specializer.name == name)
                    which (operation)
                      case ""
                        local type = Parser(specializer.tokens).parse_type.organize
                        print( type )
                        return this
                    endWhich
                  endIf
                endForEach
              endIf
              if (method_context and method_context.source_template)
                forEach (specializer at i in method_context.source_template.type_parameters)
                  if (specializer.name == name)
                    which (operation)
                      case ""
                        local type = Parser(t,method_context.name,method_context.name.from_first("<<"))...
                          .parse_specialization_type(i).organize
                        print( type )
                        return this
                    endWhich
                  endIf
                endForEach
              endIf
              cur_type = cur_type.base_class
            endWhile
            throw t.error( "Unrecognized native code insertion marker: $$.$" ('$',name,operation) )
          endIf

          if (method_context and locals)
            forEach (v in locals step -1)
              if (v.name == name)
                print_native_code_marker_value( t, name, operation, v.cpp_name, v.type )
                escapeWhich
              endIf
            endForEach
          endIf

          local p = type_context.property_lookup[ name ]
          if (p)
            if (type_context.is_reference)
              print_native_code_marker_value( t, name, operation, "THIS->" + p.cpp_name, p.type )
            else
              print_native_code_marker_value( t, name, operation, "THIS." + p.cpp_name, p.type )
            endIf
            escapeWhich
          endIf

          print( "$" ).print( name )
      endWhich
      return this

    method print_native_code_marker_value( t:Token, name:String, operation:String, default:String, type:Type )
      which (operation)
        case "release"
          if (type and type.is_reference)
            print( '(' ).print_cast( Program.type_Object, type ).print( "RogueObject_release(" )
            print_cast( type, Program.type_Object ).print( default ).print( "))" )
          else
            print( default )
          endIf
        case "retain"
          if (type and type.is_reference)
            print( '(' ).print_cast( Program.type_Object, type ).print( "RogueObject_retain(" )
            print_cast( type, Program.type_Object ).print( default ).print( "))" )
          else
            print( default )
          endIf
        case "type"
          print( type )
        case "type_name"
          print_type_name( type )
        case ""
          print( default )
        others
          throw t.error( "Unrecognized native code insertion marker: $$.$" ('$',name,operation) )
      endWhich

    method print_arg ( arg:Cmd, param_info=null:Local, cast_to=null:Type, &is_mutating )
      # Prints an argument to a call
      #
      # Note that the argument here may not be an argument as far as *Rogue*
      # is concerned, but it's an argument as far as C++ is concerned (e.g.,
      # it may be the "this" pointer).
      # If param_type is given and is an aspect, we do an aspect-wrap.
      # If cast_to is given, we'll insert a cast to this type.

      local param_type = select{param_info : param_info.type || arg.type}->Type
      local is_alias = is_mutating or (param_info and param_info.is_alias)
      if (is_alias)
        if (arg.is_safely_mutable)
          # CmdReadLocal
          # CmdReadSingleton
          # CmdThisContext
          # CmdReadProperty where context.is_safely_mutable
          noAction # These are always okay
        elseIf (arg instanceOf CmdReadArrayElement)
          # It's possible to shoot oneself in the foot with this, but it's
          # potentially useful, so we allow it when it's easy.
          if (RogueC.gc_mode == GCMode.AUTO_ST or RogueC.gc_mode == GCMode.AUTO_MT)
            if (param_info)
              throw arg.t.error("The argument for parameter '$' cannot be aliased, because element access aliases " ...
                                "are not currently supported in the active garbage collection mode." (param_info.name))
            else
              throw arg.t.error("Cannot call a [mutating] method on an element access because it is " ...
                                "not currently supported in the active garbage collection mode." )
            endIf
          endIf
        else
          if (param_info)
            throw arg.t.error("The argument for parameter '$' cannot be aliased because it is produced by evaluating an expression - only local variable and singleton accesses can be aliased." (param_info.name))
          else
            throw arg.t.error("Cannot call a [mutating] method on a context produced by evaluating an expression - mutating methods can only be called only local variable and singleton contexts.")
          endIf
        endIf
        if (RogueC.gc_mode == GCMode.AUTO_ST or RogueC.gc_mode == GCMode.AUTO_MT)
          if (not (param_type.is_primitive or param_type.is_compound))
            if (param_info)
              throw arg.t.error("The parameter '$' can not be an alias, because the active garbage collection mode " ...
                                "currently only supports primitive and compound aliases." (param_info.name))
            else
              throw arg.t.error("Cannot call a [mutating] method on a reference type due to the active garbage collection mode - only calls to mutating primitive and compound methods are supported.")
            endIf
          endIf
        endIf
      endIf

      local close_paren = 0

      # We want to increase the reference count of arguments we're passing,
      # which happens by wrapping them in ROGUE_ARG.  If this argument is
      # guaranteed to have a lifetime at least as long as the call we're
      # making, we can skip this.
      if (arg.type.is_compound)
        noAction # Compound lifetime is tied to stack frame!
      elseIf (arg instanceOf CmdReadLocal)
        noAction # Current frame won't die before call
      elseIf (arg instanceOf CmdReadSingleton)
        noAction # Singletons live forever
      elseIf (arg instanceOf CmdLiteral)
        noAction # Literals live forever
      else
        # Can't be sure.  Increase the ref count.
        print( "ROGUE_ARG(" )
        ++ close_paren
      endIf

      if (param_type and param_type.is_aspect)
        print( "(" ).print_cast(arg.type, param_type).print("(")
        close_paren += 2
      endIf

      if (cast_to)
        print_cast( arg.type, cast_to, arg )
      elseIf (arg.type is not param_type)
        print_cast( arg.type, param_type, arg )
      else
        arg.write_cpp( this )
      endIf

      while (close_paren)
        -- close_paren
        print( ")" )
      endWhile

    method print_export ( m:Method )->CPPWriter
      if (m.is_c_compatible()) print("ROGUE_EXPORT_C ")
      else                     print("ROGUE_EXPORT   ")
      return this

    method mark_statement_start( statement_filepath:String, start_line:Int32, end_line:Int32 )
      #@trace "STATEMENT ", this.filepath, this.line_number, statement_filepath, start_line, end_line

    method mark_statement_end
      noAction

    method mark_method_start( t:Type, m:Method )
      if (m.omit_output) return
      #@trace "METHOD ", this.filepath, this.line_number, t.name, m.name

    method mark_method_end
      noAction

    method mark_routine_start ( m:Method )
      if (m.omit_output) return
      #@trace "ROUTINE ", this.filepath, this.line_number, m.name

    method mark_routine_end
      noAction

    method update_trace_info( t:Token )
      if (trace_token and t and t.filepath)
        if (t.filepath is not trace_token.filepath)
          if (RogueC.debug_mode)
            print( ";__trace.filename = \"" ).print( t.filename ).println( "\";" )
            print( ";__trace.line = " ).print( t.line ).println( ";" )
          endIf
        elseIf (t.line != trace_token.line)
          if (RogueC.debug_mode) print( ";__trace.line = " ).print( t.line ).println( ";" )
        endIf
      endIf
      trace_token = t
endClass


#------------------------------------------------------------------------------
# RogueC
#------------------------------------------------------------------------------
augment RogueC
  METHODS
    method launch
      <collect_supported_targets>
      supported_targets.add( "C++" )

    method write_output
      <target_specific_code>
      if (compile_targets["C++"]) write_cpp; return

    method write_cpp
      if (output_filepath is null)
        output_filepath = File.filename(first_filepath)
        if (output_filepath.to_lowercase.ends_with(".rogue")) output_filepath = output_filepath.leftmost(-6)

        if (RogueC.compile_targets["Cython"] or RogueC.compile_targets["Python"]) output_filepath = output_filepath.to_lowercase

      else
        if (File.is_folder(output_filepath))
          output_filepath += "/"

          local filename = File.filename( first_filepath )
          if (filename.to_lowercase.ends_with(".rogue")) filename = filename.leftmost(-6)
          else                                           filename = "RogueProgram"

          if (RogueC.compile_targets["Cython"] or RogueC.compile_targets["Python"]) output_filepath = output_filepath.to_lowercase

          output_filepath += filename

        elseIf (output_filepath.to_lowercase.ends_with(".cpp"))
          output_filepath = output_filepath.leftmost(-4)
        endIf
      endIf

      Program.write_cpp( output_filepath )
      RogueC.on_compile_finished

      if (compile_output)
        local compiler_name = RogueC.compiler_name
        if (not compiler_name)
          native @|#if defined(DEFAULT_CXX)
                  |  $compiler_name = RogueString_create_from_utf8( DEFAULT_CXX );
                  |#else
                  |  $compiler_name = RogueString_create_from_utf8( "g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof" );
                  |#endif
          if (RogueC.thread_mode == ThreadMode.PTHREADS)
            compiler_name += " -pthread"
          elseIf (RogueC.thread_mode == ThreadMode.CPP)
            if (not RogueC.compile_targets["Windows"])
              compiler_name += " -pthread"
            endIf
          endIf
        endIf

$if not target("WINDOWS")
        if (RogueC.pkg_config_pkgs.count)
          forEach (pkg in RogueC.pkg_config_pkgs)
            local result = Process.run("pkg-config --cflags --libs " + pkg)
            if (result.success)
              compiler_name += " " + result.output_string.trimmed
            else
              local msg = result.error_string.trimmed
              if (msg.count == 0) msg = result.output_string.trimmed
              local full_msg = "Couldn't configure pkg-config package '$'" (pkg)
              if (msg.count)
                full_msg += ":\n" + msg
              else
                full_msg += "."
              endIf
              throw Error(full_msg)
            endIf
          endForEach
        endIf
$endIf

        if (RogueC.compiler_options.count)
          compiler_name += " " + " ".join(RogueC.compiler_options)
        endIf

        local exe = output_filepath
        if (exe.contains('/'))
          exe = File.path(exe) + "/" + File.filename(exe).to_lowercase
        else
          exe = exe.to_lowercase
        endIf
$if not target("WINDOWS")
        local cmd = "$ $.cpp -o $" (compiler_name,output_filepath,exe)
        if (execute_args) cmd += " && ./$ $" (exe,execute_args)
        println cmd
        println
        if (System.run(cmd)) System.exit( 1 )
$else # Windows
        local cmd = "$ $.cpp /Fe$.exe" (compiler_name,output_filepath,exe)
        println cmd
        if (System.run(cmd)) System.exit( 1 )
        if (execute_args) cmd = ".\\$ $" (exe,execute_args)
        println cmd
        println
        if (System.run(cmd)) System.exit( 1 )
$endIf
      endIf

endAugment


#------------------------------------------------------------------------------
# Type
#------------------------------------------------------------------------------
augment Type
  PROPERTIES
    cpp_name       : String
    cpp_class_name : String
    cpp_type_name  : String

  METHODS
    method assign_cpp_name
      if (cpp_name) return
      cpp_name = Program.validate_cpp_name( name )

      if (is_array or this is Program.type_Array)
        cpp_class_name = "RogueArray"
        cpp_name = "Array"

      elseIf (this.is_primitive or this.simplify_name)
        cpp_class_name = "Rogue" + cpp_name

      elseIf (is_list)
        cpp_class_name = "Rogue" + cpp_name

      elseIf (is_optional)
        cpp_name = Program.validate_cpp_name( "Optional" + element_type.cpp_name )
        cpp_class_name = "Rogue" + cpp_name

      else
        cpp_class_name = "RogueClass" + cpp_name
      endIf

      cpp_type_name = "RogueType" + cpp_name

      forEach (s in global_list)
        s.cpp_name = Program.validate_cpp_name( s.name )
      endForEach

      forEach (p in property_list)
        if (p.is_native) p.cpp_name = p.name
        else             p.cpp_name = Program.validate_cpp_name( p.name )
      endForEach

    method print_data_definition( writer:CPPWriter )
      if (omit_output or is_primitive) return

      writer.print( "struct " ).print( cpp_class_name )
      local is_error = false
      if (is_reference)
        if (instance_of(Program.type_Exception))
          is_error = true
          writer.print( " : " ).print_type_name( base_class )
        else
          writer.print( " : RogueObject" )
        endIf
      endIf
      writer.println.println( "{" )
      writer.indent += 2

      # Properties
      if (not is_aspect)
        writer.println "// PROPERTIES"
        forEach (p in property_list)
          if (not is_error or p.type_context is this)
            if (is_compound and p.type.is_reference)
              writer.print( "ROGUE_DEF_COMPOUND_REF_PROP(")
              writer.print( p.type ).print(",").print( p.cpp_name )
              writer.print( ");")
            elseIf (p.is_native)
              writer.print_native_code( p.t, this, null, null, p.name )
            else
              writer.print( p.type ).print(" ").print( p.cpp_name ).println(";")
            endIf
          endIf
        endForEach
        writer.println
      endIf

      if (is_compound)
        if (property_list.count)
          # Default Constructor
          writer.print( this ).print( "() { memset( this, 0, sizeof(" ).print( this ).println( ") ); }" )
          writer.println

          local native_property_count = 0
          forEach (p in property_list)
            if (p.is_native) ++native_property_count
          endForEach

          # This is sort of a strange place to do this, but we usually need to
          # count the native properties here anyway.
          local compare_method = find_method("operator==($)" (this.name))
          if (compare_method is null or (compare_method.attributes.includes(Attribute.is_generated)))
            if (native_property_count != 0)
              throw t.error( "Compound $ contains native properties and must therefore implement operator==()" (name) )
            endIf
          endIf

          if (is_optional)
            # Value Constructor, exists->true
            writer.print( this ).print( "( " ).print( property_list.first.type )
            writer.println( " value, bool exists=true ) : value(value), exists(exists) {}" )
          else
            # Standard Constructor
            contingent
              necessary (native_property_count == 0)

            satisfied
              # No native properties - use property initializer syntax
              writer.print( this ).print( "( " )
              local first = true
              forEach (p in property_list)
                if (first) first = false
                else       writer.print( ", " )
                writer.print( p.type ).print(" ").print( p.cpp_name )
              endForEach
              writer.print( " ) : " )
              first = true
              forEach (p in property_list)
                if (first) first = false
                else       writer.print( ", " )
                writer.print( p.cpp_name ).print("(").print( p.cpp_name ).print(")")
              endForEach
              writer.println( " {}" )
              writer.println

            unsatisfied
              # Native properties - start with a memset and then assign non-native properties individually.
              # If there are no non-native properties then just skip this entirely.
              if (native_property_count != property_list.count)
                writer.print( this ).print( "( " )
                local first = true
                forEach (p in property_list)
                  if (not p.is_native)
                    if (first) first = false
                    else       writer.print( ", " )
                    writer.print( p.type ).print(" ").print( p.cpp_name )
                  endIf
                endForEach
                writer.println( " )" )
                writer.println( "{" )
                writer.indent += 2

                writer.print( "memset( this, 0, sizeof(" ).print( this ).println( ") );" )

                forEach (p in property_list)
                  if (not p.is_native)
                    writer.print( "this->" ).print( p.cpp_name ).print(" = ").print( p.cpp_name ).println(";")
                  endIf
                endForEach

                writer.indent -= 2
                writer.println( "}" )
                writer.println
              endIf
            endContingent
          endIf
        endIf
      endIf

      writer.indent -= 2
      writer.println( "};" )

    method print_global_method_prototypes( writer:CPPWriter )
      forEach (m in global_method_list)
        if (m.type_context is this) m.print_prototype( writer )
      endForEach

    method print_global_method_definitions( writer:CPPWriter )
      forEach (m in global_method_list)
        if (m.type_context is this)
          writer.mark_routine_start( m )
          m.print_definition( writer )
          writer.mark_routine_end
        endIf
      endForEach

    method print_method_prototypes( writer:CPPWriter )
      forEach (m in method_list)
        if (m.type_context is this) m.print_prototype( writer )
      endForEach

    method determine_cpp_method_typedefs( list:String[], lookup:Table<<String,Method>> )
      local buffer = StringBuilder()
      forEach (m in method_list)        determine_cpp_method_typedefs( m, buffer, list, lookup )
      forEach (m in global_method_list) determine_cpp_method_typedefs( m, buffer, list, lookup )

    method determine_cpp_method_typedefs( m:Method, buffer:StringBuilder, list:String[], lookup:Table<<String,Method>> )
      if (not m.is_macro and m.store_dynamically and m.is_used)
        buffer.clear
        if (m.return_type)
          if (m.return_type.is_reference) buffer.print( "void*" )
          else                            buffer.print( m.return_type.cpp_class_name )
        else
          buffer.print( "void" )
        endIf
        buffer.print( "(*)(" )
        local first = true
        if (not m.is_global)
          if (this.is_reference) buffer.print( "void*" )
          else                   buffer.print( cpp_class_name )
          first = false
        endIf
        forEach (i of m.parameters)
          if (first) first = false
          else       buffer.print(',')
          local param_type = m.parameters[i].type
          if (param_type.is_reference) buffer.print("void*")
          else                         buffer.print( param_type.cpp_class_name )
        endForEach
        buffer.print( ")" )
        local sig = buffer->String
        local mapping = lookup[sig]
        if (mapping)
          m.cpp_typedef = mapping.cpp_typedef
          if (not mapping.called_dynamically and m.called_dynamically)
            lookup[ sig ] = m
          endIf
        else
          m.cpp_typedef = "ROGUEM" + list.count
          lookup[sig] = m
          list.add( sig )
        endIf
      endIf

    method print_dynamic_method_table_entries( at_index:Int32, writer:CPPWriter )->Int32
      dynamic_method_table_index = at_index

      local i2 = method_list.count - 1
      while (i2 > 0)
        local m = method_list[ i2 ]
        if (not m.is_macro and m.store_dynamically and m.is_used) escapeWhile
        --i2
      endWhile

      local print_type_name = true
      forEach (i in 0..i2)
        local m = method_list[i]
        #NOTE: The writing of method names for introspection must use exactly these same conditions!
        if (not m.is_macro)
          if (m.store_dynamically and m.is_used and not m.is_abstract)
            # Note: can't cast multiple overloaded fns directly to void*, must go through fn pointer type first
            writer.print( "(void*) (" ).print( m.cpp_typedef ).print(") ").print( m.cpp_name ).print( "," )
          else
            writer.print( "0," ).print( " // " ).print(m.type_context.name).print(".").print( m.signature )
          endIf
          if (print_type_name) print_type_name = false; writer.print( " // " ).print( name )
          writer.println
          ++at_index
        endIf
      endForEach

      dynamic_method_table_count = at_index - dynamic_method_table_index

      return at_index

    method print_method_definitions( writer:CPPWriter )
      forEach (m in method_list)
        if (m.type_context is this)
          writer.mark_method_start(this, m)
          m.print_definition( writer )
          writer.mark_method_end
        endIf
      endForEach

    method print_type_configuration( writer:CPPWriter )
      if (omit_output) return
      writer.print( "  type_" ).print( cpp_name ).print( " = Rogue_types[" ).print( index )
      writer.print( "].init( " ).print( index ).print( ", \"" ).print( cpp_class_name ).print( "\", sizeof(Class" )
      writer.print( cpp_class_name ).println( ") );" )

endAugment


#------------------------------------------------------------------------------
# Method
#------------------------------------------------------------------------------
augment Method
  PROPERTIES
    cpp_name     : String
    cpp_typedef  : String

  METHODS
    method cloned->Method
      <initialize_result>
      result.cpp_name = cpp_name
      result.cpp_typedef = cpp_typedef

    method assign_cpp_name
      if (cpp_name) return
      local buffer = StringBuilder()
      buffer.print( type_context.name ).print( "__" )
      buffer.print( name )
      if (parameters.count)
        buffer.print "_"
        forEach (param in parameters)
          buffer.print "_"
          buffer.print( param.type.cpp_name )
        endForEach
      endIf
      cpp_name = "Rogue" + Program.validate_cpp_name( buffer->String )

    method incorporate( into_type:Type )->Method
      <initialize_m>
      m.cpp_name = null

    method print_prototype( writer:CPPWriter )
      if (omit_output) return
      writer.print_export( this )
      print_signature( writer )
      writer.println( ";" )

    method print_signature( writer:CPPWriter )
      writer.print( return_type ).print(" ").print( cpp_name )
      writer.print( "(" )
      local first = true
      if (not is_global)
        first = false
        writer.print( " " )
        if (type_context.is_aspect)
          writer.print( Program.type_Object )
        else
          writer.print( type_context )
          if (is_mutating) writer.print( '&' )
        endIf
        writer.print( " THIS" )
      endIf
      if (parameters.count)
        forEach (param in parameters)
          if (first) writer.print( " " ); first = false
          else       writer.print( ", " )
          if (param.parameter_needs_gc)
            writer.print_param( param ).print( " " ).print( param.parameter_cpp_name )
          else
            writer.print_param( param ).print( " " ).print( param.cpp_name )
          endIf
        endForEach
      endIf
      if (not first) writer.print( " " )
      writer.print( ")" )

    method print_definition( writer:CPPWriter )
      if (omit_output) return

      print_signature( writer )
      writer.println
      writer.println "{"

      if (is_abstract and not type_context.is_aspect and overriding_methods.count == 0)
        # Empty abstract method
        if (return_type)
          writer.print( "  return " ).print_default_value( return_type ).println( ";" )
        endIf
        writer.println "}"
        writer.println
        return
      endIf

      writer.indent += 2

      local do_sync = is_synchronized
      if ( is_global ) do_sync = false
      elseIf ( name == "init_object" ) do_sync = false
      elseIf ( name == "on_cleanup" ) do_sync = false
      if ( do_sync )
        writer.println "ROGUE_SYNC_OBJECT_ENTER"
      endIf
      forEach (param in parameters)
        if (param.parameter_needs_gc)
          writer.print("ROGUE_DEF_LOCAL_REF(").print(param.type).print(",").print(param.cpp_name).print(",").print(param.parameter_cpp_name).println(");")
        endIf
      endForEach

      if (type_context.is_aspect and not is_global)
        writer.println( "switch (THIS->type->index)" );
        writer.println "{"
        writer.indent += 2
        if (incorporating_classes)
          forEach (ic in incorporating_classes)
            if (ic.is_used)
              local m = ic.find_method(signature)
              if (m.is_used)
                writer.print("case ").print(ic.index).println(":")
                if (return_type)
                  writer.print( "  return " )
                  if (return_type is not m.return_type)
                    # Manual widening cast
                    writer.print( "(" ).print( return_type ).print( ")" )
                  endIf
                else
                  writer.print( "  " )
                endIf
                writer.print( m.cpp_name ).print( "( (" ).print( m.type_context ).print( ")THIS" )
                forEach (param in parameters)
                  writer.print( ", " ).print( param.cpp_name )
                endForEach
                writer.println( " );" )
                if (not return_type) writer.println "return;"
              endIf
            endIf
          endForEach
        endIf
        if (return_type)
          writer.println( "default:" )
          writer.print( "  return " ).print_default_value( return_type ).println( ";" )
        endIf
        writer.indent -= 2
        writer.println "}"
      else
        if (RogueC.debug_mode)
          writer.trace_token = t
          writer.print( ''RogueDebugTrace __trace( "'' )
          writer.print_literal_string( type_context.name, &omit_quotes ).print( "." )
          writer.print_literal_string( signature, &omit_quotes ).print( ''", "'' )
          writer.print( t.filename ).print( ''", '' ).print( t.line )
          writer.println( '' );'' )
        endIf
        if (statements.count > 1) writer.println "ROGUE_GC_CHECK;"
        statements.write_cpp( writer )
      endIf

      if ( do_sync )
        writer.println "ROGUE_SYNC_OBJECT_EXIT"
      endIf
      writer.indent -= 2
      writer.println "}"
      writer.println

    method store_dynamically -> Logical
      <append> # Append so that other things (plugins) can alter behavior using <insert>
      return is_dynamic or Program.using_introspection

    method is_c_compatible ( )->Logical
      # Returns true if C linkage is okay for this method
      # In theory, this should be okay for compounds that don't has_object_references...
      # except that their constructors keep them from being POD types.  They should
      # actually probably work fine *anyway*, and we could also rewrite compounds
      # to not use constructors (and use factories and aggregation initialization
      # instead).  But for now... compounds are out.
      if (return_type and return_type.is_compound) return false
      if (parameters)
        forEach (p in parameters)
          if (p.type.is_compound) return false
        endForEach
      endIf
      return true
endAugment

#------------------------------------------------------------------------------
# Property
#------------------------------------------------------------------------------
augment Property
  PROPERTIES
    cpp_name      : String

  METHODS
    method cloned->Property
      <init_result>
      result.cpp_name = cpp_name
endAugment

#------------------------------------------------------------------------------
# Local
#------------------------------------------------------------------------------
augment Local
  PROPERTIES
    _cpp_name           : String
    _parameter_cpp_name : String

  METHODS
    method cloned( clone_args=null:CloneArgs )->Local
      <init_result>
      result._cpp_name = _cpp_name
      result._parameter_cpp_name = _parameter_cpp_name

    method cpp_name->String
      if (not _cpp_name) _cpp_name = Program.validate_cpp_name( name + "_" + index );
      return _cpp_name

    method parameter_cpp_name->String
      if (not _parameter_cpp_name) _parameter_cpp_name = Program.create_unique_id
      return _parameter_cpp_name

    method parameter_needs_gc->Logical
      if (is_modified and type.is_reference)
        if (RogueC.gc_mode == GCMode.AUTO_ST) return true
        if (RogueC.gc_mode == GCMode.AUTO_MT) return true
      endIf
      return false
endAugment

#------------------------------------------------------------------------------
# Cmd
#------------------------------------------------------------------------------
augment Cmd
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      throw t.error( "[INTERNAL] $::write_cpp() is not defined." (type_name) )
endAugment

augment CmdStatementList
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical, &skip_trace_update, &return_last )
      if (count?) writer.mark_statement_start(this[0].t.filepath, this[0].t.line, this[count-1].t.line)
      forEach (statement at index in this)
        if (not skip_trace_update and statement.generates_output) writer.update_trace_info( statement.t )
        if (return_last and index == count-1) writer.print( " return " )
        statement.write_cpp( writer, true )
        if (statement.requires_semicolon) writer.println ";"
      endForEach
      if (count?) writer.mark_statement_end
endAugment

augment CmdArgs
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      throw this[0].t.error( "[INTERNAL] $::write_cpp() is not defined." (type_name) )
endAugment

augment CmdLocalDeclaration
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (local_info.type.is_reference)
        if (skip_initialization)
          writer.print("ROGUE_DEF_LOCAL_REF_NULL(").print(local_info.type).print(",").print(local_info.cpp_name).print(")")
        elseIf
          writer.print("ROGUE_DEF_LOCAL_REF(").print(local_info.type).print(",").print(local_info.cpp_name).print(",")
          if (local_info.initial_value)
            writer.print( "(" ).print_cast( local_info.initial_value.type, local_info.type )
            local_info.initial_value.write_cpp( writer )
            writer.print( ")" )
          else
            writer.print_default_value( local_info.type )
          endIf
          writer.print(")")
        endIf
      else
        writer.print( local_info.type ).print(" ").print( local_info.cpp_name )
        if (not skip_initialization)
          writer.print(" = ")
          if (local_info.initial_value)
            writer.print( "(" ).print_cast( local_info.initial_value.type, local_info.type )
            local_info.initial_value.write_cpp( writer )
            writer.print( ")" )
          else
            writer.print_default_value( local_info.type )
          endIf
        endIf
      endIf
endAugment


augment CmdReturn
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value)
        writer.print( "return (" ).print( value.type ).print( ")(" )
        value.write_cpp( writer )
        writer.print( ")" )
      else
        writer.print "return"
      endIf
endAugment


augment CmdBlock
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (expression_type)
        writer.print( "([&]()->" ).print( expression_type ).println( "{" )
        writer.indent += 2
        statements.write_cpp( writer, &return_last )
        writer.indent -= 2
        writer.println( "}())" )
      else
        writer.println( "{" )
        writer.indent += 2
        statements.write_cpp( writer )
        writer.indent -= 2
        writer.println( "}" )
        if (escape_label) writer.print( escape_label ).println( ":;" )
      endIf
endAugment


augment CmdIf
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if (ROGUE_COND(" )
      if (condition instanceOf CmdLiteralLogical and not (condition as CmdLiteralLogical).value)
        # Surround with extra parens to prevent dead code warning
        writer.print( "(" )
        condition.write_cpp( writer )
        writer.print( ")" )
      else
        condition.write_cpp( writer )
      endIf
      writer.println( "))" )
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      if (else_statements)
        if (else_statements.count == 1 and else_statements.first instanceOf CmdIf)
          # Write the else/if in the "else if" style.
          writer.print( "else " )
          else_statements.write_cpp( writer, &skip_trace_update )
        else
          # General 'else' block.
          writer.println( "else" )
          writer.println( "{" )
          writer.indent += 2
          else_statements.write_cpp( writer )
          writer.indent -= 2
          writer.println( "}" )
        endIf
      endIf

      if (escape_label) writer.print( escape_label ).println( ":;" )

endAugment


augment CmdSwitch
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "switch (" )
      expression.write_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2

      forEach (c in cases)
        forEach (condition in c.conditions)
          writer.print( "case " )
          condition.write_cpp( writer )
          writer.println( ":" )
        endForEach
        writer.println "{"
        writer.indent += 2
        c.statements.write_cpp( writer )
        if (c.statements.count == 0 or c.statements.last not instanceOf CmdReturn)
          writer.println "break;"
        endIf
        writer.indent -= 2
        writer.println "}"
      endForEach

      if (case_others)
        writer.println "default:"
        writer.println "{"
        writer.indent += 2
        case_others.statements.write_cpp( writer )
        writer.indent -= 2
        writer.println "}"
      endIf

      writer.indent -= 2
      writer.println( "}" )
endAugment


augment CmdContingent
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "{" ); writer.indent += 2
      writer.println( "{" ); writer.indent += 2

      writer.println( "{" ); writer.indent += 2
      statements.write_cpp( writer )
      writer.println( "}" ); writer.indent -= 2

      # 'satisfied_returns' and 'body_returns' are pretty kludgy ways to get rid of
      # some C++ warnings for now... need to replace with a more robust control path
      # tracing system at some point.

      if (satisfied_label)   writer.print( satisfied_label ).println( ":;" )
      if (satisfied_statements)
        writer.println( "{" ); writer.indent += 2
        satisfied_statements.write_cpp( writer )
        local satisfied_returns = (satisfied_statements.count and satisfied_statements.last instanceOf CmdReturn)
        writer.println( "}" ); writer.indent -= 2
        if (not satisfied_returns)
          escape_label_used = true
          writer.print( "goto " ).print( escape_label ).println( ";" )
        endIf
      else
        local body_returns = (statements.count and statements.last instanceOf CmdReturn)
        if (not body_returns)
          escape_label_used = true
          writer.print( "goto " ).print( escape_label ).println( ";" )
        endIf
      endIf

      writer.indent -= 2
      writer.println( "}" )

      if (unsatisfied_label)      writer.print( unsatisfied_label ).println( ":;" )
      if (unsatisfied_statements)
        writer.println( "{" ); writer.indent += 2
        unsatisfied_statements.write_cpp( writer )
        writer.println( "}" ); writer.indent -= 2
      endIf

      writer.indent -= 2
      writer.println( "}" )

      if (escape_label_used) writer.print( escape_label ).println( ":;" )
endAugment


augment CmdGenericLoop
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (control_statements)
        writer.println( "{" )
        writer.indent += 2

        if (control_statements)
          forEach (statement in control_statements)
            statement.write_cpp( writer )
            writer.println( ";" )
          endForEach
        endIf

      endIf

      if (upkeep or not condition)
        writer.print( "for (;" )
        if (condition)
          writer.print( "ROGUE_COND(" )
          condition.write_cpp( writer )
          writer.print( ")" )
        endIf
        writer.print( ";" )
        local first = true
        if (upkeep)
          forEach (statement in upkeep)
            if (first) first = false
            else       writer.print( "," )
            statement.write_cpp( writer )
          endForEach
        endIf
        writer.println( ")" )
      else
        writer.print( "while (ROGUE_COND(" )
        condition.write_cpp( writer )
        writer.println( "))" )
      endIf
      writer.println( "{" )
      writer.indent += 2
      writer.println( "ROGUE_GC_CHECK;" )
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      if (control_statements)
        writer.indent -= 2
        writer.println( "}" )
      endIf

      if (escape_label)
        writer.print( escape_label ).println( ":;" )
      endIf

endAugment


augment CmdTry
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println "ROGUE_TRY"
      #writer.println "try"
      writer.println "{"
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println "}"
      forEach (c in catches)
        c.write_cpp( writer )
      endForEach
      if (catches.count == 0)
        writer.println "} catch (...) {"
      endIf

      writer.println( "ROGUE_END_TRY" )

      if (escape_label)
        writer.print( escape_label ).println( ":;" )
      endIf
endAugment

augment CmdCatch
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      #writer.print( "catch ( " ).print( error_var.type ).print( " " ).print( error_var.cpp_name ).println( " )" )
      if (error_var)
        writer.print( "ROGUE_CATCH( " ).print( error_var.type.cpp_class_name ).print( "," ).print( error_var.cpp_name ).println( " )" )
      else
        writer.print( "ROGUE_CATCH_NO_VAR(" ).print( error_type.cpp_class_name ).println( ")" )
      endIf
      writer.println( "{" )
      writer.indent += 2
      statements.write_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )
endAugment

augment CmdThrow
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "throw " )
      expression.write_cpp( writer )
endAugment

augment CmdEscape
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "goto " + target_cmd.escape_label

endAugment


augment CmdNextIteration
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "continue"

endAugment


augment CmdNecessary
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if ( !(" )
      condition.write_cpp( writer )
      writer.print( ") ) goto " ).print( target_cmd.unsatisfied_label )
endAugment


augment CmdSufficient
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "if (ROGUE_COND(" )
      condition.write_cpp( writer )
      writer.print( ")) goto " ).print( target_cmd.satisfied_label )
endAugment

augment CmdLiteralNull
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "NULL" )
endAugment

augment CmdLiteralReal64
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value == value)
        if (value - value == 0)
          writer.print( value )
        else
          if (value > 0) writer.print( "ROGUE_R64_INFINITY" )   #  infinity
          else           writer.print( "ROGUE_R64_NEG_INFINITY" )  # -infinity
        endIf
      else
        writer.print( "ROGUE_R64_NAN" )  # NaN
      endIf
endAugment


augment CmdLiteralReal32
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value == value)
        if (value - value == 0)
          writer.print( value ).print( 'f' )
        else
          if (value > 0) writer.print( "ROGUE_R32_INFINITY" )   #  infinity
          else           writer.print( "ROGUE_R32_NEG_INFINITY" )  # -infinity
        endIf
      else
        writer.print( "ROGUE_R32_NAN" )  # NaN
      endIf
endAugment


augment CmdLiteralInt64
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( value ).print( "LL" )
endAugment

augment CmdLiteralInt32
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( value )
endAugment


augment CmdLiteralCharacter
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "(RogueCharacter)" )
      if (value >= 32 and value <= 126)
        which (value)
          case 10:   writer.print( "'\\n'" )
          case '\\': writer.print( "'\\\\'" )
          case '\'': writer.print( "'\\''" )
          others
            writer.print( "'" )
            writer.print_literal_character( value, false )
            writer.print( "'" )
        endWhich
      else
        writer.print( value->Int32 )
      endIf
endAugment

augment CmdLiteralByte
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( Int32(value) )
endAugment


augment CmdLiteralLogical
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value) writer.print "true"
      else       writer.print "false"
endAugment


augment CmdLiteralString
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (value)
        writer.print( "Rogue_literal_strings[" ).print( index ).print( "]" )
      else
        writer.print( "0" );
      endIf
endAugment

augment CmdAccess
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
println StackTrace()
      throw t.error( "[INTERNAL] $::write_cpp() is not defined (access name $)." (type_name,name) )
endAugment

augment CmdCreateObject
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print( "ROGUE_CREATE_REF(" ).print(of_type).print(",")

      #writer.print("RogueType_create_object(RogueType").print(type.cpp_name).print(",0)")
      writer.print("ROGUE_CREATE_OBJECT(").print(type.cpp_name).print(")")

      if (not is_statement) writer.print( ")" )
endAugment


augment CmdCreateCompound
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( of_type ).print( "(" )
      if (args.count)
        writer.print( " " )
        local first = true
        forEach (arg in args)
          if (first) first = false
          else       writer.print( ", " )
          arg.write_cpp( writer )
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )
endAugment


augment CmdAssign
  METHODS
endAugment

augment CmdThisContext
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print "THIS"
endAugment

augment CmdReadSingleton
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not of_type.is_singleton)
        throw t.error( "$ is not a singleton - add () to the end to create an object." (of_type.name) )
      endIf

      if (is_statement)
        # Omit the cast
        writer.print( "ROGUE_SINGLETON( " ).print( of_type.cpp_name ).print( " )" )
      else
        writer.print( "((" ).print( of_type.cpp_class_name )
        if (of_type.is_reference) writer.print( "*" )
        writer.print( ")ROGUE_SINGLETON(" ).print( of_type.cpp_name ).print( "))" )
      endIf
endAugment

augment CmdWriteSingleton
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not of_type.is_singleton)
        throw t.error( "$ is not a singleton." (of_type.name) )
      endIf
      writer.print( "ROGUE_SET_SINGLETON(RogueType" ).print( of_type.cpp_name ).print( ", " )
      if (new_value.type is not of_type) writer.print_cast( new_value.type, of_type )
      writer.print( "(" )
      new_value.write_cpp( writer )
      writer.println( "));" )
endAugment

augment CmdReadLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name )

endAugment

augment CmdWriteLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name ).print(" = ")
      writer.print( "((" ).print( local_info.type ).print( ")(" )
      new_value.write_cpp( writer )
      writer.print( "))" )
endAugment

augment CmdReadGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print_open_cast( global_info.type, global_info.type )

      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name )
      if (not is_statement) writer.print_close_cast( global_info.type, global_info.type )
endAugment


augment CmdWriteGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name ).print(" = ")

      if (global_info.type is new_value.type)
        new_value.write_cpp( writer )
      else
        writer.print( "((" ).print( global_info.type ).print( ")(" )
        new_value.write_cpp( writer )
        writer.print( "))" )
      endIf
endAugment

augment CmdReadProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print_open_cast( property_info.type, property_info.type )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name )
      if (not is_statement) writer.print_close_cast( property_info.type, property_info.type )
endAugment

augment CmdWriteProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" = ")

      if (property_info.type is new_value.type)
        new_value.write_cpp( writer )
      else
        writer.print( "((" ).print( property_info.type ).print( ")(" )
        new_value.write_cpp( writer )
        writer.print( "))" )
      endIf
endAugment

augment CmdCallRoutine
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )

      writer.print( method_info.cpp_name )
      writer.print( "(" )
      if (args.count)
        writer.print( " " )
        local i = 0
        forEach (arg in args)
          if (i > 0) writer.print( ", " )
          writer.print_arg( arg, method_info.parameters[i] )
          ++i
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallAspectMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context, &cast_to=Program.type_Object, &is_mutating=method_info.is_mutating )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i] )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallDynamicMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement)
        writer.print("(")
        if (method_info.return_type.is_reference)
          writer.print( "(" ).print( method_info.return_type ).print( ")" )
        else
          writer.print_cast( method_info.return_type, method_info.return_type )
        endIf
      endIf
      if (method_info.is_overridden)
        writer.print( "Rogue_call_" ).print( method_info.cpp_typedef )
        writer.print( "( " )
        writer.print( method_info.index ).print( ", " )
        writer.print_arg( context, &cast_to = method_info.type_context, &is_mutating=method_info.is_mutating )
        local i = 0
        forEach (arg in args)
          writer.print( ", " )
          writer.print_arg( arg, method_info.parameters[i] )
          ++i
        endForEach
        writer.print( " )" )

      else
        CmdCallStaticMethod( t, context, method_info, args ).write_cpp( writer, is_statement )
      endIf
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallStaticMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context, &cast_to = method_info.type_context, &is_mutating=method_info.is_mutating )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i] )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment


augment CmdCallNativeRoutine
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      local i = 0
      forEach (arg in args)
        if (i > 0) writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i] )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallNativeMethod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (not is_statement) writer.print("(").print_cast( method_info.return_type, method_info.return_type )
      writer.print( method_info.cpp_name )
      writer.print( "( " )
      writer.print_arg( context, &is_mutating=method_info.is_mutating )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        writer.print_arg( arg, method_info.parameters[i] )
        ++i
      endForEach
      writer.print( " )" )
      if (not is_statement) writer.print( ")" )  # end of return type cast
endAugment

augment CmdCallInlineNative
  METHODS
    method print_this( writer:CPPWriter )
      throw t.error( "Illegal use of '$this' in global method." )

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      which (adjust_delta)
        case -1: writer.print( "--" )
        case  1: writer.print( "++" )
      endWhich

      local st = method_info.native_code

      local dollar = st.locate('$')
      while (dollar)
        writer.print( st.from(0,dollar.value-1) )
        st = st.from( dollar.value+1 )

        local is_handled = false
        local name  : String
        local param : Local
        if (st.begins_with('('))
          # $(name)
          name = st.before_first(')').from(1)
          st = st.after_first( ')' )

          if (name == "this")
            is_handled = true
            print_this( writer )
          else
            forEach (p in method_info.parameters)
              if (p.name == name)
                param = p
                escapeForEach
              endIf
            endForEach
          endIf

        else
          # $name
          local best_match : Local
          forEach (p in method_info.parameters)
            if (st.begins_with(p.name))
              if (best_match is null or p.name.count > best_match.name.count) best_match = p
            endIf
          endForEach

          if (best_match)
            param = best_match
            name = param.name
            st = st.from( best_match.name.count )
          elseIf (st.begins_with("this"))
            is_handled = true
            print_this( writer )
            st = st.from( 4 )
          endIf
        endIf

        if (not is_handled)
          if (param)
            args[ param.index ].write_cpp( writer )
          elseIf (name)
            writer.print_native_marker( t, method_info.type_context, method_info, null, name )
          else
            local i2 = 1
            while (i2 < st.count and st[i2].is_identifier) ++i2
            name = st.from( 0, i2-1 )
            st = st.from( i2 )
            writer.print_native_marker( t, method_info.type_context, method_info, null, name )
          endIf
        endIf

        dollar = st.locate('$')
      endWhile

      writer.print( st )
endAugment


augment CmdCallInlineNativeMethod
  METHODS
    method print_this( writer:CPPWriter )
      context.write_cpp( writer )
endAugment


augment CmdUnary
  METHODS
    method cpp_prefix_symbol->String
      return prefix_symbol

    method cpp_suffix_symbol->String
      return suffix_symbol

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( cpp_prefix_symbol ).print( "(" )
      operand.write_cpp( writer )
      writer.print( ")" ).print( cpp_suffix_symbol )
endAugment

augment CmdLogicalize
  METHODS
    method cpp_prefix_symbol->String
      return "!!"

    method cpp_suffix_symbol->String
      return ""
endAugment

augment CmdLogicalNot
  METHODS
    method cpp_prefix_symbol->String
      return "!"
endAugment


augment CmdBinary
  METHODS
    method cpp_symbol->String
      return symbol

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (requires_parens) writer.print( "((" )
      left.write_cpp( writer )
      if (requires_parens) writer.print( ")" )
      writer.print( " " ).print( cpp_symbol ).print( " " )
      if (requires_parens) writer.print( "(" )
      right.write_cpp( writer )
      if (requires_parens) writer.print( "))" )
endAugment

#{
augment CmdMod
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local cast = "(RogueInt32)"
      if (this_type is Program.type_Real64)     cast = "(RogueReal64)"
      elseIf (this_type is Program.type_Int64) cast = "(RogueInt64)"
      writer.print( Program.program_name ).print( ".mod( " ).print( cast )
      left.write_cpp( writer )
      writer.print( ", " ).print( cast )
      right.write_cpp( writer )
      writer.print( " )" )
endAugment
}#


augment CmdPower
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( left.type ).print( ") pow((double)")
      left.write_cpp( writer )
      writer.print( ", (double)" )
      right.write_cpp( writer )
      writer.print( "))" )
endAugment


augment CmdLogicalAnd
  METHODS
    method cpp_symbol->String
      return "&&"
endAugment


augment CmdLogicalOr
  METHODS
    method cpp_symbol->String
      return "||"
endAugment


augment CmdLogicalXor
  METHODS
    method cpp_symbol->String
      return "^"
endAugment

augment CmdCompareIs
  METHODS
    method cpp_symbol->String
      return "=="

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((void*)" )
      left.write_cpp( writer )
      writer.print( ") == ((void*)" )
      right.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdCompareIsNot
  METHODS
    method cpp_symbol->String
      return "!="

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((void*)" )
      left.write_cpp( writer )
      writer.print( ") != ((void*)" )
      right.write_cpp( writer )
      writer.print( ")" )
endAugment

augment CmdBitwiseXor
  METHODS
    method cpp_symbol->String
      return "^"
endAugment

augment CmdBitwiseShiftLeft
  METHODS
    method cpp_symbol->String
      return "<<"
endAugment

#{
augment CmdBitwiseShiftRight
  PROPERTIES

  METHODS
    method cpp_symbol->String
      return ">>>"

    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "Rogue_program.shift_right( " )
      left.write_cpp( writer )
      writer.print( ", " )
      right.write_cpp( writer )
      writer.print( " )" )
endAugment
}#

augment CmdBitwiseShiftRightX
  METHODS
    method cpp_symbol->String
      return ">>"
endAugment


augment CmdBitwiseNot
  METHODS
    method cpp_prefix_symbol->String
      return "~"
endAugment

augment CmdAdjustLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )
      writer.print( local_info.cpp_name )
endAugment


augment CmdAdjustProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name )
endAugment


augment CmdAdjustGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (delta > 0) writer.print( "++" )
      else           writer.print( "--" )

      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )
      writer.print( global_info.cpp_name )
endAugment


augment CmdResolvedModifyAndAssign
  METHODS
    method cpp_symbol->String
      return symbol
endAugment

augment CmdModifyAndAssignLocal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( local_info.cpp_name ).print( " " ).print( cpp_symbol ).print( " " )
      new_value.write_cpp( writer )
endAugment


augment CmdModifyAndAssignGlobal
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      #writer.print_type_name( global_info.type_context ).print( "::" )
      writer.print( "Rogue" ).print( global_info.type_context.cpp_name ).print( "_" )

      writer.print( global_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.write_cpp( writer )
endAugment

augment CmdModifyAndAssignProperty
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      context.write_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.write_cpp( writer )
endAugment

augment CmdCreateArray
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "RogueType_create_array( " )
      count_cmd.write_cpp( writer )
      writer.print( ", sizeof(" ).print( array_type.element_type ).print( ")" )
      if (array_type.element_type.is_reference) writer.print( ", true" ) else writer.print(", false" )
      writer.print( ", " ).print( array_type.element_type.index )
      writer.print( " )" )
endAugment

augment CmdReadArrayElement
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local element_type = array_type.element_type
      if (not is_statement) writer.print_open_cast( element_type, element_type )
      if (element_type.is_reference)
        writer.print( "((" )
        writer.print( element_type )
        writer.print( ")(" )
        context.write_cpp( writer )
        writer.print( "->as_objects[" )
        index.write_cpp( writer )
        writer.print( "]))" )

      elseIf (element_type.is_primitive)
        context.write_cpp( writer )
        writer.print( "->" )
        which (element_type)
          case Program.type_Real64:      writer.print( "as_real64s[" )
          case Program.type_Real32:     writer.print( "as_real32s[" )
          case Program.type_Int64:      writer.print( "as_int64s[" )
          case Program.type_Int32:   writer.print( "as_int32s[" )
          case Program.type_Character: writer.print( "as_characters[" )
          case Program.type_Byte:      writer.print( "as_bytes[" )
          case Program.type_Logical:   writer.print( "as_logicals[" )
          others
            throw t.error( "[INTERNAL] Unhandled type in CmdReadArrayElement." )
        endWhich
        index.write_cpp( writer )
        writer.print( "]" )

      else
        # Compound
        writer.print( "((" ).print( element_type ).print( "*)(" )
        context.write_cpp( writer )
        writer.print( "->as_bytes))[" )
        index.write_cpp( writer )
        writer.print( "]" )

      endIf
      if (not is_statement) writer.print_close_cast( element_type, element_type )
endAugment

augment CmdWriteArrayElement
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local element_type = array_type.element_type
      if (element_type.is_primitive)
        context.write_cpp( writer )
        writer.print( "->" )
        which (element_type)
          case Program.type_Real64:      writer.print( "as_real64s[" )
          case Program.type_Real32:     writer.print( "as_real32s[" )
          case Program.type_Int64:      writer.print( "as_int64s[" )
          case Program.type_Int32:   writer.print( "as_int32s[" )
          case Program.type_Character: writer.print( "as_characters[" )
          case Program.type_Byte:      writer.print( "as_bytes[" )
          case Program.type_Logical:   writer.print( "as_logicals[" )
        endWhich
        index.write_cpp( writer )
        writer.print( "] = " )
        if (new_value.type is not element_type) writer.print_cast( new_value.type, element_type )
        writer.print( "(" )
        new_value.write_cpp( writer )
        writer.print( ")" )

      elseIf (element_type.is_reference)
        context.write_cpp( writer )
        writer.print( "->" )
        writer.print( "as_objects[" )
        index.write_cpp( writer )
        writer.print( "] = " )
        new_value.write_cpp( writer )

      else
        writer.print( "((" ).print( element_type ).print( "*)(" )
        context.write_cpp( writer )
        writer.print( "->as_bytes))[" )
        index.write_cpp( writer )
        writer.print( "] = " )
        new_value.write_cpp( writer )

      endIf
endAugment

augment CmdCastToType
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (is_statement)
        # Skip the cast if this is a statement-level expression and the result
        # will be unused.
        operand.write_cpp( writer, true )
      else
        writer.print( "((" ).print( target_type ).print( ")(" )
        operand.write_cpp( writer )
        writer.print( "))" )
      endIf
endAugment

augment CmdConvertToPrimitiveType
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( target_type.cpp_class_name ).print( ")(" )
      operand.write_cpp( writer )
      writer.print( "))" )
endAugment

augment CmdAs
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( target_type ).print( ")(RogueObject_as(" )
      operand.write_cpp( writer )
      writer.print( "," )
      writer.print_type_info( target_type )
      writer.print( ")))" )
endAugment

augment CmdInstanceOf
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "RogueObject_instance_of(" )
      operand.write_cpp( writer )
      writer.print( "," )
      writer.print_type_info( target_type )
      writer.print( ")" )
endAugment


augment CmdTaskControl
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "switch (++THIS->ip)" )
      writer.println( "{" )
      writer.indent += 2
      forEach (section in sections)
        writer.print( "case " ).print( section.ip ).println( ":" )
        section.statements.write_cpp( writer )
      endForEach
      writer.println( "default:" )
      writer.println( "  THIS->ip = -1;" )
      writer.println( "  THIS->has_result = true;" )   # finished
      writer.println( "  return false;" )
      writer.indent -= 2
      writer.println( "}" )
endAugment


augment CmdCreateOptionalValue
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (of_type.element_type.is_reference)
        # Reference types don't need an intermediate type to signify null
        if (value)
          value.write_cpp( writer )
        else
          writer.print "NULL"
        endIf
      else
        # Non-reference types are kept in Optional<<DataType>> wrappers
        writer.print( of_type )
        if (value)
          writer.print( "( " )
          value.write_cpp( writer )
          writer.print( " )" )
        else
          writer.print( "()" )
        endIf
      endIf

endAugment


augment CmdLabel
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      statements.write_cpp( writer, is_statement )
endAugment

augment CmdInlineNative
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      which (adjust_delta)
        case -1: writer.print( "--" )
        case  1: writer.print( "++" )
      endWhich

      local print_cast = (result_type and not new_value and not adjust_delta)

      if (print_cast) writer.print( "((" ).print( result_type ).print( ")(" )

      writer.print_native_code( t, this_method.type_context, this_method, local_list, code, result_type )

      if (print_cast) writer.print( "))" )

      if (adjust_delta) writer.println( ";" ); return

      if (code.contains('\n') or not result_type) writer.println

      if (new_value)
        if (modify_op) writer.print(' ').print( modify_op->String ).print(' ')
        else           writer.print( " = " )
        new_value.write_cpp( writer )
        writer.println( ";" )
      endIf
endAugment

augment CmdMakeRequisite
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdNoAction
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdSelect
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      write_cpp( cases.reader, writer, &first_case )

    method write_cpp( reader:ListReader<<CmdSelectCase>>, writer:CPPWriter, &first_case )
      local select_case = reader.read

      if (not reader.has_another)
        # Final value
        if (value_type.is_reference) writer.print("ROGUE_ARG(")
        select_case.value.write_cpp( writer )
        if (value_type.is_reference) writer.print(")")
        return
      endIf

      writer.print( "((" )

      local first_condition = true
      forEach (c in select_case.conditions)
        if (first_condition) first_condition = false
        else                 writer.print " || "

        writer.print "("
        if (expression)
          if (first_case)
            # Need to store expression in local
            writer.print( "(" ).print( local_info.cpp_name ).print( "=" )
            expression.write_cpp( writer )
            writer.print( ")" )
            first_case = false
          else
            writer.print( local_info.cpp_name )
          endIf
          writer.print( "==" )
        endIf

        writer.print( "(" )
        c.write_cpp( writer )
        writer.print( "))" )
      endForEach

      writer.print( ") ? (" )

      if (value_type.is_reference) writer.print("ROGUE_ARG(")
      select_case.value.write_cpp( writer )
      if (value_type.is_reference) writer.print(")")

      writer.print( ") : " )

      write_cpp( reader, writer )

      writer.print ")"
endAugment


augment CmdAssert
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( local_info.cpp_name ).print( "=" )
      writer.print "("
      condition.write_cpp( writer )
      writer.print( "))?" ).print( local_info.cpp_name ).print( ":" )
      error.write_cpp( writer )
      writer.print( ")" )
endAugment


augment CmdRequire
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.print( "((" ).print( local_info.cpp_name ).print( "=" )
      writer.print "("
      condition.write_cpp( writer )
      writer.print( "))?" ).print( local_info.cpp_name ).print( ":" )
      error.write_cpp( writer )
      writer.print( ")" )
endAugment


augment CmdMacroGenerated
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment


augment CmdSyncObjectInit
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "ROGUE_SYNC_OBJECT_INIT" )
endAugment


augment CmdSyncObjectCleanup
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      writer.println( "ROGUE_SYNC_OBJECT_CLEANUP" )
endAugment

augment CmdNativeCode
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdNativeHeader
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      noAction
endAugment

augment CmdInsertionPoint
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      if (content) content.write_cpp( writer, is_statement )
endAugment

#{
augment IntrospectionCallManager
  PROPERTIES
    roguem_to_handler = StringTable<<IntrospectionCallHandler>>()

  METHODS
    method index_handlers
      forEach (handler in handlers)
        local roguem = handler.methods.first.cpp_typedef
        roguem_to_handler[ roguem ] = handler
      endForEach
endAugment
}#

augment CmdIntrospectionCall
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local typedef = handler.methods.first.cpp_typedef
      writer.print( '(' )
      if (handler.return_type and handler.return_type.is_reference)
        writer.print( '(' ).print( handler.return_type ).print( ')' )
      endIf
      writer.print( "((" ).print( typedef ).print( ")(intptr_t)fn_0)(" )
      local first = true
      forEach (arg in args)
        if (first) first = false
        else       writer.print( ',' )
        writer.print_arg( arg )
      endForEach
      writer.print( "))" )
endAugment

augment CmdSourceComment
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      local c = comment
      local newline = false
      if (c.ends_with("\n"))
        c = c.before(c.count - 1)
        newline = true
      endIf
      writer.print "/* " + comment + " */"
      if (newline)
        writer.println
      endIf
endAugment

augment CmdThisType
  METHODS
    method write_cpp( writer:CPPWriter, is_statement=false:Logical )
      require cmd_new
      cmd_new.write_cpp( writer, &=is_statement )
endAugment
