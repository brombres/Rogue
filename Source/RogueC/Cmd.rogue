# Generated and updated by Froley. Custom changes will not be overwritten; customize as desired.
module RogueC

class Cmd( t:Token )
  GLOBAL METHODS
    method to_character( st:String )->Character
      if (st is null or st.count == 0) return Character(0)
      return st[0]

  METHODS
    method init( existing:Cmd )
      t = existing.t

    method cloned->ThisType [propagated]
      return ThisType(this)

    method add( cmd:Cmd )
      throw UnsupportedOperationError()

    method add_debug_line_number->Logical
      return true

    method catches_escape( cmd:Cmd )->Logical
      return catches_escape( cmd.control_type )

    method catches_escape( escape_type:ControlType )->Logical
      return false

    method catches_exception( of_type:Type )->Logical
      return false

    method clear
      throw UnsupportedOperationError()

    method control_type->ControlType
      return ControlType.UNDEFINED

    method count->Int32
      return 0

    method description->String
      return "Cmd"

    method dispatch<<$m,$VisitorType>>( visitor:$VisitorType ) [propagated]
      visitor.$m( this )

    method dispatch<<$m,$VisitorType,$ReturnType>>( visitor:$VisitorType )->$ReturnType [propagated]
      return visitor.$m( this )

    method first->Cmd
      throw UnsupportedOperationError()

    method get( index:Int32 )->Cmd
      throw UnsupportedOperationError()

    method get<<$AsType>>( index:Int32 )->$AsType
      return get(index)->(as $AsType)

    method insert( element:Cmd, before_index=0:Int32 )
      throw UnsupportedOperationError()

    method last->Cmd
      throw UnsupportedOperationError()

    method remove_first->Cmd
      throw UnsupportedOperationError()

    method remove_last->Cmd
      throw UnsupportedOperationError()

    method set( index:Int32, value:Cmd )
      throw UnsupportedOperationError()

    method to->Character
      return Character(this->Int32)

    method to->Int32
      return this->Int->Int32

    method to->Int
      return 0

    method to->Int64
      return this->Int->Int64

    method to->Logical
      return (this->Int)?

    method to->Real
      return this->Int

    method to->Real64
      return this->Int

    method to->String
      return description
endClass

class CmdList : Cmd
  PROPERTIES
    list = Cmd[]

  METHODS
    method init( t )
      noAction

    method init( element:Cmd )
      init( element.t, element )

    method init( t, element:Cmd )
      list.add( element )

    method init( element1:Cmd, element2:Cmd )
      init( element1.t, element1, element2 )

    method init( t, element1:Cmd, element2:Cmd )
      list.add( element1 )
      list.add( element2 )

    method init( t, element1:Cmd, element2:Cmd, element3:Cmd )
      list.add( element1 )
      list.add( element2 )
      list.add( element3 )

    method init( existing:CmdList )
      prior.init( existing )

      # Start with shallow clone
      list = existing.list.cloned

      # Turn into deep clone
      localize list
      forEach (cmd at i in list)
        if (cmd) list[i] = cmd.cloned
      endForEach

    method add( cmd:Cmd )
      @list.add( cmd )

    method clear
      @list.clear

    method count->Int32
      return @list.count

    method description->String
      return "CmdList" + list_description

    method first->Cmd
      return @list.first

    method get( index:Int32 )->Cmd
      return @list[index]

    method insert( element:Cmd, before_index=0:Int32 )
      list.insert( element, before_index )

    method last->Cmd
      return @list.last

    method list_description->String
      local builder = String()
      builder.print '['
      forEach (element at index in @list)
        if (index > 0) builder.print ','
        builder.print( %element )
      endForEach
      builder.print ']'
      return builder

    method remove_first->Cmd
      return @list.remove_first

    method remove_last->Cmd
      return @list.remove_last

    method set( index:Int32, value:Cmd )
      @list[index] = value
endClass

class TokenList : Cmd
  PROPERTIES
    tokens : Token[]

  METHODS
    method init( t )
      tokens = Token[]

    method init( t, tokens )

    method init( existing:TokenList )
      prior.init( existing )
      tokens = existing.tokens.cloned

    method add( token:Token )
      tokens.add( token )

    method clear
      tokens.clear

    method description->String
      return "TokenList($)"(tokens)

    method to->Token[]
      return tokens

    method to->String
      local result = String()
      result.print( (forEach in tokens).to_source_string )
      return result
endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method init( existing:Unary )
      prior.init( existing )
      operand = existing.operand.cloned

    method description->String
      return "Unary($)"(%operand)
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method init( existing:Binary )
      prior.init( existing )
      left = existing.left.cloned
      right = existing.right.cloned

    method description->String
      return "Binary($,$)"(%left,%right)
endClass

class Args : CmdList
  METHODS
    method description->String
      return "Args" + list_description
endClass

class Statements : CmdList
  METHODS
    method description->String
      return "Statements" + list_description
endClass


class Print : Cmd
  PROPERTIES
    args : Cmd

  METHODS
    method init( t, args )

    method init( existing:Print )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned

    method description->String
      return "Print($)" (%args)

endClass

class Println : Cmd
  PROPERTIES
    args : Cmd

  METHODS
    method init( t, args )

    method init( existing:Println )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned

    method description->String
      return "Println($)" (%args)

endClass

class Add : Binary
  METHODS
    method description->String
      return "Add($,$)" (%left,%right)

endClass

class BitwiseAnd : Binary
  METHODS
    method description->String
      return "BitwiseAnd($,$)" (%left,%right)

endClass

class BitwiseOr : Binary
  METHODS
    method description->String
      return "BitwiseOr($,$)" (%left,%right)

endClass

class BitwiseXor : Binary
  METHODS
    method description->String
      return "BitwiseXor($,$)" (%left,%right)

endClass

class Compare : Binary
  METHODS
    method description->String
      return "Compare($,$)" (%left,%right)

endClass

class CompareEQ : Compare
  METHODS
    method description->String
      return "CompareEQ($,$)" (%left,%right)

endClass

class CompareGE : Compare
  METHODS
    method description->String
      return "CompareGE($,$)" (%left,%right)

endClass

class CompareGT : Compare
  METHODS
    method description->String
      return "CompareGT($,$)" (%left,%right)

endClass

class CompareLE : Compare
  METHODS
    method description->String
      return "CompareLE($,$)" (%left,%right)

endClass

class CompareLT : Compare
  METHODS
    method description->String
      return "CompareLT($,$)" (%left,%right)

endClass

class CompareNE : Compare
  METHODS
    method description->String
      return "CompareNE($,$)" (%left,%right)

endClass

class ContextAccess : Cmd
  PROPERTIES
    context : Cmd
    name    : String
    args    : Cmd

  METHODS
    method init( t, context, name, args=null )

    method init( existing:ContextAccess )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      name = existing.name
      if (existing.args) args = existing.args.cloned

    method description->String
      return "ContextAccess($,$,$)" (%context,%name,%args)

endClass

class Divide : Binary
  METHODS
    method description->String
      return "Divide($,$)" (%left,%right)

endClass

class Identifier : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:Identifier )
      prior.init( existing )
      name = existing.name

    method description->String
      return "Identifier($)" (%name)

    method to->Character
      return Cmd.to_character(name)

    method to->Int:  return name->Int
    method to->Logical: return name?
    method to->String: return name

endClass

class IndexedAccess : Cmd
  PROPERTIES
    context : Cmd
    index   : Cmd

  METHODS
    method init( t, context, index )

    method init( existing:IndexedAccess )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.index) index = existing.index.cloned

    method description->String
      return "IndexedAccess($,$)" (%context,%index)

endClass

class BitShiftLeft : Binary
  METHODS
    method description->String
      return "BitShiftLeft($,$)" (%left,%right)

endClass

class Literal : Cmd
  METHODS
    method description->String
      return "Literal"
endClass

class LiteralPrimitive : Literal
  METHODS
    method description->String
      return "LiteralPrimitive"
endClass

class LiteralCharacter : LiteralPrimitive
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method init( existing:LiteralCharacter )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralCharacter($)" (%value)

    method to->Character: return value
    method to->Int:       return value
    method to->String:    return value

endClass

class LiteralInteger : LiteralPrimitive
  GLOBAL METHODS
    method create( t:Token, content:String, base:Int32 )->LiteralInteger
      if ("lLI".contains(content[content.count-1]))
        return LiteralInt64( t, content.unright(1)->Int64(&=base) )
      elseIf (content.ends_with('i'))
        return LiteralInt32( t, content.unright(1)->Int32(&=base) )
      elseIf (Program.int_bits == 64)
        return LiteralInt( t, content->Int64(&=base) )
      endIf

      contingent
        if (base == 10)
          sufficient (content.count > 10)
          local n64 = content->Int64(&=base)
          sufficient (n64 != n64->Int32->Int64)
          return LiteralInt( t, n64->Int32 )
        endIf

        sufficient (base == 2 and content.count > 32)
        if (base == 8)
          sufficient (content.count > 11 or (content.count == 11 and content[0] > '3'))
        endIf
        sufficient (base == 16 and content.count > 8)

        return LiteralInt( t, content->Int32(&=base) )

      satisfied
        return LiteralInt64( t, content->Int64(&=base) )

      endContingent

  METHODS
    method init( existing:LiteralInteger )
      prior.init( existing )

    method description->String
      return "LiteralInteger()"

    method to->Int64
      throw UnsupportedOperationError()

endClass

class LiteralInt32 : LiteralInteger
  PROPERTIES
    value   : Int32

  METHODS
    method init( t, value )

    method init( existing:LiteralInt32 )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralInt32($)" (%value)

    method to->Character: return value
    method to->Int:       return value
    method to->String:    return value

endClass

class LiteralInt64 : LiteralInteger
  PROPERTIES
    value   : Int64

  METHODS
    method init( t, value )

    method init( existing:LiteralInt64 )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralInt64($)" (%value)

    method to->Character: return value
    method to->Int:       return value
    method to->Int64:     return value
    method to->String:    return value
endClass

class LiteralReal : LiteralRealNumber
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method init( existing:LiteralReal )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralReal($)" (%value)

    method to->Int:    return value
    method to->Real64: return value
    method to->String: return value

endClass

class LiteralString : Literal
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method init( existing:LiteralString )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralString($)" (%value)

    method to->Character
      return Cmd.to_character(value)

    method to->Int:    return value
    method to->Logical: return value?
    method to->String: return value

endClass

class LogicalAnd : Binary
  METHODS
    method description->String
      return "LogicalAnd($,$)" (%left,%right)

endClass

class LogicalNot : Unary
  METHODS
    method description->String
      return "LogicalNot($)" (%operand)

endClass

class LogicalOr : Binary
  METHODS
    method description->String
      return "LogicalOr($,$)" (%left,%right)

endClass

class LogicalXor : Binary
  METHODS
    method description->String
      return "LogicalXor($,$)" (%left,%right)

endClass

class Mod : Binary
  METHODS
    method description->String
      return "Mod($,$)" (%left,%right)

endClass

class Multiply : Binary
  METHODS
    method description->String
      return "Multiply($,$)" (%left,%right)

endClass

class Negate : Unary
  METHODS
    method description->String
      return "Negate($)" (%operand)

endClass

class BitShiftRight : Binary
  METHODS
    method description->String
      return "BitShiftRight($,$)" (%left,%right)

endClass

class BitShiftRightX : Binary
  METHODS
    method description->String
      return "BitShiftRightX($,$)" (%left,%right)

endClass

class Subtract : Binary
  METHODS
    method description->String
      return "Subtract($,$)" (%left,%right)

endClass

class Join : Cmd
  PROPERTIES
    a : String
    b : String

  METHODS
    method init( t, a, b )

    method init( existing:Join )
      prior.init( existing )
      a = existing.a
      b = existing.b

    method description->String
      return "Join($,$)" (%a,%b)

endClass

class Local : Cmd
  PROPERTIES
    name          : String
    original_name : String   # for auto-store parameters
    initial_value_tokens : TokenList
    initial_value : Cmd
    type          : Type
    attributes    : Attributes
    index         : Int

  METHODS
    method init( t, name, type )
      original_name = name
      ensure<<attributes>>(t)
      attributes.is_anchored = true  # always true

    method init( t, name, initial_value, type, attribute=null:String )
      original_name = name
      ensure<<attributes>>(t)
      if (attribute)
        which (attribute)
          case "default"
            attributes.is_default_parameter = true
          case "direct-auto-store"
            attributes.is_direct_auto_store = true
        endWhich
      endIf
      attributes.is_anchored = true  # always true

    method init( t:Token, name:String, initial_value:Cmd, initial_value_tokens, type:Type, attribute=null:String )
      init( t, name, initial_value, type, attribute )

    method init( existing:Local )
      prior.init( existing )
      name = existing.name
      index = existing.index
      original_name = existing.original_name
      if (existing.initial_value_tokens) initial_value_tokens = existing.initial_value_tokens.cloned
      if (existing.initial_value) initial_value = existing.initial_value.cloned
      if (existing.type) type = existing.type.cloned
      attributes = existing.attributes.cloned

    method description->String
      return "Local($,$)" (%name,%type)
      #return "Local($,$,$)" (%name,%initial_value,%type)

endClass

class LocalDeclarations : Cmd
  PROPERTIES
    declarations : Cmd
    type         : Type

  METHODS
    method init( t, declarations, type )

    method init( existing:LocalDeclarations )
      prior.init( existing )
      if (existing.declarations) declarations = existing.declarations.cloned
      if (existing.type) type = existing.type.cloned

    method description->String
      return "LocalDeclarations($,$)" (%declarations,%type)

endClass

class Access : Cmd
  PROPERTIES
    name : String
    args : Cmd

  METHODS
    method init( t, name, args=null )

    method init( existing:Access )
      prior.init( existing )
      name = existing.name
      if (existing.args) args = existing.args.cloned

    method description->String
      return "Access($,$)" (%name,%args)

endClass

class Assign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method init( existing:Assign )
      prior.init( existing )
      if (existing.target) target = existing.target.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "Assign($,$)" (%target,%new_value)

endClass

class SetLocal : Cmd
  PROPERTIES
    info                  : Local
    new_value             : Cmd
    is_initial_assignment : Logical

  METHODS
    method init( info:Local, new_value:Cmd, &initial_assignment )
      init( info.t, info, new_value, &=initial_assignment )

    method init( t, info, new_value, &initial_assignment )
      is_initial_assignment = initial_assignment
      if (not initial_assignment) info.attributes.is_anchored = false

    method init( existing:SetLocal )
      prior.init( existing )
      info = existing.info
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "SetLocal($,$)" (%info,%new_value)

endClass

class GetLocal : Cmd
  PROPERTIES
    info : Local

  METHODS
    method init( info )
      t = info.t

    method init( t, info )

    method init( existing:GetLocal )
      prior.init( existing )
      if (existing.info) info = existing.info

    method description->String
      return "GetLocal($)" (%info)

endClass

class Class : Cmd
  PROPERTIES
    constructor_properties : Parameters
    base_types             : TypeList
    attributes             : Attributes
    sections               : Cmd
    doc                    : String

  METHODS
    method init( t, constructor_properties, base_types, attributes, doc, sections )

    method init( existing:Class )
      prior.init( existing )
      if (existing.constructor_properties) constructor_properties = existing.constructor_properties.cloned
      if (existing.base_types) base_types = existing.base_types.cloned
      if (existing.attributes) attributes = existing.attributes.cloned
      if (existing.sections) sections = existing.sections.cloned
      doc = existing.doc

    method description->String
      local doc_comment = ""
      if (doc)
        if (doc.count > 20) doc_comment = ",$..."(doc.leftmost(17))
        else                doc_comment = ",$"(doc.leftmost(20))
      endIf
      return "Class($,$,$,$,$)" (%constructor_properties,%base_types,%attributes,%sections,doc_comment)

endClass

class Placeholder : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:Placeholder )
      prior.init( existing )
      name = existing.name

    method description->String
      return "Placeholder($)" (%name)

    method to->Character
      return Cmd.to_character(name)

    method to->Int:    return name
    method to->Logical: return name?
    method to->String: return name

endClass

class PropertyDeclarations : Cmd
  PROPERTIES
    declarations : Cmd
    type         : Type
    attributes   : Attributes
    doc          : String

  METHODS
    method init( t, declarations, type, attributes, doc )

    method init( existing:PropertyDeclarations )
      prior.init( existing )
      if (existing.declarations) declarations = existing.declarations.cloned
      if (existing.type) type = existing.type.cloned
      doc = existing.doc

    method description->String
      return "PropertyDeclarations($,$)" (%declarations,%type)

endClass

class Property : Cmd
  PROPERTIES
    type_context      : Type
    name              : String
    initial_value     : Cmd
    type              : Type
    attributes        : Attributes
    native_expression : String
    id = -1           : Int
    doc               : String

  METHODS
    method init( t, name, initial_value, type )
      attributes = Attributes(t)

    method init( t, name, native_expression )
      type = Program.type_NativeProperty
      attributes = Attributes(t)

    method init( existing:Property )
      prior.init( existing )
      type_context = existing.type_context
      name = existing.name
      if (existing.initial_value) initial_value = existing.initial_value.cloned
      if (existing.type) type = existing.type.cloned
      if (existing.attributes) attributes = existing.attributes.cloned
      native_expression = existing.native_expression
      doc = existing.doc

    method description->String
      if (native_expression) return "Property($,$)" (%name,%native_expression)
      else                   return "Property($,$,$)" (%name,%initial_value,%type)

    method is_native->Logical
      return native_expression?

endClass

class NativeProperty : Cmd
  PROPERTIES
    target     : String
    expression : String
    doc        : String

  METHODS
    method init( t, target, expression )

    method init( existing:NativeProperty )
      prior.init( existing )
      target     = existing.target
      expression = existing.expression
      doc = existing.doc

    method description->String
      return "NativeProperty<<$>>($)" (%target,%expression)

    method to->Character
      return Cmd.to_character(expression)

    method to->Int:    return expression
    method to->Logical: return expression?
    method to->String: return expression

endClass

class NativeCode : Cmd
  PROPERTIES
    ordinal : Int
    content : String

  METHODS
    method init( t, ordinal, content )

    method init( existing:NativeCode )
      prior.init( existing )
      ordinal = existing.ordinal
      content = existing.content

    method description->String
      local _content = %content
      if (_content.count > 20) _content = _content.leftmost(17) + "..."
      return "NativeCode($)" (_content)

    method to->Character
      return Cmd.to_character(content)

    method to->Int:    return content
    method to->Logical: return content?
    method to->String: return content

endClass

class NativeHeader : Cmd
  PROPERTIES
    ordinal : Int
    content : String

  METHODS
    method init( t, ordinal, content )

    method init( existing:NativeHeader )
      prior.init( existing )
      ordinal = existing.ordinal
      content = existing.content

    method description->String
      local _content = %content
      if (_content.count > 20) _content = _content.leftmost(17) + "..."
      return "NativeHeader($)" (_content)

    method to->Character
      return Cmd.to_character(content)

    method to->Int:    return content
    method to->Logical: return content?
    method to->String: return content

endClass

class ControlStructure : Cmd
  PROPERTIES
    locals                = Local[]  # local to the scope of the control structure
    statements            : Cmd
    control_type          : ControlType
    catches_escape        : Logical # catches control escape
    exception_passthrough : Logical # a thrown exception passes through

  METHODS
    method init( t, control_type )
      statements = Statements(t)

    method init( t, statements, control_type=ControlType.UNDEFINED )

    method init( existing:ControlStructure )
      prior.init( existing )
      if (existing.locals) locals = existing.locals.cloned
      if (existing.statements) statements = existing.statements.cloned

    method catches_escape->Logical
      return @catches_escape

    method catches_escape( escape_type:ControlType )->Logical
      if (@control_type != escape_type) return false
      catches_escape = true
      return true

    method catches_exception->Logical
      return false

    method control_type->ControlType
      return @control_type

    method description->String
      return "ControlStructure($)" (%statements)

    method requires_cleanup->Logical
      return false

endClass

class LocalScope : ControlStructure
  METHODS
    method init( t:Token )
      prior.init( t, ControlType.LOCAL_SCOPE )

    method init( t:Token, statements:Cmd )
      prior.init( t, statements, ControlType.LOCAL_SCOPE )

    method init( existing:LocalScope )
      prior.init( existing )

    method description->String
      return "LocalScope($)"(%statements)
endClass

class Conditional : ControlStructure
  PROPERTIES
    condition      : Cmd

  METHODS
    method init( t:Token, control_type:ControlType )
      prior.init( t, control_type )

    method init( t:Token, condition, statements:Cmd, control_type=ControlType.UNDEFINED:ControlType )
      prior.init( t, statements, control_type )

    method init( existing:Conditional )
      prior.init( existing )
      if (existing.condition) condition = existing.condition.cloned

    method description->String
      return "Conditional($,$)" (%condition,%statements)

endClass

class Iterator : Conditional
  PROPERTIES
    control           : Cmd
    upkeep            : Cmd
    upkeep_label      : String
    upkeep_label_used : Logical

  METHODS
    method init( t:Token, statements:Cmd, control_type:ControlType )
      init( t, Statements(t), null, statements, Statements(t), control_type )

    method init( t:Token, control, condition:Cmd, statements:Cmd, upkeep,
                 control_type=ControlType.UNDEFINED:ControlType )
     prior.init( t, condition, statements, control_type )

    method init( existing:Iterator )
      prior.init( existing )
      if (existing.control)        control = existing.control.cloned
      if (existing.upkeep)         upkeep  = existing.upkeep.cloned
      upkeep_label = existing.upkeep_label
      upkeep_label_used = existing.upkeep_label_used

    method description->String
      return "Iterator($,$,$,$)" (%control,%condition,%statements,%upkeep)

endClass

class ForEach : Cmd
  PROPERTIES
    control  : ForEachControl
    statements : Cmd

  METHODS
    method init( t, control, statements )

    method init( existing:ForEach )
      prior.init( existing )
      if (existing.control) control = existing.control.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "ForEach($,$)" (%control,%statements)

endClass

class ForEachAt : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:ForEachAt )
      prior.init( existing )
      name = existing.name

    method description->String
      return "ForEachAt($)" (%name)

    method to->Character
      return Cmd.to_character(name)

    method to->Int:    return name
    method to->Logical: return name?
    method to->String: return name

endClass

class ForEachCollection : Cmd
  PROPERTIES
    name           : String
    data           : Cmd
    starting_index : Cmd
    step_size      : Cmd

  METHODS
    method init( t, name, data, starting_index, step_size )

    method init( existing:ForEachCollection )
      prior.init( existing )
      name = existing.name
      if (existing.data) data = existing.data.cloned
      if (existing.starting_index) starting_index = existing.starting_index.cloned
      if (existing.step_size) step_size = existing.step_size.cloned

    method description->String
      return "ForEachCollection($,$,$,$)" (%name,%data,%starting_index,%step_size)

endClass

class ForEachControl : Cmd
  PROPERTIES
    name        : String
    optional_at : ForEachAt
    collection  : ForEachCollection

  METHODS
    method init( t, name, optional_at, collection )

    method init( existing:ForEachControl )
      prior.init( existing )
      name = existing.name
      if (existing.optional_at) optional_at = existing.optional_at.cloned
      if (existing.collection) collection = existing.collection.cloned

    method description->String
      return "ForEachControl($,$,$)" (%name,%optional_at,%collection)

endClass

class ForEachInControl : ForEachControl
  METHODS
    method description->String
      return "ForEachInControl($,$,$)" (%name,%optional_at,%collection)

endClass

class ForEachOfControl : ForEachControl
  METHODS
    method description->String
      return "ForEachOfControl($,$,$)" (%name,%optional_at,%collection)

endClass

class Block : ControlStructure
  PROPERTIES
    assignments : Cmd

  METHODS
    method init( t, control_type=ControlType.BLOCK )
      prior.init( t, control_type )

    method init( t, statements:Cmd, control_type=ControlType.BLOCK )
      prior.init( t, statements, control_type )

    method init( t, assignments, statements:Cmd, control_type=ControlType.BLOCK )
      prior.init( t, statements, control_type )

    method init( existing:Block )
      prior.init( existing )
      if (existing.assignments) assignments = existing.assignments.cloned

    method description->String
      return "Block($)" (%statements)

endClass

class Stepper : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:Stepper )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "Stepper($)" (%operand)

endClass

class Decrement : Stepper
  METHODS
    method description->String
      return "Decrement($)" (%operand)

endClass

class Increment : Stepper
  METHODS
    method description->String
      return "Increment($)" (%operand)

endClass

class If : Conditional
  PROPERTIES
    cmd_else : Cmd

  METHODS
    method init( t, condition, statements:Cmd, cmd_else, control_type=ControlType.IF:ControlType )
      prior.init( t, condition, statements, control_type )

    method init( existing:If )
      prior.init( existing )
      if (existing.cmd_else) cmd_else = existing.cmd_else.cloned

    method description->String
      return "If($,$,$)" (%condition,%statements,%cmd_else)

endClass

class Return : Cmd
  PROPERTIES
    result : Cmd

  METHODS
    method init( t, result )

    method init( existing:Return )
      prior.init( existing )
      if (existing.result) result = existing.result.cloned

    method description->String
      return "Return($)" (%result)

endClass

class CallProcedure : Cmd
  PROPERTIES
    info : Procedure
    args : Cmd
    result_discarded   : Logical

  METHODS
    method init( t, args )

    method init( t, info, args )

    method init( existing:CallProcedure )
      prior.init( existing )
      info = existing.info
      if (existing.args) args = existing.args.cloned

    method description->String
      return "CallProcedure($)" (%args)

endClass

class BitwiseNot : Unary
  METHODS
    method description->String
      return "BitwiseNot($)" (%operand)

endClass

class LiteralLogical : LiteralPrimitive
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method init( existing:LiteralLogical )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralLogical($)" (%value)

    method to->Int:     return which{value:1 || 0}
    method to->Logical: return value
    method to->String:  return which{value:"true" || "false"}

endClass

class LiteralPi : Literal
  METHODS
    method description->String
      return "LiteralPi"
endClass

class Convert( t, operand:Cmd ) : Cmd
  METHODS
    method init( existing:Convert )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "Convert($)" (%operand)

endClass

class ConvertToByte : Convert
  METHODS
    method description->String
      return "ConvertToByte($)" (%operand)

endClass

class ConvertToCharacter : Convert
  METHODS
    method description->String
      return "ConvertToCharacter($)" (%operand)

endClass

class ConvertToInt32 : Convert
  METHODS
    method description->String
      return "ConvertToInt32($)" (%operand)

endClass

class ConvertToInt64 : Convert
  METHODS
    method description->String
      return "ConvertToInt64($)" (%operand)

endClass

class ConvertToLogical : Convert
  METHODS
    method description->String
      return "ConvertToLogical($)" (%operand)

endClass

class ConvertToReal32 : Convert
  METHODS
    method description->String
      return "ConvertToReal32($)" (%operand)

endClass

class ConvertToReal64 : Convert
  METHODS
    method description->String
      return "ConvertToReal64($)" (%operand)

endClass

class AttributeExport : Cmd
  METHODS
    method description->String
      return "AttributeExport"
endClass

class DefineModule : Cmd
  PROPERTIES
    name       : String
    attributes : Attributes

  METHODS
    method init( t, name, attributes )

    method init( existing:DefineModule )
      prior.init( existing )
      name = existing.name
      if (existing.attributes) attributes = existing.attributes.cloned

    method description->String
      return "DefineModule($,$)" (%name,%attributes)

endClass


class ModuleQualifiedID : Cmd
  PROPERTIES
    context : Cmd
    name    : String

  METHODS
    method init( t, context, name )

    method init( existing:ModuleQualifiedID )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      name = existing.name

    method description->String
      return "ModuleQualifiedID($,$)" (%context,%name)

    method to->String
      return "$::$"(context->String,name)

endClass

class NativeExpression : Cmd
  PROPERTIES
    content     : String
    result_type : Type

  METHODS
    method init( t, content, result_type )

    method init( existing:NativeExpression )
      prior.init( existing )
      content = existing.content
      if (existing.result_type) result_type = existing.result_type.cloned

    method description->String
      return "NativeExpression($,$)" (%content,%result_type)

endClass

class NativeStatement : Cmd
  PROPERTIES
    content : String

  METHODS
    method init( t, content )

    method init( existing:NativeStatement )
      prior.init( existing )
      content = existing.content

    method add_debug_line_number->Logical
      return false

    method description->String
      return "NativeStatement($)" (%content)

    method to->Character
      return Cmd.to_character(content)

    method to->Int:    return content
    method to->Logical: return content?
    method to->String: return content

endClass

class CreateObject : Cmd
  PROPERTIES
    of_type : Type
    m_init  : Method
    args    : Cmd

  METHODS
    method init( t, of_type, m_init, args )
      # Real constructor

    method init( t, of_type, args )
      # Froley constructor

    method init( existing:CreateObject )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.args) args = existing.args.cloned
      m_init = existing.m_init

    method description->String
      return "CreateObject($,$)" (%of_type,%args)

endClass

class TypeContext : Cmd
  PROPERTIES
    type : Type

  METHODS
    method init( t, type )

    method init( existing:TypeContext )
      prior.init( existing )
      if (existing.type) type = existing.type.cloned

    method description->String
      return "TypeContext($)" (%type)

endClass

class CallGlobalMethod : CallProcedure
  METHODS
    method description->String
      return "CallGlobalMethod($,$,$)" (info->(as GlobalMethod).type_context,%info,%args)

endClass

class AddAndAssign : OpAndAssign
  METHODS
    method description->String
      return "AddAndAssign($,$)" (%target,%operand)

endClass

class OpAndAssign : Cmd
  PROPERTIES
    target  : Cmd
    operand : Cmd

  METHODS
    method init( t, target, operand )

    method init( existing:OpAndAssign )
      prior.init( existing )
      if (existing.target) target = existing.target.cloned
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "OpAndAssign($,$)" (%target,%operand)

endClass

class LiteralNull : Literal
  PROPERTIES
    of_type : Type

  METHODS
    method init( t )

    method init( t, of_type )

    method init( existing:LiteralNull )
      t = existing.t
      of_type = existing.of_type

    method description->String
      return "LiteralNull"
endClass

class GlobalMethod : Procedure
  METHODS
    method init( t:Token, type_context, name:String )
      prior.init( t, type_context.module_context, name, null, null, null, null, null )

    method init( t:Token, name:String, parameters=null:Parameters, return_type=null:Type,
        attributes=null:Attributes, doc=null:String, body=null:LocalScope )
      prior.init( t, name, parameters, return_type, attributes, doc, body )

    method init( existing:GlobalMethod )
      prior.init( existing )
      type_context = existing.@type_context
      doc = existing.doc

    method context_signature->String
      return "$.$"(type_context.scoped_name,signature)

    method is_global->Logical
      return true

    method organize( &skip_add_to_type )
      if (is_organized) return

      attributes.is_global = true
      prior.organize

      if (not skip_add_to_type) @type_context.add( this )

endClass

class Method : Procedure
  PROPERTIES
    inheriting_types = Type[]
    source_tokens    : TokenList

  METHODS
    method init( t:Token, name:String )
      init( t, null, name, null, null, null, null, null )

    method init( t:Token, name:String, parameters:Parameters, return_type:Type,
        attributes:Attributes, doc:String, source_tokens, body:LocalScope )
      init( t, null, name, parameters, return_type, attributes, doc, body )

    method init( t:Token, module_context:Module, name:String, parameters=null:Parameters, return_type=null:Type,
        attributes=null:Attributes, doc=null:String, body=null:LocalScope )
      prior.init( t, module_context, name, parameters, return_type, attributes, doc, body )

    method init( t:Token, type_context, name:String )
      prior.init( t, type_context.module_context, name, null, null, null, null, null )

    method init( existing:Method )
      prior.init( existing )
      type_context = existing.@type_context
      doc = existing.doc
      if (existing.source_tokens) source_tokens = existing.source_tokens.cloned

    method context_signature->String
      return "$.$"(@type_context.scoped_name,signature)

    method generate_body
      if (statements is null)
        local tokens = source_tokens.tokens
        contingent
          sufficient ((forEach in tokens).type == TokenType.KEYWORD_THIS_TYPE)
          escapeContingent

        satisfied
          local specialized_tokens = Token[]( tokens.count * 1.1 )
          forEach (t in tokens)
            if (t.type == TokenType.KEYWORD_THIS_TYPE)
              specialized_tokens.add( type_context.name_tokens )
            else
              specialized_tokens.add( t )
            endIf
          endForEach
          tokens = specialized_tokens
        endContingent

        temporarily Program.current_module = this.module_context
          body.statements = Parser(tokens).parse( Parser.ip_multi_line_statements )
          statements = body.statements
        endTemporarily
      endIf

    method organize( &skip_add_to_type )
      if (is_organized) return

      use organizer = ObjectPool<<MethodOrganizer>>
        temporarily organizer.this_module=module_context, organizer.this_type=@type_context
          prior.organize( &=skip_add_to_type )
        endTemporarily
      endUse

      if (not skip_add_to_type) @type_context.add( this )

    method propagated_to( type_context:Type )->Method
      temporarily body.statements=null, statements=null
        local propagated_m = this.cloned
        propagated_m.type_context = type_context
        ClearLocalInfo.visit( propagated_m )
        propagated_m.generate_body
        AspectMethodPatcher.patch( type_context, propagated_m )
        propagated_m.dynamic_signature # adds to Program.dynamic_methods{}

        if (type_context.base_class)
          propagated_m.overridden_method = type_context.base_class.methods[ propagated_m.signature ]
        endIf

        return propagated_m
      endTemporarily

endClass

class CallDynamicMethod : CallProcedure
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, args )

    method init( t, context, info, args )

    method init( existing:CallDynamicMethod )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "CallDynamicMethod($,$,$)" (%context,%info,%args)

endClass

class CallThisDynamicMethod : CallProcedure
  METHODS
    method init( t, args )

    method init( t, info, args )

    method init( existing:CallThisDynamicMethod )
      prior.init( existing )

    method description->String
      return "CallThisDynamicMethod($,$)" (info,%args)

endClass

class GetProperty : Cmd
  PROPERTIES
    context : Cmd
    info    : Property

  METHODS
    method init( t, context, info )

    method init( existing:GetProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.info) info = existing.info.cloned

    method description->String
      return "GetProperty($,$)" (%context,%info)

endClass

class GetThisProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:GetThisProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "GetThisProperty($)" (%info)

endClass

class SetProperty : Cmd
  PROPERTIES
    context   : Cmd
    info      : Property
    new_value : Cmd

  METHODS
    method init( context, info, new_value )
      t = context.t

    method init( t, context, info, new_value )

    method init( existing:SetProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.info) info = existing.info.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "SetProperty($,$,$)" (%context,%info,%new_value)

endClass

class SetThisProperty : Cmd
  PROPERTIES
    info      : Property
    new_value : Cmd

  METHODS
    method init( info, new_value )
      t = info.t

    method init( t, info, new_value )

    method init( existing:SetThisProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "SetThisProperty($,$)" (%info,%new_value)

endClass

class Is : Binary
  METHODS
    method description->String
      return "Is($,$)" (%left,%right)

endClass

class IsNot : Binary
  METHODS
    method description->String
      return "IsNot($,$)" (%left,%right)

endClass

class AttributeEssential : Cmd
  METHODS
    method description->String
      return "AttributeEssential"
endClass

class AttributeSingleton : Cmd
  METHODS
    method description->String
      return "AttributeSingleton"
endClass

class GetSingleton : Cmd
  PROPERTIES
    type : Type

  METHODS
    method init( t, type )

    method init( existing:GetSingleton )
      prior.init( existing )
      if (existing.type) type = existing.type.cloned

    method description->String
      return "GetSingleton($)" (%type)

endClass

class ConvertToType : Cmd
  PROPERTIES
    operand : Cmd
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method init( existing:ConvertToType )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.to_type) to_type = existing.to_type.cloned

    method description->String
      return "ConvertToType($,$)" (%operand,%to_type)

endClass


class CreateObjectAndSetLocal : Cmd
  PROPERTIES
    of_type : Type
    info    : Local  # local ref to store the new object

  METHODS
    method init( t, of_type, info )

    method init( existing:CreateObjectAndSetLocal )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.info)    info = existing.info.cloned

    method description->String
      return "CreateObjectAndSetLocal($,$)" (%of_type,%info)

endClass

class Definition : Cmd
  PROPERTIES
    name  : String
    value : Cmd

  METHODS
    method init( t, name, value )

    method init( existing:Definition )
      prior.init( existing )
      name = existing.name
      if (existing.value) value = existing.value.cloned

    method description->String
      return "Definition($,$)" (%name,%value)

endClass

class Throw : Cmd
  PROPERTIES
    exception : Cmd
    is_analyzed : Logical

  METHODS
    method init( t, exception )

    method init( existing:Throw )
      prior.init( existing )
      if (existing.exception) exception = existing.exception.cloned

    method description->String
      return "Throw($)" (%exception)

endClass

class Try : ControlStructure
  PROPERTIES
    catches           : Catches
    catches_exception : Logical

  METHODS
    method init( t, statements, catches )
      prior.init( t, statements, ControlType.TRY )

    method init( existing:Try )
      prior.init( existing )
      catches_exception = existing.catches_exception
      if (existing.catches) catches = existing.catches.cloned->(as Catches)

    method catches_exception->Logical
      return @catches_exception

    method catches_exception( of_type:Type )->Logical
      if (of_type.instance_of((forEach in catches).exception_type))
        catches_exception = true
        return true
      endIf
      return false

    method description->String
      return "Try($,$)" (%statements,%catches)

endClass

class Catch : ControlStructure
  PROPERTIES
    var_name       : String
    exception_type : Type
    v_catch        : Local

  METHODS
    method init( t, var_name, exception_type, statements:Cmd )
      prior.init( t, statements, ControlType.CATCH )

    method init( existing:Catch )
      prior.init( existing )
      var_name = existing.var_name
      if (existing.exception_type) exception_type = existing.exception_type.cloned

    method catches_escape( escape_type:ControlType )->Logical
      if (escape_type == ControlType.TRY)
        catches_escape = true
        return true
      else
        return false
      endIf

    method description->String
      return "Catch($,$,$)" (%var_name,%exception_type,%statements)

endClass

class Catches : CmdList
  METHODS
    method description->String
      return "Catches" + list_description

    method get( index:Int32 )->Catch
      return list[index]->(as Catch)
endClass


class DummyInitialValue : Cmd [singleton]
  METHODS
    method description->String
      return "DummyInitialValue"
endClass

class ReturnOnException : Cmd
  METHODS
    method description->String
      return "ReturnOnException"
endClass

class Power : Binary
  METHODS
    method description->String
      return "Power($,$)" (%left,%right)

endClass

class AttributePrimitive : Cmd
  METHODS
    method description->String
      return "AttributePrimitive"
endClass

class This : Cmd
  PROPERTIES
    this_type : Type

  METHODS
    method init( t )

    method init( t, this_type )

    method init( other:This )
      prior.init( other )
      this_type = other.this_type

    method description->String
      return "This($)"(this_type)
endClass

class TypeList : CmdList
  METHODS
    method description->String
      return "TypeList" + list_description

    method get( index:Int32 )->Type
      return list[index]->(as Type)
endClass

class TemplateArgs : CmdList
  METHODS
    method init( t )

    method init( t, type_arg:Type )
      add( TokenList(t,type_arg.name_tokens) )

    method init( existing:CmdList )
      prior.init( existing )

    method description->String
      return "TemplateArgs" + list_description

    method get( index:Int32 )->TokenList
      return list[index]->(as TokenList)

    method to->String
      local builder = String()
      builder.print( (forEach in this).tokens )
      return builder

    method to->String( name:String )
      local builder = String()
      builder.print name
      builder.print "<<"
      forEach (i of this)
        if (i) builder.print ','
        local type = type(i)
        if (type)
          builder.print type.scoped_name
        else
          builder.print( (forEach in this[i].tokens)->String )
        endIf
      endForEach
      builder.print ">>"
      return builder

    method type( index:Int32 )->Type
      use token_string = StringPool
        local token_list = this[index]
        if (token_list.tokens.contains($.type == RogueC::TokenType.STRING)) return null

        token_string.print((forEach in token_list.tokens)->String)
        local type_entry = Program.current_module.type_arg_lookup.find( token_string )
        if (type_entry)
          if (type_entry.value)
            # This token string has already been identified as a type
            return type_entry.value
          else
            # Already identified as NOT a type
            return null
          endIf
        else
          # Determine if this token string represents a type and, if so, create lookup table entry
          local type = Program.current_module.find_type( t, token_string, &extended_search )
          if (not type)
            try
              type = Parser( token_list.tokens ).parse( Parser.ip_type )->(as Type)
            catch (Exception)
              # not a type
            endTry
          endIf
          if (type)
            token_list = TokenList( token_list.t, type.name_tokens )
            this[index] = token_list
            token_string.clear
            token_string.print((forEach in token_list.tokens)->String)
          endIf
          Program.current_module.type_arg_lookup[token_string.cloned] = type
          return type
        endIf
      endUse
      return null
endClass

class AttributeAspect : Cmd
  METHODS
    method description->String
      return "AttributeAspect"
endClass

class Parameters : CmdList
  METHODS
    method description->String
      return "Parameters" + list_description

    method get( index:Int32 )->Local
      return list[index]->(as Local)
endClass

class CallStaticMethod : CallProcedure
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, args )

    method init( t, context, info, args )

    method init( existing:CallStaticMethod )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "CallStaticMethod($,$,$)" (%context,%info,%args)

endClass

class CallThisStaticMethod : CallProcedure
  METHODS
    method init( t, args )

    method init( t, info, args )

    method init( existing:CallThisStaticMethod )
      prior.init( existing )

    method description->String
      return "CallThisStaticMethod($,$)" (%info,%args)

endClass

class AttributeAppend : Cmd
  METHODS
    method description->String
      return "AttributeAppend"
endClass

class AttributeInsert : Cmd
  METHODS
    method description->String
      return "AttributeInsert"
endClass

class InlineWhich : Cmd
  PROPERTIES
    cases       : InlineWhichCases
    result_type : Type

  METHODS
    method init( t, cases )

    method init( t, a:Cmd, b:Cmd )
      cases = InlineWhichCases( t )
      cases.add( InlineWhichCase(a.t,a,null) )
      cases.add( InlineWhichCase(b.t,b,null) )

    method init( existing:InlineWhich )
      prior.init( existing )
      if (existing.cases) cases = existing.cases.cloned

    method description->String
      return "InlineWhich($)" (%cases)

    method type->Type
      return result_type

endClass

class InlineWhichCase : Cmd
  PROPERTIES
    condition : Cmd
    value     : Cmd

  METHODS
    method init( t, condition, value )

    method init( existing:InlineWhichCase )
      prior.init( existing )
      if (existing.condition) condition = existing.condition.cloned
      if (existing.value) value = existing.value.cloned

    method description->String
      return "InlineWhichCase($,$)" (%condition,%value)

endClass

class InlineWhichCases : CmdList
  METHODS
    method description->String
      return "InlineWhichCases" + list_description

    method get( index:Int32 )->InlineWhichCase
      return list[index]->(as InlineWhichCase)
endClass

#class DiscardResult : Cmd
#  PROPERTIES
#    operand : Cmd
#
#  METHODS
#    method init( t, operand )
#
#    method init( existing:DiscardResult )
#      prior.init( existing )
#      if (existing.operand) operand = existing.operand.cloned
#
#    method description->String
#      return "DiscardResult($)" (%operand)
#
#endClass

class AttributeCompound : Cmd
  METHODS
    method description->String
      return "AttributeCompound"
endClass

class IsType : Cmd
  PROPERTIES
    operand : Cmd
    compare_type : Type

  METHODS
    method init( t, operand, compare_type )

    method init( existing:IsType )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.compare_type) compare_type = existing.compare_type.cloned

    method description->String
      return "IsType($,$)" (%operand,%compare_type)

endClass

class InstanceOf : Cmd
  PROPERTIES
    operand      : Cmd
    compare_type : Type

  METHODS
    method init( t, operand, compare_type )

    method init( existing:InstanceOf )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.compare_type) compare_type = existing.compare_type.cloned

    method description->String
      return "InstanceOf($,$)" (%operand,%compare_type)

endClass

class IsCompound : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:IsCompound )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "IsCompound($)" (%operand)

endClass

class IsPrimitive : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:IsPrimitive )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "IsPrimitive($)" (%operand)

endClass

class IsReference : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:IsReference )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "IsReference($)" (%operand)

endClass


class AttributeReturnsThis : Cmd
  METHODS
    method description->String
      return "AttributeReturnsThis"
endClass

class ContextBlock : Cmd
  PROPERTIES
    context  : Cmd
    commands : Cmd

  METHODS
    method init( t, context, commands=null )
      if (not commands) commands = Args(t)

    method init( existing:ContextBlock )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.commands) commands = existing.commands.cloned

    method add( cmd:Cmd )
      commands.add( cmd )

    method add( cmd:String, args=null:Args )
      commands.add( ContextAccess( t, ContextBlockContext(t), cmd, args ) )

    method description->String
      return "ContextBlock($,$)" (%context,%commands)

endClass

class ContextBlockContext : Cmd
  METHODS
    method description->String
      return "ContextBlockContext"
endClass

class NamedArg : Cmd
  PROPERTIES
    name       : String
    value      : Cmd
    is_zero    : Logical   # &!param
    is_forward : Logical   # &=param

  METHODS
    method init( t, name, value, &zero, &forward )
      is_zero = zero
      is_forward = forward

    method init( existing:NamedArg )
      prior.init( existing )
      name = existing.name
      if (existing.value) value = existing.value.cloned
      is_zero = existing.is_zero
      is_forward = existing.is_forward

    method description->String
      return "NamedArg($,$)" (%name,%value)

endClass

class DefaultArg : Unary
  METHODS
    method description->String
      return "DefaultArg($)" (%operand)

endClass

class Loop : Cmd
  PROPERTIES
    loop_count : Cmd
    statements : Cmd

  METHODS
    method init( t, loop_count, statements )

    method init( existing:Loop )
      prior.init( existing )
      if (existing.loop_count) loop_count = existing.loop_count.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "Loop($,$)" (%loop_count,%statements)

endClass

class GlobalPropertyDeclarations : Cmd
  PROPERTIES
    declarations : Cmd
    type         : Type
    attributes   : Attributes
    doc          : String

  METHODS
    method init( t, declarations, type, attributes, doc )

    method init( existing:GlobalPropertyDeclarations )
      prior.init( existing )
      if (existing.declarations) declarations = existing.declarations.cloned
      if (existing.type) type = existing.type.cloned
      if (existing.attributes) attributes = existing.attributes.cloned
      doc = existing.doc

    method description->String
      return "GlobalPropertyDeclarations($,$,$)" (%declarations,%type,%attributes)

endClass

class TypeAccess : Cmd
  PROPERTIES
    of_type : Type
    args    : Cmd

  METHODS
    method init( t, of_type, args=null )

    method init( existing:TypeAccess )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "TypeAccess($,$)" (%of_type,%args)

endClass

class GetGlobalProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:GetGlobalProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "GetGlobalProperty($)" (%info)

endClass

class SetGlobalProperty : Cmd
  PROPERTIES
    info      : Property
    new_value : Cmd

  METHODS
    method init( info, new_value )
      t = info.t

    method init( t, info, new_value )

    method init( existing:SetGlobalProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "SetGlobalProperty($,$)" (%info,%new_value)

endClass

class ContextDirectAccess : Cmd
  PROPERTIES
    context : Cmd
    name    : String

  METHODS
    method init( t, context, name )

    method init( existing:ContextDirectAccess )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      name = existing.name

    method description->String
      return "ContextDirectAccess($,$)" (%context,%name)

endClass

class DirectAccess : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:DirectAccess )
      prior.init( existing )
      name = existing.name

    method description->String
      return "DirectAccess($)" (%name)

    method to->Character
      return Cmd.to_character(name)

    method to->Int:    return name
    method to->Logical: return name?
    method to->String: return name

endClass

class Logicalize : Unary
  METHODS
    method description->String
      return "Logicalize($)" (%operand)

endClass

class WideningCast : Cmd
  PROPERTIES
    operand : Cmd
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method init( existing:WideningCast )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.to_type) to_type = existing.to_type.cloned

    method description->String
      return "WideningCast($,$)" (%operand,%to_type)

endClass

class Logicalized : Unary
  METHODS
    method description->String
      return "Logicalized($)" (%operand)

endClass

class CompareOp : Compare
  METHODS
    method description->String
      return "CompareOp($,$)" (%left,%right)

endClass

class UsedResource : Cmd
  PROPERTIES
    name     : String
    resource : Cmd

  METHODS
    method init( t, name, resource )

    method init( existing:UsedResource )
      prior.init( existing )
      name = existing.name
      if (existing.resource) resource = existing.resource.cloned

    method description->String
      return "UsedResource($,$)" (%name,%resource)

endClass

class UsedResources : CmdList
  METHODS
    method description->String
      return "UsedResources" + list_description

    method get( index:Int32 )->UsedResource
      return list[index]->(as UsedResource)
endClass

class Use : ControlStructure
  PROPERTIES
    resources  : UsedResources
    statements : Cmd

  METHODS
    method init( t, resources, statements )

    method init( existing:Use )
      prior.init( existing )
      if (existing.resources) resources = existing.resources.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "Use($,$)" (%resources,%statements)

    method requires_cleanup->Logical
      return true

endClass

class CleanupBlock : ControlStructure
  PROPERTIES
    cleanup : Cmd

  METHODS
    method init( t, control_type:ControlType )
      prior.init( t, control_type )
      cleanup = Statements(t)

    method init( t, statements, cleanup=null )
      cleanup = Statements(t)

    method init( existing:CleanupBlock )
      prior.init( existing )
      if (existing.cleanup) cleanup = existing.cleanup.cloned

    method description->String
      return "CleanupBlock($,$)" (%statements,%cleanup)

    method requires_cleanup->Logical
      return true
endClass

class While : Cmd
  PROPERTIES
    condition  : Cmd
    statements : Cmd

  METHODS
    method init( t, condition, statements )

    method init( existing:While )
      prior.init( existing )
      if (existing.condition) condition = existing.condition.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "While($,$)" (%condition,%statements)

endClass

class LiteralList : CmdList
  METHODS
    method description->String
      return "LiteralList" + list_description
endClass

class AddAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "AddAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class AddAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "AddAndAssignLocal($,$)" (%info,%operand)

endClass

class AddAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:AddAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "AddAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class AddAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "AddAndAssignThisProperty($,$)" (%info,%operand)

endClass

class BitShiftLeftAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitShiftLeftAndAssign($,$)" (%target,%operand)

endClass

class BitShiftLeftAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitShiftLeftAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class BitShiftLeftAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "BitShiftLeftAndAssignLocal($,$)" (%info,%operand)

endClass

class BitShiftLeftAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:BitShiftLeftAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "BitShiftLeftAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class BitShiftLeftAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitShiftLeftAndAssignThisProperty($,$)" (%info,%operand)

endClass

class BitShiftRightAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitShiftRightAndAssign($,$)" (%target,%operand)

endClass

class BitShiftRightXAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitShiftRightXAndAssign($,$)" (%target,%operand)

endClass

class BitShiftRightXAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitShiftRightXAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class BitShiftRightXAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "BitShiftRightXAndAssignLocal($,$)" (%info,%operand)

endClass

class BitShiftRightXAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:BitShiftRightXAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "BitShiftRightXAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class BitShiftRightXAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitShiftRightXAndAssignThisProperty($,$)" (%info,%operand)

endClass

class BitwiseAndAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitwiseAndAndAssign($,$)" (%target,%operand)

endClass

class BitwiseAndAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseAndAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class BitwiseAndAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "BitwiseAndAndAssignLocal($,$)" (%info,%operand)

endClass

class BitwiseAndAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:BitwiseAndAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "BitwiseAndAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class BitwiseAndAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseAndAndAssignThisProperty($,$)" (%info,%operand)

endClass

class BitwiseOrAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitwiseOrAndAssign($,$)" (%target,%operand)

endClass

class BitwiseOrAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseOrAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class BitwiseOrAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "BitwiseOrAndAssignLocal($,$)" (%info,%operand)

endClass

class BitwiseOrAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:BitwiseOrAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "BitwiseOrAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class BitwiseOrAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseOrAndAssignThisProperty($,$)" (%info,%operand)

endClass

class BitwiseXorAndAssign : OpAndAssign
  METHODS
    method description->String
      return "BitwiseXorAndAssign($,$)" (%target,%operand)

endClass

class BitwiseXorAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseXorAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class BitwiseXorAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "BitwiseXorAndAssignLocal($,$)" (%info,%operand)

endClass

class BitwiseXorAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:BitwiseXorAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "BitwiseXorAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class BitwiseXorAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "BitwiseXorAndAssignThisProperty($,$)" (%info,%operand)

endClass

class DivideAndAssign : OpAndAssign
  METHODS
    method description->String
      return "DivideAndAssign($,$)" (%target,%operand)

endClass

class DivideAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "DivideAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class DivideAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "DivideAndAssignLocal($,$)" (%info,%operand)

endClass

class DivideAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:DivideAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "DivideAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class DivideAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "DivideAndAssignThisProperty($,$)" (%info,%operand)

endClass

class ModAndAssign : OpAndAssign
  METHODS
    method description->String
      return "ModAndAssign($,$)" (%target,%operand)

endClass

class MultiplyAndAssign : OpAndAssign
  METHODS
    method description->String
      return "MultiplyAndAssign($,$)" (%target,%operand)

endClass

class MultiplyAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "MultiplyAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class MultiplyAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "MultiplyAndAssignLocal($,$)" (%info,%operand)

endClass

class MultiplyAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:MultiplyAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "MultiplyAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class MultiplyAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "MultiplyAndAssignThisProperty($,$)" (%info,%operand)

endClass

class PowerAndAssign : OpAndAssign
  METHODS
    method description->String
      return "PowerAndAssign($,$)" (%target,%operand)

endClass

class ResolvedOpAndAssignLocal : Cmd
  PROPERTIES
    info    : Local
    operand : Cmd

  METHODS
    method init( t, info, operand )

    method init( existing:ResolvedOpAndAssignLocal )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "ResolvedOpAndAssignLocal($,$)" (%info,%operand)

endClass

class ResolvedOpAndAssignProperty : Cmd
  PROPERTIES
    info    : Property
    operand : Cmd

  METHODS
    method init( t, info, operand )

    method init( existing:ResolvedOpAndAssignProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "ResolvedOpAndAssignProperty($,$)" (%info,%operand)

endClass

class SubtractAndAssign : OpAndAssign
  METHODS
    method description->String
      return "SubtractAndAssign($,$)" (%target,%operand)

endClass

class SubtractAndAssignGlobalProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "SubtractAndAssignGlobalProperty($,$)" (%info,%operand)

endClass

class SubtractAndAssignLocal : ResolvedOpAndAssignLocal
  METHODS
    method description->String
      return "SubtractAndAssignLocal($,$)" (%info,%operand)

endClass

class SubtractAndAssignProperty : ResolvedOpAndAssignProperty
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context, info, operand )

    method init( existing:SubtractAndAssignProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "SubtractAndAssignProperty($,$,$)" (%context,%info,%operand)

endClass

class SubtractAndAssignThisProperty : ResolvedOpAndAssignProperty
  METHODS
    method description->String
      return "SubtractAndAssignThisProperty($,$)" (%info,%operand)

endClass

class AccessAndAssign : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:AccessAndAssign )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "AccessAndAssign($)" (%operand)

endClass

class AccessAndAssignContext : Cmd
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context )

    method init( existing:AccessAndAssignContext )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "AccessAndAssignContext($)" (%context)

endClass

class InlineForEach : Cmd
  PROPERTIES
    control : ForEachControl

  METHODS
    method init( t, control )

    method init( existing:InlineForEach )
      prior.init( existing )
      if (existing.control) control = existing.control.cloned

    method description->String
      return "InlineForEach($)" (%control)

endClass

class DecrementGlobalProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:DecrementGlobalProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "DecrementGlobalProperty($)" (%info)

endClass

class DecrementLocal : Cmd
  PROPERTIES
    info : Local

  METHODS
    method init( t, info )

    method init( existing:DecrementLocal )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "DecrementLocal($)" (%info)

endClass

class DecrementProperty : Cmd
  PROPERTIES
    context : Cmd
    info    : Property

  METHODS
    method init( t, context, info )

    method init( existing:DecrementProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.info) info = existing.info.cloned

    method description->String
      return "DecrementProperty($,$)" (%context,%info)

endClass

class DecrementThisProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:DecrementThisProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "DecrementThisProperty($)" (%info)

endClass

class IncrementGlobalProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:IncrementGlobalProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "IncrementGlobalProperty($)" (%info)

endClass

class IncrementLocal : Cmd
  PROPERTIES
    info : Local

  METHODS
    method init( t, info )

    method init( existing:IncrementLocal )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "IncrementLocal($)" (%info)

endClass

class IncrementProperty : Cmd
  PROPERTIES
    context : Cmd
    info    : Property

  METHODS
    method init( t, context, info )

    method init( existing:IncrementProperty )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.info) info = existing.info.cloned

    method description->String
      return "IncrementProperty($,$)" (%context,%info)

endClass

class IncrementThisProperty : Cmd
  PROPERTIES
    info : Property

  METHODS
    method init( t, info )

    method init( existing:IncrementThisProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "IncrementThisProperty($)" (%info)

endClass

class PreDecrementLocal : Cmd
  PROPERTIES
    info : Local

  METHODS
    method init( t, info )

    method init( existing:PreDecrementLocal )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "PreDecrementLocal($)" (%info)

endClass

class LiteralReal32 : LiteralRealNumber
  PROPERTIES
    value : Real32

  METHODS
    method init( t, value )

    method init( existing:LiteralReal32 )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralReal32($)" (%value)

    method to->Int:    return value
    method to->Real64: return value
    method to->String: return value

endClass

class LiteralReal64 : LiteralRealNumber
  PROPERTIES
    value : Real64

  METHODS
    method init( t, value )

    method init( existing:LiteralReal64 )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralReal64($)" (%value)

    method to->Int:    return value
    method to->Real64: return value
    method to->String: return value

endClass

class Escape : Cmd
  METHODS
    method control_type->ControlType
      throw UnsupportedOperationError()

    method description->String
      return "Escape"
endClass

class EscapeForEach : Escape
  METHODS
    method control_type->ControlType
      return ControlType.FOR_EACH

    method description->String
      return "EscapeForEach"
endClass


class EscapeBlock : Escape
  METHODS
    method control_type->ControlType
      return ControlType.BLOCK

    method description->String
      return "EscapeBlock"
endClass

class EscapeIf : Escape
  METHODS
    method control_type->ControlType
      return ControlType.IF

    method description->String
      return "EscapeIf"
endClass

class EscapeWhile : Escape
  METHODS
    method control_type->ControlType
      return ControlType.WHILE

    method description->String
      return "EscapeWhile"
endClass

class EscapeLoop : Escape
  METHODS
    method control_type->ControlType
      return ControlType.LOOP

    method description->String
      return "EscapeLoop"
endClass

class EscapeTry : Escape
  METHODS
    method control_type->ControlType
      return ControlType.TRY

    method description->String
      return "EscapeTry"
endClass

class EscapeWhich : Escape
  METHODS
    method description->String
      return "EscapeWhich"

    method control_type->ControlType
      return ControlType.WHICH
endClass

class FormattedString : Cmd
  PROPERTIES
    format : String
    args   : Cmd

  METHODS
    method init( t, format, args )

    method init( existing:FormattedString )
      prior.init( existing )
      format = existing.format
      if (existing.args) args = existing.args.cloned

    method description->String
      return "FormattedString($,$)" (%format,%args)

endClass

class PushStackTraceCutoff : Cmd
  METHODS
    method description->String
      return "PushStackTraceCutoff"
endClass

class Which : Conditional
  PROPERTIES
    cases       : WhichCases
    is_resolved : Logical

  METHODS
    method init( t, condition, cases, statements )
      prior.init( t, condition, statements, ControlType.WHICH )

    method init( existing:Which )
      prior.init( existing )
      if (existing.cases) cases = existing.cases.cloned

    method description->String
      return "Which($,$,$)" (%condition,%cases,%statements)

endClass

class WhichCase : Cmd
  PROPERTIES
    args       : Cmd
    statements : Cmd

  METHODS
    method init( t, args, statements )

    method init( existing:WhichCase )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "WhichCase($,$)" (%args,%statements)

endClass

class WhichCases : CmdList
  METHODS
    method description->String
      return "WhichCases" + list_description

    method get( index:Int32 )->WhichCase
      return list[index]->(as WhichCase)
endClass


class Switch : Conditional
  PROPERTIES
    cases : WhichCases

  METHODS
    method init( t, condition, cases, statements )
      control_type = ControlType.WHICH

    method init( existing:Switch )
      prior.init( existing )
      if (existing.cases) cases = existing.cases.cloned

    method description->String
      return "Switch($,$,$)" (%condition,%cases,%statements)

endClass

class Contingent : ControlStructure
  PROPERTIES
    satisfied_scope : Cmd
    satisfied_statements       : Cmd
    unsatisfied_statements     : Cmd
    catches_necessary          : Logical
    catches_sufficient         : Logical
    is_resolved                : Logical

  METHODS
    method init( t, statements, satisfied_statements, unsatisfied_statements )
      control_type = ControlType.CONTINGENT
      if (satisfied_statements) satisfied_scope = LocalScope( satisfied_statements.t, satisfied_statements )

    method init( existing:Contingent )
      prior.init( existing )
      is_resolved = existing.is_resolved
      if (existing.satisfied_scope)
        satisfied_scope = existing.satisfied_scope.cloned
        satisfied_statements = satisfied_scope->(as LocalScope).statements
      endIf
      if (existing.unsatisfied_statements) unsatisfied_statements = existing.unsatisfied_statements.cloned

    method catches_escape( escape_type:ControlType )->Logical
      which (escape_type)
        # Contingents are wrapped in contingent Blocks that act like contingents.
        # The wrapping Block catches CONTINGENT escapes.
        #case ControlType.CONTINGENT
        #  catches_escape = true
        #  return true
        case ControlType.NECESSARY
          catches_necessary = true
          return true
        case ControlType.SUFFICIENT
          catches_sufficient = true
          return true
        others
          return false
      endWhich

    method description->String
      return "Contingent($,$,$)" (%statements,%satisfied_statements,%unsatisfied_statements)

endClass

class Necessary : Cmd
  PROPERTIES
    condition : Cmd

  METHODS
    method init( t, condition )

    method init( existing:Necessary )
      prior.init( existing )
      if (existing.condition) condition = existing.condition.cloned

    method control_type->ControlType
      return ControlType.NECESSARY

    method description->String
      return "Necessary($)" (%condition)

endClass

class Sufficient : Cmd
  PROPERTIES
    condition : Cmd

  METHODS
    method init( t, condition )

    method init( existing:Sufficient )
      prior.init( existing )
      if (existing.condition) condition = existing.condition.cloned

    method control_type->ControlType
      return ControlType.SUFFICIENT

    method description->String
      return "Sufficient($)" (%condition)

endClass

class EscapeContingent : Escape
  METHODS
    method control_type->ControlType
      return ControlType.CONTINGENT

    method description->String
      return "EscapeContingent"
endClass

class AttributeAbstract : Cmd
  METHODS
    method description->String
      return "AttributeAbstract"
endClass

class AttributeFallback : Cmd
  METHODS
    method description->String
      return "AttributeFallback"
endClass

class EmptyCompound : Cmd
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method init( existing:EmptyCompound )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned

    method description->String
      return "EmptyCompound($)" (%of_type)

endClass

class GlobalMethodTemplate : Cmd
  PROPERTIES
    name         : String
    placeholders : Cmd
    token_list   : TokenList
    omit_doc     : Logical

  METHODS
    method init( t, name, placeholders, token_list )

    method init( existing:GlobalMethodTemplate )
      prior.init( existing )
      name = existing.name
      if (existing.placeholders) placeholders = existing.placeholders.cloned
      if (existing.token_list) token_list = existing.token_list.cloned

    method description->String
      return "GlobalMethodTemplate($,$)" (%name,%placeholders)

    method instantiate( template_args:TemplateArgs, type_context:Type )->Procedure
      local placeholders = Token[]
      forEach (p in this.placeholders)
        placeholders.add( p.t )
      endForEach
      local name = template_args->String( name )
      local replacements = Template.replacements( placeholders, template_args )
      local tokens = Template.make_replacements( type_context, token_list, replacements )

      temporarily Program.current_module = type_context.module_context
        local parser = Parser( tokens )
        parser._cmd_stack.add( Identifier(t,name) )
        local m = parser.parse( Parser.ip_global_method_template_instance )->(as GlobalMethod)
        m.module_context = type_context.module_context
        m.type_context   = type_context
        m.attributes.omit_doc = omit_doc
        m.organize
        Transformer().visit( m )

        type_context.global_method_template_instances.add( name )
        return m
      endTemporarily
endClass

class MethodTemplate : Cmd
  PROPERTIES
    type_context : Type
    name         : String
    placeholders : Cmd
    token_list   : TokenList
    omit_doc     : Logical

  METHODS
    method init( t, name, placeholders, token_list )

    method init( existing:MethodTemplate )
      prior.init( existing )
      type_context = existing.type_context
      name = existing.name
      if (existing.placeholders) placeholders = existing.placeholders.cloned
      if (existing.token_list) token_list = existing.token_list.cloned

    method description->String
      return "MethodTemplate($,$)" (%name,%placeholders)

    method instantiate( template_args:TemplateArgs )->Procedure
      temporarily Program.current_module = type_context.module_context
        local placeholders = Token[]
        forEach (p in this.placeholders)
          placeholders.add( p.t )
        endForEach
        local name = template_args->String( name )
        local replacements = Template.replacements( placeholders, template_args )
        local tokens = Template.make_replacements( type_context, token_list, replacements )
        local parser = Parser( tokens )
        parser._cmd_stack.add( Identifier(t,name) )

        type_context.method_template_instances.add( name )

        local m = parser.parse( Parser.ip_method_template_instance )->(as Method)
        m.module_context = type_context.module_context
        m.type_context   = type_context
        m.attributes.omit_doc = omit_doc
        m.method_template = this
        m.template_args = template_args
        m.generate_body
        m.organize
        m.dynamic_signature  # adds method to dynamic call group

        if (type_context.methods_organized)
          if (not m.overridden_method and type_context.base_class)
            m.overridden_method = type_context.base_class.methods[ m.signature ]
            if (m.overridden_method) m.overridden_method.attributes.is_overridden = true
          endIf
        endIf

        # Propagate new method template to types that have already organized & inherited methods
        if (type_context.methods_organized)
          (forEach in type_context.extended_types).inject_inherited_method( m )
        endIf

        Transformer().visit( m )

        if (type_context.is_resolved)
          m.resolve
        endIf

        return m
      endTemporarily

endClass

class TemplatedAccess : Cmd
  PROPERTIES
    module_context : Module
    type_context   : Type
    name           : String
    type_args      : TemplateArgs
    args           : Cmd

  METHODS
    method init( t, name, type_args, args )

    method init( t, type_context, name, type_args, args )
      module_context = type_context.module_context

    method init( existing:TemplatedAccess )
      prior.init( existing )
      name = existing.name
      if (existing.type_args) type_args = existing.type_args.cloned
      if (existing.args) args = existing.args.cloned
      module_context = existing.module_context
      type_context = existing.type_context

    method description->String
      return "TemplatedAccess($,$,$)" (%name,%type_args,%args)

endClass

class TemplatedMethodContextAccess : Cmd
  PROPERTIES
    context   : Cmd
    name      : String
    type_args : TemplateArgs
    args      : Cmd

  METHODS
    method init( t, context, name, type_args, args )

    method init( t, context, name, type_arg:Type, args )
      init( t, context, name, TemplateArgs(t).[ add(TokenList(t,type_arg.name_tokens)) ], args )

    method init( existing:TemplatedMethodContextAccess )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      name = existing.name
      if (existing.type_args) type_args = existing.type_args.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "TemplatedMethodContextAccess($,$,$,$)" (%context,%name,%type_args,%args)

endClass

class FunctionType : Type
  PROPERTIES
    param_types : TypeList
    return_type : Type

  GLOBAL METHODS
    method create( t:Token, param_types:TypeList, return_type:Type )->FunctionType
      local builder = String()
      builder.print "(Function("
      forEach (arg_type at i in param_types)
        if (i > 0) builder.print ','
        builder.print arg_type.scoped_name
      endForEach
      builder.print ')'
      if (return_type)
        builder.print "->"
        builder.print return_type.module_context
        builder.print "::"
        builder.print return_type
      endIf
      builder.print ')'
      local name = builder

      local type = Program.default_module.find_type( t, name )->(as FunctionType)
      if (type) return type
      type = FunctionType( t, name, Attribute.OBJECT|Attribute.ABSTRACT, param_types, return_type )
      return type

  METHODS
    method init( t, name:String, attributes:Int64, param_types, return_type )
      prior.init( t, Program.default_module, name, attributes )
      this.attributes.is_defined = true

      local m_call = Method( t, this, "call" )
      forEach (param_type at i in param_types)
        m_call.parameters.add( Local(param_type.t,"arg"+i,param_type) )
      endForEach
      m_call.return_type = return_type
      m_call.attributes.add( Attribute.ABSTRACT )
      m_call.organize

    method init( existing:FunctionType )
      prior.init( existing )
      if (existing.param_types) param_types = existing.param_types.cloned
      if (existing.return_type) return_type = existing.return_type.cloned

    method description->String
      return name
endClass

class FunctionDefinition : Cmd
  PROPERTIES
    parameters  : Parameters
    return_type : Type
    with_values : WithValues
    statements  : Cmd

    fn_type     : Type
    base_type   : Type
    mod         : Module

  METHODS
    method init( t, parameters, return_type, with_values, statements, mod=Program.current_module )

    method init( existing:FunctionDefinition )
      prior.init( existing )
      if (existing.parameters)  parameters  = existing.parameters.cloned
      if (existing.return_type) return_type = existing.return_type.cloned->(as Type)
      if (existing.with_values) with_values = existing.with_values.cloned
      if (existing.statements)  statements  = existing.statements.cloned
      if (existing.fn_type)     fn_type     = existing.fn_type.cloned
      if (existing.base_type)   base_type   = existing.base_type.cloned
      mod = existing.mod

    method description->String
      return "FunctionDefinition($,$,$,$)" (%parameters,%return_type,%with_values,%statements)

    method resolve_type->Type
      if (fn_type) return fn_type

      local param_types = TypeList(t)
      if (not parameters) parameters = Parameters(t)

      forEach (p in parameters)
        if (not p.type)
          if (p.attributes.is_default_parameter) p.type = Program.type_Logical
          else throw p.t.error( "Missing parameter ':Type'." )
        endIf
        param_types.add( p.type )
      endForEach

      base_type = FunctionType( t, param_types, return_type )
      fn_type = Type( t, mod, "Function_$"(mod.types.count), Attribute.OBJECT|Attribute.SINGLETON )
      fn_type.base_class = base_type
      fn_type.attributes.is_defined = true

      local m_call = Method( t, fn_type, "call" )
      m_call.parameters = parameters
      m_call.return_type = return_type
      m_call.body = LocalScope( t, statements )
      m_call.statements = statements
      m_call.organize

      return fn_type

endClass

class WithValue : Cmd
  PROPERTIES
    name  : String
    value : Cmd

  METHODS
    method init( t, name, value )

    method init( existing:WithValue )
      prior.init( existing )
      name = existing.name
      if (existing.value) value = existing.value.cloned

    method description->String
      return "WithValue($,$)" (%name,%value)

endClass

class WithValues : CmdList
  METHODS
    method description->String
      return "WithValues" + list_description

    method get( index:Int32 )->WithValue
      return list[index]->(as WithValue)
endClass

class GenericFunctionDefinition : Cmd
  PROPERTIES
    parameters  : IDList
    with_values : WithValues
    statements  : Cmd

  METHODS
    method init( t, parameters, with_values, statements )

    method init( existing:GenericFunctionDefinition )
      prior.init( existing )
      if (existing.parameters) parameters = existing.parameters.cloned
      if (existing.with_values) with_values = existing.with_values.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "GenericFunctionDefinition($,$,$)" (%parameters,%with_values,%statements)

endClass

class IDList : CmdList
  METHODS
    method description->String
      return "IDList" + list_description

    method get( index:Int32 )->Identifier
      return list[index]->(as Identifier)
endClass

class FunctionReturnValue : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:FunctionReturnValue )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "FunctionReturnValue($)" (%operand)

endClass

class ConvertToTypeWithArgs : Cmd
  PROPERTIES
    operand : Cmd
    to_type : Type
    args    : Cmd

  METHODS
    method init( t, operand, to_type, args )

    method init( existing:ConvertToTypeWithArgs )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.to_type) to_type = existing.to_type.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "ConvertToTypeWithArgs($,$,$)" (%operand,%to_type,%args)

endClass

class Category : Cmd
  PROPERTIES
    name    : String
    args    : Cmd
    value   : Cmd
    ordinal : Int    # final resolved 'value'
    doc     : String

  METHODS
    method init( t, name, args, value, doc, ordinal=0 )

    method init( existing:Category )
      prior.init( existing )
      name = existing.name
      if (existing.args) args = existing.args.cloned
      if (existing.value) value = existing.value.cloned
      ordinal = existing.ordinal
      doc = existing.doc

    method description->String
      return "Category($,$,$,$)" (%name,%args,%value,ordinal)

endClass

class EnumValueDef : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method init( existing:EnumValueDef )
      prior.init( existing )
      if (existing.value) value = existing.value.cloned

    method description->String
      return "EnumValueDef($)" (%value)

endClass

class CreateCompound : Cmd
  PROPERTIES
    of_type : Type
    args    : Args

  METHODS
    method init( t, of_type, args=null )

    method init( existing:CreateCompound )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "CreateCompound($,$)" (%of_type,%args)

endClass

class EnumValue : Cmd
  PROPERTIES
    of_type : Type
    name    : String

  METHODS
    method init( t, of_type, name )

    method init( existing:EnumValue )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      name = existing.name

    method description->String
      return "EnumValue($,$)" (%of_type,%name)

endClass

class LocalDeclaration : Cmd
  PROPERTIES
    info : Local

  METHODS
    method init( t, info )

    method init( existing:LocalDeclaration )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned

    method description->String
      return "LocalDeclaration($)" (%info)

endClass

class Methods : CmdList
  METHODS
    method description->String
      return "Methods" + list_description

    method get( index:Int32 )->Method
      return list[index]->(as Method)
endClass

class StateDef : Cmd
  PROPERTIES
    name    : String
    methods : Methods

  METHODS
    method init( t, name, methods )

    method init( existing:StateDef )
      prior.init( existing )
      name = existing.name
      if (existing.methods) methods = existing.methods.cloned

    method description->String
      return "StateDef($,$)" (%name,%methods)

endClass

class SetSingleton : Cmd
  PROPERTIES
    of_type   : Type
    new_value : Cmd

  METHODS
    method init( t, of_type, new_value )

    method init( existing:SetSingleton )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "SetSingleton($,$)" (%of_type,%new_value)

endClass

class AttributePropagated : Cmd
  METHODS
    method description->String
      return "AttributePropagated"
endClass

class Temporarily : ControlStructure
  PROPERTIES
    assignments : TemporaryAssignments

  METHODS
    method init( t, assignments, statements )

    method init( existing:Temporarily )
      prior.init( existing )
      if (existing.assignments) assignments = existing.assignments.cloned

    method description->String
      return "Temporarily($,$)" (%assignments,%statements)

endClass

class TemporaryAssignment : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method init( existing:TemporaryAssignment )
      prior.init( existing )
      if (existing.target) target = existing.target.cloned
      if (existing.new_value) new_value = existing.new_value.cloned

    method description->String
      return "TemporaryAssignment($,$)" (%target,%new_value)

endClass

class TemporaryAssignments : CmdList
  METHODS
    method description->String
      return "TemporaryAssignments" + list_description

    method get( index:Int32 )->TemporaryAssignment
      return list[index]->(as TemporaryAssignment)
endClass

class As : Cmd
  PROPERTIES
    operand : Cmd
    as_type : Type

  METHODS
    method init( t, operand, as_type )

    method init( existing:As )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.as_type) as_type = existing.as_type.cloned

    method description->String
      return "As($,$)" (%operand,%as_type)

endClass

class IfLocal : Cmd
  PROPERTIES
    name       : String
    expression : Cmd
    statements : Cmd
    else_if    : IfLocal

  METHODS
    method init( t, name, expression, statements, else_if=null )

    method init( existing:IfLocal )
      prior.init( existing )
      name = existing.name
      if (existing.expression) expression = existing.expression.cloned
      if (existing.statements) statements = existing.statements.cloned
      if (existing.else_if)    else_if    = existing.else_if.cloned

    method description->String
      return "IfLocal($,$,$,$)" (%name,%expression,%statements,%else_if)

endClass

class AttributeMutating : Cmd
  METHODS
    method description->String
      return "AttributeMutating"
endClass

class AttributeAPI : Cmd
  METHODS
    method description->String
      return "AttributeAPI"
endClass

class AnonymousTuple : CmdList
  METHODS
    method description->String
      return "AnonymousTuple" + list_description
endClass

class NamedTuple : CmdList
  METHODS
    method description->String
      return "NamedTuple" + list_description

    method get( index:Int32 )->NamedTupleElement
      return list[index]->(as NamedTupleElement)
endClass

class NamedTupleElement : Cmd
  PROPERTIES
    name  : String
    value : Cmd

  METHODS
    method init( t, name, value )

    method init( existing:NamedTupleElement )
      prior.init( existing )
      name = existing.name
      if (existing.value) value = existing.value.cloned

    method description->String
      return "NamedTupleElement($,$)" (%name,%value)

endClass

class TypedDestructuringLocal : Cmd
  PROPERTIES
    name : String
    type : Type

  METHODS
    method init( t, name, type )

    method init( existing:TypedDestructuringLocal )
      prior.init( existing )
      name = existing.name
      if (existing.type) type = existing.type.cloned

    method description->String
      return "TypedDestructuringLocal($,$)" (%name,%type)

    method type->Type
      return @type

endClass

class TypedDestructuringLocalDeclarations : Cmd
  PROPERTIES
    locals : TypedDestructuringLocals
    tuple  : Cmd

  METHODS
    method init( t, locals, tuple )

    method init( existing:TypedDestructuringLocalDeclarations )
      prior.init( existing )
      if (existing.locals) locals = existing.locals.cloned
      if (existing.tuple) tuple = existing.tuple.cloned

    method description->String
      return "TypedDestructuringLocalDeclarations($,$)" (%locals,%tuple)

endClass

class TypedDestructuringLocals : CmdList
  METHODS
    method description->String
      return "TypedDestructuringLocals" + list_description

    method get( index:Int32 )->TypedDestructuringLocal
      return list[index]->(as TypedDestructuringLocal)
endClass

class UntypedDestructuringLocalDeclarations : Cmd
  PROPERTIES
    locals : Identifiers
    tuple  : Cmd

  METHODS
    method init( t, locals, tuple )

    method init( existing:UntypedDestructuringLocalDeclarations )
      prior.init( existing )
      if (existing.locals) locals = existing.locals.cloned
      if (existing.tuple) tuple = existing.tuple.cloned

    method description->String
      return "UntypedDestructuringLocalDeclarations($,$)" (%locals,%tuple)

endClass

class Identifiers : CmdList
  METHODS
    method description->String
      return "Identifiers" + list_description
endClass

class AnonymousTupleTypeElements : CmdList
  METHODS
    method description->String
      return "AnonymousTupleTypeElements" + list_description

    method get( index:Int32 )->Type
      return list[index]->(as Type)

endClass

class NamedTupleTypeElement : Cmd
  PROPERTIES
    name    : String
    of_type : Type

  METHODS
    method init( t, name, of_type )

    method init( existing:NamedTupleTypeElement )
      prior.init( existing )
      name = existing.name
      if (existing.of_type) of_type = existing.of_type.cloned

    method description->String
      return "NamedTupleTypeElement($,$)" (%name,%of_type)

endClass

class NamedTupleTypeElements : CmdList
  METHODS
    method description->String
      return "NamedTupleTypeElements" + list_description

    method get( index:Int32 )->NamedTupleTypeElement
      return list[index]->(as NamedTupleTypeElement)
endClass

class CreateRange : Cmd
  PROPERTIES
    start     : Cmd
    limit     : Cmd
    step_size : Cmd

  METHODS
    method init( t, start, limit, step_size )

    method init( existing:CreateRange )
      prior.init( existing )
      if (existing.start) start = existing.start.cloned
      if (existing.limit) limit = existing.limit.cloned
      if (existing.step_size) step_size = existing.step_size.cloned

    method default_step_size->Int32
      return 1

    method description->String
      return "CreateRange($,$,$)" (%start,%limit,%step_size)

    method name->String
      return "Range"

endClass

class CreateRangeDownTo : CreateRange
  METHODS
    method default_step_size->Int32
      return -1

    method description->String
      return "CreateRangeDownTo($,$,$)" (%start,%limit,%step_size)

    method name->String
      return "RangeDownTo"
endClass

class CreateRangeDownToGreaterThan : CreateRange
  METHODS
    method default_step_size->Int32
      return -1

    method description->String
      return "CreateRangeDownToGreaterThan($,$,$)" (%start,%limit,%step_size)

    method name->String
      return "RangeDownToGreaterThan"
endClass

class CreateRangeUpTo : CreateRange
  METHODS
    method default_step_size->Int32
      return 1

    method description->String
      return "CreateRangeUpTo($,$,$)" (%start,%limit,%step_size)

    method name->String
      return "RangeUpTo"
endClass

class CreateRangeUpToLessThan : CreateRange
  METHODS
    method default_step_size->Int32
      return 1

    method description->String
      return "CreateRangeUpToLessThan($,$,$)" (%start,%limit,%step_size)

    method name->String
      return "RangeUpToLessThan"
endClass

class NextIteration : Cmd
  METHODS
    method description->String
      return "NextIteration"
endClass

class New : Cmd
  PROPERTIES
    type_expression : Cmd
    args            : Args

  METHODS
    method init( t, type_expression, args )

    method init( existing:New )
      prior.init( existing )
      if (existing.type_expression) type_expression = existing.type_expression.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "New($,$)" (%type_expression,%args)

endClass

class Ensure : Cmd
  PROPERTIES
    expression : Cmd
    args       : Args

  METHODS
    method init( t, expression, args )

    method init( existing:Ensure )
      prior.init( existing )
      if (existing.expression) expression = existing.expression.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "Ensure($,$)" (%expression,%args)

endClass

class Assert : Cmd
  PROPERTIES
    expression : Cmd
    token_list : TokenList

  METHODS
    method init( t, expression, token_list )

    method init( existing:Assert )
      prior.init( existing )
      if (existing.expression) expression = existing.expression.cloned
      if (existing.token_list) token_list = existing.token_list.cloned

    method description->String
      return "Assert($,$)" (%expression,%token_list)

endClass

class GenericFnArg : Cmd
  METHODS
    method description->String
      return "GenericFnArg"
endClass

class TypedLiteralList : Cmd
  PROPERTIES
    of_type : Type
    list    : Cmd

  METHODS
    method init( t, of_type, list )

    method init( existing:TypedLiteralList )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.list) list = existing.list.cloned

    method description->String
      return "TypedLiteralList($,$)" (%of_type,%list)

endClass

class KeyValuePairList : CmdList
  METHODS
    method description->String
      return "KeyValuePairList" + list_description

    method get( index:Int32 )->KeyValuePair
      return list[index]->(as KeyValuePair)
endClass

class KeyValuePair : Cmd
  PROPERTIES
    key   : Cmd
    value : Cmd

  METHODS
    method init( t, key, value )

    method init( existing:KeyValuePair )
      prior.init( existing )
      if (existing.key) key = existing.key.cloned
      if (existing.value) value = existing.value.cloned

    method description->String
      return "KeyValuePair($,$)" (%key,%value)

endClass

class TypedLiteralTable : Cmd
  PROPERTIES
    of_type : Type
    table   : KeyValuePairList

  METHODS
    method init( t, of_type, table )

    method init( existing:TypedLiteralTable )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned
      if (existing.table) table = existing.table.cloned

    method description->String
      return "TypedLiteralTable($,$)" (%of_type,%table)

endClass

class BriefTrace : Cmd
  PROPERTIES
    expressions : TracedExpressions

  METHODS
    method init( t, expressions )

    method init( existing:BriefTrace )
      prior.init( existing )
      if (existing.expressions) expressions = existing.expressions.cloned

    method description->String
      return "BriefTrace($)" (%expressions)

endClass

class TracedExpression : Cmd
  PROPERTIES
    expression : Cmd
    token_list : TokenList

  METHODS
    method init( t, expression, token_list )

    method init( existing:TracedExpression )
      prior.init( existing )
      if (existing.expression) expression = existing.expression.cloned
      if (existing.token_list) token_list = existing.token_list.cloned

    method description->String
      return "TracedExpression($,$)" (%expression,%token_list)

endClass

class TracedExpressions : CmdList
  METHODS
    method description->String
      return "TracedExpressions" + list_description

    method get( index:Int32 )->TracedExpression
      return list[index]->(as TracedExpression)
endClass

class VerboseTrace : Cmd
  PROPERTIES
    expressions : TracedExpressions

  METHODS
    method init( t, expressions )

    method init( existing:VerboseTrace )
      prior.init( existing )
      if (existing.expressions) expressions = existing.expressions.cloned

    method description->String
      return "VerboseTrace($)" (%expressions)

endClass

class LiteralNullOptional : Literal
  PROPERTIES
    optional_type : Type

  METHODS
    method init( t, optional_type )

    method init( existing:LiteralNullOptional )
      prior.init( existing )
      if (existing.optional_type) optional_type = existing.optional_type.cloned

    method description->String
      return "LiteralNullOptional($)" (%optional_type)

endClass

class CallPriorMethod : Cmd
  PROPERTIES
    name : String
    args : Args

  METHODS
    method init( t, name, args )

    method init( existing:CallPriorMethod )
      prior.init( existing )
      name = existing.name
      if (existing.args) args = existing.args.cloned

    method description->String
      return "CallPriorMethod($,$)" (%name,%args)

endClass

class Describe : Unary
  METHODS
    method description->String
      return "Describe($)" (%operand)

endClass

class AttributeBitflags : Cmd
  METHODS
    method description->String
      return "AttributeBitflags"
endClass

class CallbackFunction : Cmd
  PROPERTIES
    context : Cmd
    name    : String
    param_types : TypeList

  METHODS
    method init( t, context, name, param_types )

    method init( existing:CallbackFunction )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.param_types) param_types = existing.param_types.cloned
      name = existing.name

    method description->String
      return "CallbackFunction($,$,$)" (%context,%name,%param_types)

endClass

class AttributeOverride : Cmd
  METHODS
    method description->String
      return "AttributeOverride"
endClass

class SwapValues : Cmd
  PROPERTIES
    a : Cmd
    b : Cmd

  METHODS
    method init( t, a, b )

    method init( existing:SwapValues )
      prior.init( existing )
      if (existing.a) a = existing.a.cloned
      if (existing.b) b = existing.b.cloned

    method description->String
      return "SwapValues($,$)" (%a,%b)

endClass

class NotInstanceOf : Cmd
  PROPERTIES
    operand      : Cmd
    compare_type : Type

  METHODS
    method init( t, operand, compare_type )

    method init( existing:NotInstanceOf )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.compare_type) compare_type = existing.compare_type.cloned

    method description->String
      return "NotInstanceOf($,$)" (%operand,%compare_type)

endClass

class AttributeFaux : Cmd
  METHODS
    method description->String
      return "AttributeFaux"
endClass

class DefaultValue : Cmd
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method init( existing:DefaultValue )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned

    method description->String
      return "DefaultValue($)" (%of_type)

endClass

class IsEnum : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method init( existing:IsEnum )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned

    method description->String
      return "IsEnum($)" (%operand)

endClass

class AttributePreferred : Cmd
  METHODS
    method description->String
      return "AttributePreferred"
endClass

class LiteralUndefined : Cmd
  METHODS
    method description->String
      return "LiteralUndefined"
endClass

class EmptyVariantList : Cmd
  METHODS
    method description->String
      return "EmptyVariantList"
endClass

class EmptyVariantTable : Cmd
  METHODS
    method description->String
      return "EmptyVariantTable"
endClass

class GetTypeInfo : Cmd
  PROPERTIES
    of_type       : Type

  METHODS
    method init( t, of_type )

    method init( existing:GetTypeInfo )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned

    method description->String
      return "GetTypeInfo($)" (%of_type)

    method type->Type
      return Program.default_module.must_find_type( t, "TypeInfo" )

endClass

class TypeIndex : Cmd
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method init( existing:TypeIndex )
      prior.init( existing )
      if (existing.of_type) of_type = existing.of_type.cloned

    method description->String
      return "TypeIndex($)" (%of_type)

    method type->Type
      return Program.type_Int32

endClass

class ConditionalContext : Cmd
  PROPERTIES
    context : Cmd

  METHODS
    method init( t, context )

    method init( existing:ConditionalContext )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "ConditionalContext($)" (%context)

endClass

class IfConditionalContext : Cmd
  PROPERTIES
    conditional_context : ConditionalContext
    statements          : Cmd

  METHODS
    method init( t, conditional_context, statements )

    method init( existing:IfConditionalContext )
      prior.init( existing )
      if (existing.conditional_context) conditional_context = existing.conditional_context.cloned
      if (existing.statements) statements = existing.statements.cloned

    method description->String
      return "IfConditionalContext($,$)" (%conditional_context,%statements)

endClass

class VariantList : Cmd
  PROPERTIES
    args : Cmd

  METHODS
    method init( t, args )

    method init( existing:VariantList )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned

    method description->String
      return "VariantList($)" (%args)

endClass

class VariantTable : Cmd
  PROPERTIES
    args : KeyValuePairList

  METHODS
    method init( t, args )

    method init( existing:VariantTable )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned

    method description->String
      return "VariantTable($)" (%args)

endClass

class CallMethodPointer : Cmd
  PROPERTIES
    info        : Procedure
    pointer     : Cmd
    param_types : TypeList
    args        : Cmd
    return_type : Type

  METHODS
    method init( t, pointer, param_types, args, return_type )

    method init( t, info, pointer, param_types, args, return_type )

    method init( existing:CallMethodPointer )
      prior.init( existing )
      if (existing.pointer) pointer = existing.pointer.cloned
      if (existing.param_types) param_types = existing.param_types.cloned
      if (existing.args) args = existing.args.cloned
      if (existing.return_type) return_type = existing.return_type.cloned

    method description->String
      return "CallMethodPointer($,$,$,$)" (%pointer,%param_types,%args,%return_type)

    method type->Type
      return return_type

endClass

class InlineAssignment : Cmd
  PROPERTIES
    info  : Local
    value : Cmd

  METHODS
    method init( t, info, value )

    method init( existing:InlineAssignment )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.value) value = existing.value.cloned

    method description->String
      return "InlineAssignment($,$)" (%info,%value)

endClass

class IntrospectionGetObjectProperty : Cmd
  PROPERTIES
    info    : Property
    context : Cmd

  METHODS
    method init( t, info, context )

    method init( existing:IntrospectionGetObjectProperty )
      prior.init( existing )
      if (existing.info) info = existing.info.cloned
      if (existing.context) context = existing.context.cloned

    method description->String
      return "IntrospectionGetObjectProperty($,$)" (%info,%context)

endClass

class TypeOf : Cmd
  PROPERTIES
    expression : Cmd
    args       : Args

  METHODS
    method init( t, expression, args )

    method init( existing:TypeOf )
      prior.init( existing )
      if (existing.expression) expression = existing.expression.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "TypeOf($,$)" (%expression,%args)

endClass

class CommandExists : Cmd
  PROPERTIES
    command : Cmd

  METHODS
    method init( t, command )

    method init( existing:CommandExists )
      prior.init( existing )
      if (existing.command) command = existing.command.cloned

    method description->String
      return "CommandExists($)" (%command)

endClass

class Placeholders : CmdList
  METHODS
    method description->String
      return "Placeholders" + list_description

    method get( index:Int32 )->Placeholder
      return list[index]->(as Placeholder)
endClass

class CallPriorTemplatedMethod : Cmd
  PROPERTIES
    name          : String
    template_args : TemplateArgs
    args          : Args

  METHODS
    method init( t, name, template_args, args )

    method init( existing:CallPriorTemplatedMethod )
      prior.init( existing )
      name = existing.name
      if (existing.template_args) template_args = existing.template_args.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "CallPriorTemplatedMethod($,$,$)" (%name,%template_args,%args)

endClass

class CallThisVirtualMethod : CallProcedure
  METHODS
    method description->String
      return "CallThisVirtualMethod($)" (%args)

endClass

class CallVirtualMethod : CallProcedure
  PROPERTIES
    context       : Cmd
    vcall_index   = -1

  METHODS
    method init( t, context, args )

    method init( t, context, info, args )

    method init( existing:CallVirtualMethod )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned

    method description->String
      return "CallVirtualMethod($,$)" (%context,%args)

endClass

class InvokeContext : Cmd
  PROPERTIES
    context : Cmd
    args    : Cmd

  METHODS
    method init( t, context, args )

    method init( existing:InvokeContext )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "InvokeContext($,$)" (%context,%args)

endClass

class ListIndexedAccess : Cmd
  PROPERTIES
    context : Cmd
    args    : Cmd

  METHODS
    method init( t, context, args )

    method init( existing:ListIndexedAccess )
      prior.init( existing )
      if (existing.context) context = existing.context.cloned
      if (existing.args) args = existing.args.cloned

    method description->String
      return "ListIndexedAccess($,$)" (%context,%args)

endClass

class ExplicitCast : Cmd
  PROPERTIES
    operand : Cmd
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method init( existing:ExplicitCast )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.to_type) to_type = existing.to_type.cloned

    method description->String
      return "ExplicitCast($,$)" (%operand,%to_type)

endClass

class NativeLiteralInt32 : NativeExpression
  METHODS
    method init( t:Token, content:String )
      prior.init( t, content, Program.type_Int32 )

    method init( other:NativeLiteralInt32 )
      prior.init( other )

    method description->String
      return "NativeLiteralInt32($)" (%content)

endClass

class NotIsType : Cmd
  PROPERTIES
    operand      : Cmd
    compare_type : Type

  METHODS
    method init( t, operand, compare_type )

    method init( existing:NotIsType )
      prior.init( existing )
      if (existing.operand) operand = existing.operand.cloned
      if (existing.compare_type) compare_type = existing.compare_type.cloned

    method description->String
      return "NotIsType($,$)" (%operand,%compare_type)

endClass


class AttributeReplace : Cmd
  METHODS
    method description->String
      return "AttributeReplace"
endClass


class LiteralInt : LiteralInteger
  PROPERTIES
    value : Int

  METHODS
    method init( t, value )

    method init( existing:LiteralInt )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralInt($)" (%value)

    method to->Int:       return value
    method to->String:    return value

endClass

class ConvertToInt : Convert
  METHODS
    method description->String
      return "ConvertToInt($)" (%operand)

endClass

class ConvertToReal : Convert
  METHODS
    method description->String
      return "ConvertToReal($)" (%operand)

endClass

class LiteralRealNumber : LiteralPrimitive
  GLOBAL METHODS
    method create( t:Token, content:String )->LiteralRealNumber
      if ("rfF".contains(content[content.count-1]))
        return LiteralReal32( t, content.unright(1)->Real32 )
      elseIf (content.ends_with('R'))
        return LiteralReal64( t, content.unright(1)->Real64 )
      else
        return LiteralReal( t, content->Real64 )
      endIf

  METHODS
    method description->String
      return "LiteralRealNumber"

endClass
