library RogueC

uses Collection/ListLookupTable

class Type : Cmd
  DEFINITIONS
    PRECISION_LOGICAL   = 0
    PRECISION_BYTE      = 1
    PRECISION_CHARACTER = 2
    PRECISION_INT32     = 3
    PRECISION_INT       = 4
    PRECISION_INT64     = 5
    PRECISION_REAL32    = 6
    PRECISION_REAL      = 7
    PRECISION_REAL64    = 8
    PRECISION_OBJECT    = 10

  PROPERTIES
    library_context   : Library
    name              : String
    base_class        : Type
    aspects           : Type[]
    extended_types    = Type[]
    attributes        : Attributes
    definitions       = [String:Cmd]
    global_properties = [String:Property]
    properties        = [String:Property]
    global_methods    = [String:GlobalMethod]
    methods           = [String:Method]
    native_header     = NativeHeader[]
    native_code       = NativeCode[]
    class_def         : Cmd
    states            = StateDef[]
    element_type      : Type  # for lists

    categories        : Category[]

    type_template                    : Template
    type_args                        : TemplateArgs
    global_method_templates          = ListLookupTable<<String,GlobalMethodTemplate>>()
    global_method_template_instances = Set<<String>>()
    method_templates                 = ListLookupTable<<String,MethodTemplate>>()
    method_template_instances        = Set<<String>>()

    scoped_name           : String
    name_tokens           : Token[]

    index = -1L       # index of type in meta info table
    id    : Int       # intermediate value used to build dynamic tables etc. Remapped to
                      # type indices after analysis is completed.
    class_data_index : Int
    exception_type   : ExceptionType

    m_init_class          : GlobalMethod
    m_on_singleton_change : GlobalMethod
    m_on_cleanup          : Method
    m_primary_constructor : GlobalMethod   # for compounds; indicates what types are for destructuring assignments

    base_type_lookup_index  : Int
    base_type_ids           = Int[]

    method_vtable           = [String:Method]

    is_type_organized    : Logical
    properties_organized : Logical
    gc_info_collected    : Logical
    methods_organizing   : Logical
    methods_organized    : Logical
    definitions_resolved : Logical
    is_resolved          : Logical
    is_vtable_finalized  : Logical

  GLOBAL METHODS
    method create( t:Token, name:String, type_args=null:TemplateArgs, &is_tuple )->Type
      # Standard type Name<<TypeArgs>> unless &is_tuple
      local base_name = name

      if (type_args)
        if (type_args.count)
          if (not is_tuple) name = type_args->String(name)
        else
          type_args = null
        endIf
      endIf

      local type = Program.current_library.find_type( t, name, &extended_search )
      if (type) return type

      local template_name = "$<<$>>" (base_name, which{type_args:type_args.count || 0})
      local template = Program.current_library.must_find_template( t, template_name, name, &extended_search )
      return Type( t, template, name, type_args, &=is_tuple )

    method create( t:Token, name:String, template_arg:Type )->Type
      # TypeName<<TypeArg>>
      local type_args = TemplateArgs(t).[ add(TokenList(t,template_arg.name_tokens)) ]
      return Type( t, name, type_args )

    method create( t:Token, library_context:Library, name:String )->Type
      # Library::TypeName
      local type = library_context.find_type( t, name )
      if (type) return type

      local template = Program.current_library.must_find_template( t, name+"<<0>>", name, &extended_search )
      return Type( t, template, name, null )

    method create( t:Token, template:Template, type_args=null:TemplateArgs, &is_tuple )->Type
      return Type( t, template, type_args->String(template.name), type_args, &=is_tuple )

    method create( t:Token, template:Template, library_context:Library, type_args=null:TemplateArgs, &is_tuple )->Type
      temporarily Program.current_library = library_context
        local name = template.name
        if (type_args) name = type_args->String(template.name)
        return Type( t, template, library_context, name, type_args, &=is_tuple )
      endTemporarily

    method create( t:Token, template:Template, name:String, type_args=null:TemplateArgs, &is_tuple )->Type
      return create( t, template, template.library_context, name, type_args, &=is_tuple )

    method create( t:Token, template:Template, library_context:Library, name:String, type_args=null:TemplateArgs, &is_tuple )->Type
      # 'name' should already include <<type,args>>
      if (type_args)
        local type = library_context.find_type( t, name, &extended_search )
        if (type) return type
      endIf

      local type = Type( t, library_context, name, 0 )
      if (is_tuple) type.attributes.is_tuple = true
      type.type_template = template
      type.type_args     = type_args
      if (template.attributes.is_essential or Program.generate_doc) type.ensure_definition
      return type

    method create( t:Token, element_type:Type )->Type
      # Creates an ElementType[] / List<<ElementType>>
      local name = element_type.name + "[]"
      if (name.ends_with("[][][][][][][][][]"))
        throw t.error( "Rogue does not support list types with more than 8 dimensions. Possible infinite template generation. For example, if type $DataType[] directly or indirectly uses type $DataType[][], then type Int32[][] will use type Int32[][][] and so on." )
      endIf

      local type = element_type.library_context.find_type( t, name )
      if (type) return type

      local type_args = TemplateArgs(t).[ add(TokenList(t,element_type.name_tokens)) ]
      local template = Program.default_library.must_find_template( t, "List<<1>>", name )

      type = Type( t, element_type.library_context, name, 0 )
      type.type_template = template
      type.type_args     = type_args
      if (template.attributes.is_essential or Program.generate_doc) type.ensure_definition
      return type

    method create( t:Token, key_type:Type, value_type:Type )->Type
      # Creates type [KeyType:ValueType] AKA Table<<KeyType,ValueType>>
      local name = "[$:$]"(key_type.scoped_name,value_type.scoped_name)

      local type = Program.current_library.find_type( t, name, &extended_search )
      if (type) return type

      local type_args = TemplateArgs(t)
      type_args.add( TokenList(t,key_type.name_tokens) )
      type_args.add( TokenList(t,value_type.name_tokens) )
      return Type( t, Program.default_library.must_find_template(t,"Table<<2>>",name), name, type_args )

    method create( t:Token, core_type:Type, optional:Logical )->Type
      # 'optional' is always true when this method is called.
      # CoreType -> CoreType? -> Optional<<CoreType>>
      local name = core_type.name + '?'
      local type = Program.current_library.find_type( t, core_type.scoped_name+'?', &extended_search )
      if (type) return type

      local template = Program.default_library.must_find_template( t, "Optional<<1>>", name )
      local type_args = TemplateArgs(t).[ add(TokenList(t,core_type.name_tokens)) ]
      type = Type( t, template, core_type.library_context, name, type_args )
      type.attributes.is_optional = true
      return type

    method create( t:Token, anonymous_elements:AnonymousTupleTypeElements )->Type
      # Transform into named tuple type with names _1, _2, ...
      local named_elements = NamedTupleTypeElements( anonymous_elements.t )
      forEach (type at i in anonymous_elements)
        named_elements.add( NamedTupleTypeElement(anonymous_elements.t,"_$"(i+1),type) )
      endForEach

      return Type( t, named_elements )

    method create( t:Token, named_elements:NamedTupleTypeElements )->Type
      # Example
      # - NamedTupleTypeElements = [ {a:Int32}, {b:Real64} ]
      # - Tuple Type = Tuple<<4>> : Tuple<<a,Int32,b,Real64>>
      # - All in default library 'Rogue'
      local is_anonymous = true
      forEach (element at i in named_elements)
        # See if elements are named _1, _2, ...
        if (element.name != "_$"(i+1))
          is_anonymous = false
          escapeForEach
        endIf
      endForEach

      local builder = String()
      builder.print '('
      forEach (element at i in named_elements)
        if (i > 0) builder.print ','
        if (not is_anonymous)
          builder.print element.name
          builder.print ':'
        endIf
        builder.print element.of_type.scoped_name
      endForEach
      builder.print ')'
      local tuple_type_name = builder

      local type = Program.default_library.types[ tuple_type_name ]
      if (type) return type

      local template_key = "Tuple<<$>>"(named_elements.count*2)
      local template = Program.default_library.templates[ template_key ]
      if (not template)
        # Create template e.g.:
        #   <<$name1,$Type1,$name2,$Type2>>
        #   ( name1:Type1, name2:Type2, ... ) [compound]
        #   endClass
        local placeholders = Token[]
        forEach (element at i in named_elements)
          placeholders.add( element.t.cloned(TokenType.PLACEHOLDER, "$name"+(i+1)) )
          placeholders.add( element.t.cloned(TokenType.PLACEHOLDER, "$Type"+(i+1)) )
        endForEach

        local tokens = Token[]
        t = t.cloned( t.type, null )
        tokens.add( t.cloned(TokenType.SYMBOL_OPEN_PAREN) )            # (
        forEach (i of named_elements)
          if (i > 0) tokens.add( t.cloned(TokenType.SYMBOL_COMMA) )    # ,
          tokens.add( t.cloned(TokenType.PLACEHOLDER, "$name"+(i+1)) ) # $nameN
          tokens.add( t.cloned(TokenType.SYMBOL_COLON) )               # :
          tokens.add( t.cloned(TokenType.PLACEHOLDER, "$Type"+(i+1)) ) # $TypeN
        endForEach
        tokens.add( t.cloned(TokenType.SYMBOL_CLOSE_PAREN) )           # )
        tokens.add( t.cloned(TokenType.SYMBOL_OPEN_SQUARE) )           # [
        tokens.add( t.cloned(TokenType.IDENTIFIER,"compound") )        # compound
        tokens.add( t.cloned(TokenType.SYMBOL_CLOSE_SQUARE) )          # ]
        tokens.add( t.cloned(TokenType.EOL,"") )                       # EOL
        tokens.add( t.cloned(TokenType.KEYWORD_END_CLASS) )            # endClass
        tokens.add( t.cloned(TokenType.EOL,"") )                       # EOL

        template = Template( t, Program.default_library, "Tuple", placeholders, tokens, Attribute.COMPOUND )
        Program.default_library.templates[ template_key ] = template
      endIf

      # Instantiate the template
      local template_args = TemplateArgs( t )
      forEach (element in named_elements)
        template_args.add( TokenList( element.t, Token[][element.t.cloned(TokenType.IDENTIFIER, element.name)] ) )
        template_args.add( TokenList( element.t, element.of_type.name_tokens.cloned ) )
      endForEach

      type = Type( t, template, tuple_type_name, template_args, &is_tuple )
      type.attributes.is_anonymous_tuple = is_anonymous
      return type

  METHODS
    method init( t, name, attributes:Int64, &unlisted )
      init( t, Program.current_library, name, attributes, &=unlisted )

    method init( t, library_context, name, attributes:Int64, &unlisted )
      if (not unlisted) library_context.types[ name ] = this
      this.attributes = Attributes( t, attributes )

    method init( existing:Type )
      prior.init( existing )
      name   = existing.name
      c_name = existing.@c_name
      attributes = existing.attributes
      library_context = existing.library_context
      if (existing.categories) categories = existing.categories.cloned

    method add( m:GlobalMethod )
      local existing = global_methods[m.signature]
      if (existing and existing.type_context is m.type_context)
        throw m.t.error( "Global method $ is already defined."(m.dev_signature) )
      endIf
      m.attributes.is_global = true
      global_methods[ m.signature ] = m

    method add( m:Method )
      local existing = methods[m.signature]
      if (existing)
        if (existing.type_context is m.type_context)
          throw m.t.error( "Method $ is already defined."(m.dev_signature) )
        else
          m.overridden_method = existing
          existing.attributes.is_overridden = true
        endIf
      endIf
      methods[ m.signature ] = m

    method add_base_type_id( id:Int )
      if (not base_type_ids.contains(id)) base_type_ids.add( id )

    method add_property( p:Property )
      p.type_context = this

      if (not p.type)
        if (p.initial_value)
          p.type = p.initial_value.type
          if (not p.type)
            if ((p.initial_value instanceOf ContextAccess and p.initial_value->(as ContextAccess).args) or
                (p.initial_value instanceOf TemplatedAccess and p.initial_value->(as TemplatedAccess).args))
              throw p.t.error(
                ''Cannot implicitly determine type of property "$" from initial value. ''(p.name) +
                ''Add an explicit ': Type' at the end of the line and/or add any necessary '$include' and 'uses' directives.''
              )
            else
              throw p.t.error(
                ''Cannot implicitly determine type of property "$" from initial value. ''(p.name) +
                ''Add an explicit ': Type' at the end of the line.''
              )
            endIf
          endIf
        else
          throw p.t.error( ''Property "$" must have an initial assignment or a declared ': Type'.''(p.name) )
        endIf
      endIf

      local existing_p = this.properties[p.name]
      if (existing_p and existing_p.type_context is this)
        throw p.t.error( ''Type $ already defines a property called "$".''(this,p.name) )
      endIf
      this.properties[ p.name ] = p

    method add_global_property_augment( p:Property )
      local existing_p = global_properties[p.name]
      if (existing_p)
        throw p.t.error( "A global property named '$' already exists."(p.name) )
      endIf
      global_properties[p.name] = p
      p.attributes.augmented = true

    method add_extended_property( p:Property )
      if local existing_p = properties[p.name]
        if (not p.type.instance_of(existing_p.type))
          throw p.t.error( "Redeclared property '$' type $ is not instance of inherited type $."...
            (p.name,p.type,existing_p.type) )
        endIf
      endIf
      properties[p.name] = p

    method all_template_parameters_are_dummy_values->Logical
      if (not type_template) return false

      forEach (placeholder_t at i in type_template.placeholders)
        local placeholder_name = placeholder_t.content
        local placeholder_type = type_args.type( i )
        if (placeholder_type)
          use necessary_name = StringPool
            necessary_name.print( "_Doc_Gen_" )
            necessary_name.print( forEach in placeholder_name from 1 )  # skip '$'
            if (placeholder_type.name != necessary_name) return false
          endUse

        else
          if (type_args[i].tokens.count != 1) return false
          local t = type_args[i].tokens[0]
          if (not t.content) return false
          if (not t.content.begins_with("_Doc_Gen_")) return false
        endIf

      endForEach

      return true

    method cloned->this
      return this

    method collect_base_type_ids
      if (base_type_ids.count) return

      if (base_class)
        base_class.collect_base_type_ids
        add_base_type_id( base_class.id )
        add_base_type_id( forEach in base_class.base_type_ids )
      endIf

      if (aspects)
        forEach (a in aspects)
          a.collect_base_type_ids
          add_base_type_id( a.id )
        endForEach
      endIf

    method collect_compounds_and_primitives( type_list:Type[] )
      if (attributes.is_visiting or attributes.is_collected) return
      attributes.is_visiting = true
      (forEach in global_properties).type.collect_compounds_and_primitives( type_list )
      (forEach in properties).type.collect_compounds_and_primitives( type_list )
      if (this.is_compound or this.is_primitive)
        type_list.add( this )
        attributes.is_collected = true
      endIf
      attributes.is_visiting = false

    method collect_reference_types( type_list:Type[] )
      if (attributes.is_visiting or attributes.is_collected) return
      attributes.is_visiting = true  # use as 'is_collected' flag; will be reset externally
      (forEach in global_properties).type.collect_reference_types( type_list )
      (forEach in properties).type.collect_reference_types( type_list )
      if (this.is_reference)
        type_list.add( this )
        attributes.is_collected = true
      endIf
      attributes.is_visiting = false

    method collect_methods( m_name:String, list:Procedure[], &require_global )
      ensure_definition
      organize_methods

      if (not require_global)
        forEach (m in methods.values)
          if (m.name == m_name or m.base_name == m_name) list.add( m )
        endForEach
      endIf

      forEach (m in global_methods.values)
        if (m.name == m_name or m.base_name == m_name) list.add( m )
      endForEach

      if (base_class)
        base_class.collect_methods( m_name, list, &require_global )
      endIf

    method contains_embedded_compound( type:Type )->Logical
      forEach (p in properties)
        if (p.type is type) return true
        if (p.type.is_compound and p.type.contains_embedded_compound(type)) return true
      endForEach
      return false

    method contains_embedded_reference->Logical
      forEach (p in properties)
        if (p.type.is_reference) return true
        if (p.type.is_compound and p.type.contains_embedded_reference) return true
      endForEach
      return false

    method contains_reference->Logical
      return attributes.contains_reference

    method description->String
      return "$" (%name)

    method documentable->Logical
      if (attributes.omit_doc) return false
      if (attributes.is_augment) return false
      if (not class_def) return false

      if (name.begins_with('(')) return false  # (Function...) or (Tuple,...)

      if (name == "Routine")
        forEach (m in global_methods)
          if (not m.attributes.omit_doc and Program.doc_root_prefix(m.t.filepath)) return true
        endForEach
      endIf

      if (not Program.doc_root_prefix(t.filepath)) return false

      if (name.begins_with("_Doc_Gen_"))
        if (not type_template) return false  # this was a dummy type used to generate another type template
        if (name.contains("[][]")) return false
        if (name.contains("[]?")) return false
        if (name.contains("?[]")) return false
        if (not all_template_parameters_are_dummy_values) return false
        return true
      endIf

      if (name.ends_with(']'))
        if (name == "[Rogue::_Doc_Gen_KeyType:Rogue::_Doc_Gen_ValueType]") return true
        return attributes.augmented   # List[]
      endIf
      if (name.ends_with('?')) return false                  # Optional?

      if (name.begins_with("Function_"))
        forEach (ch in name from 9)
          if (not ch.is_number) return true
        endForEach
        return false
      endIf

      if (not type_template) return true
      return all_template_parameters_are_dummy_values

    method doc_type->Type
      if (name.begins_with("Function_") and base_class is not Program.type_Object) return base_class
      if (documentable) return this
      if (name.ends_with(']') and attributes.augmented) return this # augmented List[]
      if (type_template and type_template.doc_type) return type_template.doc_type
      return this

    method ensure_definition
      if (attributes.is_defined) return
      if (not type_template) type_template = library_context.must_find_template( t, name+"<<0>>", name )
      type_template.instantiate( this, type_args )

    method finalize_vtable
      if (is_vtable_finalized) return
      is_vtable_finalized = true

      use vtable = WorkList<<Method>>
        if (base_class)
          base_class.finalize_vtable

          forEach (base_m in base_class.method_vtable)
            local overridden_m = method_vtable[base_m.signature]
            if (not overridden_m) overridden_m = methods[base_m.signature]
            vtable.add( which{overridden_m||base_m} )
          endForEach

          forEach (m in method_vtable)
            # .method_vtable can have abstract methods that are no longer in .methods
            if (not base_class.method_vtable.contains(m.signature))
              vtable.add( m )
            endIf
          endForEach

          forEach (m in methods)
            # Some .methods are not yet in .method_vtable
            if (not base_class.method_vtable.contains(m.signature) and not method_vtable.contains(m.signature))
              vtable.add( m )
            endIf
          endForEach

        else
          vtable.add( forEach in method_vtable.values )
          # .method_vtable can have abstract methods that are no longer in .methods

          forEach (m in methods.values)
            # Some .methods are not yet in .method_vtable
            if (not method_vtable.contains(m.signature)) vtable.add( m )
          endForEach
        endIf

        method_vtable.clear
        forEach (m at i in vtable)
          assert m.vtable_index == -1 or m.vtable_index == i
          m.vtable_index = i
          method_vtable[m.signature] = m
        endForEach

      endUse

    method find_method( signatures:String[] )->Method
      forEach (sig in signatures)
        if local m = methods[ sig ]
          return m
        endIf
      endForEach
      return null

    method has_global_method_named( name:String )->Logical
      forEach (m in global_methods.values)
        if (m.name == name) return true
      endForEach
      return false

    method has_method_named( name:String )->Logical
      forEach (m in methods.values)
        if (m.name == name) return true
      endForEach
      return false

    method incorporate_global( aspect_m:GlobalMethod, &is_augment )
      aspect_m .= cloned
      AspectMethodPatcher.patch( this, aspect_m )

      local existing_m = global_methods[ aspect_m.signature ]
      if (existing_m)
        if (existing_m.return_type? xor aspect_m.return_type?)
          if (existing_m.return_type?)
            throw aspect_m.t.error( "Return type mismatch - existing global method $ does not return a value."...
                (existing_m.context_signature) )
          else
            throw aspect_m.t.error( "Return type mismatch - existing global method $ returns a value."...
                (existing_m.context_signature) )
          endIf
        endIf
        if (existing_m.return_type and existing_m.return_type is not aspect_m.return_type)
          throw aspect_m.t.error( "Return type mismatch - aspect method return type $ does not match existing return type $."...
          (aspect_m.return_type,existing_m.return_type) )
        endIf

        if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append)
          forEach (aspect_p at i in aspect_m.parameters)
            local existing_p = existing_m.parameters[i]
            if (aspect_p.name != existing_p.name)
              throw aspect_m.t.error(
                "Parameter name mismatch - aspect parameter '$' must be named '$' as in the existing method."...
                (aspect_p.name,existing_p.name)
              )
            endIf
          endForEach
        endIf

      endIf

      if (is_augment)
        this.attributes.augmented = true
        aspect_m.attributes.augmented = true
      endIf

      if (existing_m)
        if (is_augment) existing_m.attributes.augmented = true

        existing_m.attributes.flags |= aspect_m.attributes.flags
        if (aspect_m.attributes.is_insert)
          aspect_m.statements.add( forEach in existing_m.statements )
          existing_m.body = aspect_m.body
          existing_m.statements = aspect_m.statements
        elseIf (aspect_m.attributes.is_append)
          existing_m.statements.add( forEach in aspect_m.statements )
        elseIf (existing_m.type_context is not this or (is_augment and this.name!="Routine") or aspect_m.attributes.is_replace)
          global_methods[ aspect_m.signature ] = aspect_m
          aspect_m.attributes.is_global = true
        else
          throw aspect_m.t.error( "Routine $ is already defined. Add attribute [append], [insert], or [replace] to have this definition merge with or replace the previous definition."(aspect_m.signature) )
        endIf

      else
        global_methods[ aspect_m.signature ] = aspect_m
        aspect_m.attributes.is_global = true

      endIf

    method incorporate( aspect_m:Method, &is_augment )
      aspect_m .= cloned
      AspectMethodPatcher.patch( this, aspect_m )

      local existing_m = methods[ aspect_m.signature ]
      if (existing_m)
        if (existing_m.return_type? xor aspect_m.return_type?)
          if (existing_m.return_type?)
            throw aspect_m.t.error( "Return type mismatch - existing method $ does not return a value."...
                (existing_m.context_signature) )
          else
            throw aspect_m.t.error( "Return type mismatch - existing method $ returns a value."...
                (existing_m.context_signature) )
          endIf
        endIf
        if (existing_m.return_type and existing_m.return_type is not aspect_m.return_type)
          throw aspect_m.t.error( "Return type mismatch - aspect method return type $ does not match existing return type $."...
          (aspect_m.return_type,existing_m.return_type) )
        endIf

        if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append)
          forEach (aspect_p at i in aspect_m.parameters)
            local existing_p = existing_m.parameters[i]
            if (aspect_p.name != existing_p.name)
              throw aspect_m.t.error(
                "Parameter name mismatch - aspect parameter '$' must be named '$' as in the existing method."...
                (aspect_p.name,existing_p.name)
              )
            endIf
          endForEach
        endIf

      endIf

      if (is_augment)
        this.attributes.augmented = true
        aspect_m.attributes.augmented = true
      endIf

      if (existing_m)
        if (is_augment) existing_m.attributes.augmented = true

        if (aspect_m.attributes.is_insert and existing_m.type_context is this)
          aspect_m.statements.add( forEach in existing_m.statements )
          existing_m.body = aspect_m.body
          existing_m.statements = aspect_m.statements
        elseIf (aspect_m.attributes.is_append and existing_m.type_context is this)
          existing_m.statements.add( forEach in aspect_m.statements )
        elseIf (existing_m.type_context is not this)
          methods[ aspect_m.signature ] = aspect_m
          aspect_m.overridden_method = existing_m
        elseIf (is_augment)
          methods[ aspect_m.signature ] = aspect_m
          aspect_m.overridden_method = existing_m.overridden_method
        endIf

      else
        methods[ aspect_m.signature ] = aspect_m

      endIf

    method instance_of( ancestor_type:Type )->Logical
      if (ancestor_type is Program.type_Object and this.is_reference) return true
      if (this is ancestor_type) return true

      if (ancestor_type.is_aspect)
        local type = this
        while (type)
          if (type.aspects)
            if ((forEach in type.aspects) is ancestor_type) return true
          endIf
          type .= base_class
        endWhile
        return false
      else
        local type = this
        while (type)
          if (type is ancestor_type) return true

          type .= base_class
        endWhile
        return false
      endIf

    method is_aspect->Logical
      return attributes.is_aspect

    method is_compatible_tuple( other_type:Type )->Logical
      contingent
        this.resolve
        other_type.resolve
        necessary this.m_primary_constructor
        necessary other_type.m_primary_constructor
        local params1 = this.m_primary_constructor.parameters
        local params2 = other_type.m_primary_constructor.parameters
        necessary (params1.count == params2.count)
        forEach (param at i in params1)
          necessary (param.type is params2[i].type)
        endForEach
        return true
      unsatisfied
        return false
      endContingent

    method is_compound->Logical
      return attributes.is_compound

    method is_enum->Logical
      return attributes.is_enum

    method is_integer->Logical
      return this is Program.type_Int or this is Program.type_Int32 or this is Program.type_Int64

    method is_object->Logical
      return attributes.is_object

    method is_optional->Logical
      return attributes.is_optional

    method is_primitive->Logical
      return attributes.is_primitive

    method is_reference->Logical
      return attributes.is_reference

    method is_value_type->Logical
      return attributes.is_primitive or attributes.is_compound

    method name_tokens->Token[]
      if (@name_tokens) return @name_tokens

      localize scoped_name

      use scanner = ObjectPool<<Scanner>>
        scanner.init( scoped_name, scoped_name )
        @name_tokens = scanner.tokenize
        @name_tokens.remove_last  # EOL
        return @name_tokens
      endUse

    method core_type->Type
      # For use with .is_optional types only
      return this.properties//value.type

    method generic_type->Type
      if (this.is_reference) return Program.type_Object
      return this

    method organize
      ensure_definition
      organize_type
      organize_properties
      collect_gc_info
      organize_methods

    method organize_type
      if (is_type_organized) return
      is_type_organized = true

      TypeOrganizer( library_context ).visit( this, class_def )

      if (library_context.attributes.is_essential or library_context.attributes.is_api) attributes.is_essential = true
      if (library_context.attributes.is_api) attributes.is_api = true

      if (is_compound)
        ensure<<aspects>>
        contingent
          sufficient ((forEach in aspects).name == "CommonCompoundMethods")
          aspects.add( Type(t, "CommonCompoundMethods") )
        endContingent
      endIf

      if (is_enum)
        local extended : Type
        contingent
          sufficient (not (base_class or aspects))

          extended = base_class
          if (extended) necessary (not extended.categories)

          if (aspects)
            forEach (a in aspects)
              extended = a
              necessary (not extended.categories)
            endForEach
          endIf

        satisfied
          escapeContingent

        unsatisfied
          throw extended.t.error( "Cannot extend enums with additional categories." )
        endContingent
      endIf

      # Categorize base types
      if (base_class)
        base_class.ensure_definition
        base_class.organize_type
        base_class.extended_types.add( this )
      elseIf (this.is_object and this is not Program.type_Object)
        base_class = Program.type_Object
        base_class.ensure_definition
        base_class.organize_type
        base_class.extended_types.add( this )
      endIf

      if (aspects)
        (forEach in aspects).[ensure_definition, organize_type]

        # Build flat list of incorporated aspects. Each aspect will already have
        # a flat list of its own base aspects.
        use aspect_list = WorkList<<Type>>
          forEach (incorporated_aspect in aspects)
            if (incorporated_aspect.aspects)
              aspect_list.add( incorporated_aspect.aspects )
            endIf
            aspect_list.add( incorporated_aspect )
          endForEach
          aspects.clear
          aspects.add( aspect_list )
        endUse

        (forEach in aspects).extended_types.add( this )
      endIf

      # Check attributes
      if (attributes.is_singleton)
        if (is_aspect)    throw t.error( "Aspects cannot have singletons." )
        if (is_compound)  throw t.error( "Compounds cannot have singletons." )
        if (is_primitive) throw t.error( "Primitives cannot have singletons." )
        attributes.is_anchored = true # any SetSingleton command will disprove this
      endIf

    method organize_properties
      if (properties_organized) return
      properties_organized = true

      organize_type

      PropertyOrganizer( library_context ).visit( this, class_def )

      # Inherit properties
      if (base_class or aspects)
        use my_properties = WorkList<<Property>>
          my_properties.add( forEach in properties )
          properties.clear

          if (base_class)
            base_class.[ ensure_definition, organize_properties ]

            forEach (p in base_class.properties)
              properties[p.name] = p
            endForEach
          endIf

          if (aspects)
            forEach (incorporated_aspect in aspects)
              local is_augment = incorporated_aspect.attributes.is_augment

              incorporated_aspect.[ ensure_definition, organize_properties ]

              if (is_augment)
                forEach (p in incorporated_aspect.global_properties)
                  add_global_property_augment( p.cloned.[type_context=this] )
                endForEach
                incorporated_aspect.global_properties.clear
              endIf

              forEach (p in incorporated_aspect.properties)
                p = p.cloned.[type_context=this]
                if (is_augment) p.attributes.is_augment = true
                add_extended_property( p.cloned.[type_context=this] )
              endForEach
            endForEach
          endIf

          forEach (p in my_properties)
            add_extended_property( p )
          endForEach

        endUse
      endIf

      if (states.count)
        if (properties.contains("state"))
          local p = properties//state
          throw p.t.error( "Because this class contains STATES it cannot have a property named 'state'." )
        else
          local t = states.first.t
          properties//state = Property( t, "state", LiteralInt(t,-1), Program.type_Int ).[ type_context=this ]
        endIf
      endIf

      forEach (p in properties.values)
        if (p.type_context is this)
          p.type.[ ensure_definition, organize_type ]

          if (this.is_compound and p.type.is_compound)
            if (p.type.contains_embedded_compound(this))
              throw p.t.error(
                  "Circular compound definition - $ directly or indirectly contains an embedded $, so $ cannot contain a $."...
                  (p.type,this,this,p.type)
              )
            endIf
          endIf

          local base_p = properties[p.name]
          if (base_p)
            if (not p.type.instance_of(base_p.type))
              throw p.t.error( "Redeclared property '$' has type $ which is not instanceOf inherited type $."...
                (p.name,p.type,base_p.type) )
            endIf
          endIf
        endIf
      endForEach

    method collect_gc_info
      if (gc_info_collected) return
      gc_info_collected = true

      organize_properties

      forEach (pass in 1..2)
        if (base_class and base_class.contains_reference) attributes.contains_reference = true

        if (aspects)
          forEach (a in aspects)
            if (a.contains_reference) attributes.contains_reference = true
          endForEach
        endIf

        forEach (p in global_properties)
          if (p.type.is_reference or (p.type.is_compound and p.type.contains_embedded_reference))
            p.type.attributes.contains_reference = true
          endIf
        endForEach

        forEach (p in properties)
          if (p.type_context is this)
            if (p.type.is_reference or (p.type.is_compound and p.type.contains_embedded_reference))
              attributes.contains_reference = true
            endIf
          endIf
        endForEach

        if (pass == 2) escapeForEach

        if (base_class) base_class.collect_gc_info
        if (aspects)
          (forEach in aspects).collect_gc_info
        endIf
        (forEach in global_properties).type.collect_gc_info
        (forEach in properties).type.collect_gc_info
        forEach (p in properties)
          if (p.type_context is this) p.type.collect_gc_info
        endForEach

        if (contains_reference) escapeForEach
      endForEach

      if (this.instance_of(Program.type_ListType) and this is not Program.type_ListType)
        local p_element_type = properties["element_type"]
        assert p_element_type
        element_type = p_element_type.type
        if (element_type.is_reference)
          attributes.is_reference_list = true
          attributes.contains_reference = true
        elseIf (element_type.contains_reference)
          attributes.contains_reference = true
        endIf
      endIf

      if (this.instance_of(Program.type_Exception))
        exception_type = ExceptionTypes.register( this )
      endIf

    method organize_methods
      if (methods_organizing) return
      methods_organizing = true

      collect_gc_info

      use organizer = ObjectPool<<MethodOrganizer>>
        temporarily organizer.this_library = library_context
          organizer.visit( this, class_def )
        endTemporarily
      endUse

      # Organize base types
      if (base_class) base_class.organize_methods
      if (aspects)
        (forEach in aspects).organize_methods
      endIf

      # Add init_class() for global property initialization
      if (not attributes.is_augment)
        local m = global_methods["init_class()"]
        if (not m)
          m = GlobalMethod( t, this, "init_class" )
          m.attributes.is_global = true
          m.attributes.omit_doc = true
          m.organize
          global_methods[ m.signature ] = m
        endIf
        m_init_class = m

        if (global_properties.count)
          m.attributes.is_essential = true  # init_class()
          use my_properties = WorkList<<Property>>
            my_properties.add( forEach in global_properties )

            forEach (p in my_properties step -1)
              if (not p.initial_value) p.initial_value = p.type.cmd_default_value( p.t )
              m.statements.insert(
                Assign(
                  p.t,
                  ContextAccess(p.t,TypeContext(p.t,this),p.name),
                  p.initial_value
                )
              )
            endForEach
          endUse
        endIf
      endIf

      # Add init_object() methods for new initial property assignments
      if (is_object and not is_aspect)
        local m = methods["init_object()"]
        if (not m)
          m = Method( t, this, "init_object" )
          m.attributes.omit_doc = true
          m.organize
          methods[ m.signature ] = m
        endIf

        use my_properties = WorkList<<Property>>
          forEach (p in properties)
            if (p.type_context is this) my_properties.add( p )
          endForEach

          forEach (p in my_properties step -1)
            if (p.initial_value)
              local initial_value = p.initial_value.cloned
              AspectMethodPatcher.patch( this, initial_value )  # fix 'this' type
              m.statements.insert( Assign(p.t,Access(p.t,p.name),initial_value) )
            endIf
          endForEach
          if (base_class)
            local prior_m = base_class.methods[ "init_object()" ]
            assert prior_m
            m.statements.insert( CallThisStaticMethod(m.t,prior_m,Args(m.t)) )
          endIf
        endUse
      endIf

      inherit_methods

      if (not is_aspect and this is not Program.type_NativeProperty)
        # library_name()->String
        local m = Method( t, this, "library_name" )
        m.attributes.omit_doc = (this is not Program.type_Object)
        m.return_type = Program.type_String
        m.statements.add( Return(t,LiteralString(t,"$"(library_context))) )
        m.organize
        methods[ m.signature ] = m

        # type_name()->String
        m = Method( t, this, "type_name" )
        m.attributes.omit_doc = (this is not Program.type_Object)
        m.return_type = Program.type_String
        m.statements.add( Return(t,
          ContextAccess( t, TypeContext(t,Program.type_Object),
                         "__type_name", Args(t,TypeIndex(t,this)))
        ) )
        m.organize
        methods[ m.signature ] = m

        # type_info_index()->Int
        m = Method( t, this, "type_info_index" )
        m.attributes.omit_doc = (this is not Program.type_Object)
        m.return_type = Program.type_Int
        m.statements.add( Return(t,TypeIndex(t,this)) )
        m.organize
        methods[ m.signature ] = m

        # type_id()->Int
        m = Method( t, this, "type_id" )
        m.attributes.omit_doc = (this is not Program.type_Object)
        m.return_type = Program.type_TypeID
        m.statements.add( Return(t,TypeIndex(t,this)) )
        m.organize
        methods[ m.signature ] = m

      endIf

      # Add state methods
      if (states.count)
        use state_methods = WorkList<<StateMethod>>
          forEach (state in states)
            state_methods.add( StateMethod(state,forEach in state.methods) )
          endForEach

          forEach (sm in state_methods)
            sm.m.library_context = library_context
            sm.m.type_context = this
            sm.m.organize( &skip_add_to_type )
          endForEach

          local has_enter = false
          local has_leave = false
          forEach (sm in state_methods)
            if (sm.m.signature == "ENTER()")
              has_enter = true
              escapeForEach
            endIf
          endForEach
          forEach (sm in state_methods)
            if (sm.m.signature == "LEAVE()")
              has_leave = true
              escapeForEach
            endIf
          endForEach

          if (has_enter)
            block m = methods["ENTER()"]
              if (not m)
                m = Method( t, this, "ENTER" )
                m.organize
                methods[ m.signature ] = m
              endIf
            endBlock
          endIf

          if (has_leave)
            block m = methods["LEAVE()"]
              if (not m)
                m = Method( t, this, "LEAVE" )
                m.organize
                methods[ m.signature ] = m
              endIf
            endBlock
          endIf

          block m = methods["set_state(Rogue::Int)"]
            if (not m)
              m = Method( t, this, "set_state" )
              m.parameters.add( Local(t,"new_state",null,Program.type_Int) )

              local cmd_else : If
              if (has_leave)
                cmd_else = If( t, null, Statements(t,Access(t,"LEAVE")), null )
              endIf

              m.statements.add(
                If( t,
                CompareEQ(t,Access(t,"new_state"),LiteralInt(t,-1)),
                  Statements(t,Assign(t,Access(t,"new_state"),LiteralInt(t,0))),
                  Statements(t,cmd_else)
                )
              )

              m.statements.add( Assign(t,DirectAccess(t,"state"),Access(t,"new_state")) )
              if (has_enter) m.statements.add( Access(t,"ENTER") )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

          while (not state_methods.is_empty)
            use variations = WorkList<<StateMethod,Variations>>
              local state_m = state_methods.remove_last
              variations.add( state_m )
              local existing_m = methods[state_m.m.signature]
              forEach (sm at i in state_methods step -1)
                if (sm.m.signature == state_m.m.signature)
                  state_methods.remove_at( i )
                  variations.add( sm )
                endIf
              endForEach

              variations.reverse

              (forEach in variations).m.generate_body

              # Make sure all variations have the same parameters
              forEach (sm in variations from 1)
                contingent
                  necessary (sm.m.parameters.count == state_m.m.parameters.count)
                  forEach (param at i in sm.m.parameters)
                    local param2 = state_m.m.parameters[i]
                    necessary (param.name == param2.name)
                    necessary (param.type is param2.type)
                  endForEach
                  necessary (sm.m.return_type is state_m.m.return_type)
                unsatisfied
                  throw sm.m.t.error( "Each state's implementation of $() must have consistent parameters and return type."(sm.m.name) )
                endContingent
              endForEach

              # All states must define each method or else a base definition must exist outside of STATES.
              if (not existing_m and variations.count < states.count)
                local m = state_m.m
                throw m.t.error( "Definition of $() missing for some states. Either all states must define $() or a general definition of $() must exist outside of the STATES section." (m.name,m.name,m.name) )
              endIf

              local cmd_case_others : Cmd
              if (existing_m)
                if (existing_m.type_context is this)
                  cmd_case_others = existing_m.statements
                else
                  # Call the prior implementation as the default
                  cmd_case_others = Statements(existing_m.t)
                  local args = Args(existing_m.t)
                  forEach (param in existing_m.parameters)
                    args.add( Access(param.t,param.name) )
                  endForEach
                  cmd_case_others = Statements(existing_m.t)
                  local cmd_call = CallThisStaticMethod( existing_m.t, existing_m, args ) : Cmd
                  if (existing_m.return_type) cmd_call = Return( cmd_call.t, cmd_call )
                  cmd_case_others.add( cmd_call )
                  existing_m = null
                endIf
              else
                cmd_case_others = variations.remove_last.m.statements
              endIf

              # Merge method statements from various states
              local t = which{ existing_m:existing_m.t || state_m.m.t }
              local cmd_cases = WhichCases(t)
              local cmd_which = Which( t, Access(t,"state"), cmd_cases, cmd_case_others )
              forEach (sm in variations)
                local m = sm.m
                local args = Args(m.t)
                args.add( Access(m.t,sm.state_def.name) )
                cmd_cases.add( WhichCase(m.t,args,m.statements) )
              endForEach

              if (not existing_m)
                existing_m = state_m.m
                methods[existing_m.signature] = existing_m
              endIf
              existing_m.body.statements = Statements(t,cmd_which)
              existing_m.statements = existing_m.body.statements
            endUse

          endWhile
        endUse
      endIf

      # Compounds get:
      # - to->String
      # - description->String (calls to->String by default)
      # - print_to(PrintWriter) (prints this->String by default)
      # - operator==
      if (is_compound)
        block m = methods["description()"]
          if (not m)
            m = Method( t, this, "description" )
            m.return_type = Program.type_String
            m.statements.add( Return(t,Access(t,"to<<Rogue::String>>")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        block m = methods["print_to(Rogue::PrintWriter)"]
          if (not m)
            m = Method( t, this, "print_to" )
            m.parameters.add( Local(t,"buffer",Type(t,"Rogue::PrintWriter")) )
            m.statements.add( ContextAccess(t, Access(t,"buffer"), "print", Args(t,Access(t,"to<<Rogue::String>>"))) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        if (not is_enum)
          if (not m_primary_constructor)
            block m_create = global_methods["create()"]
              if (not m_create and has_global_method_named("create"))
                m_create = GlobalMethod( t, this, "create" )
                m_create.return_type = this
                m_create.attributes.is_primary = true
                m_create.statements.add( Return(t, CreateCompound(t,this)) )
                m_primary_constructor = m_create
                m_create.organize
                global_methods[ m_create.signature ] = m_create
              endIf
            endBlock
          endIf

          # Enums get different versions of to->String/to->Object and operator==()
          block m = methods["to<<Rogue::Object>>()"]
            if (not m)
              local boxed_type = Type( t, "Boxed", this )
              m = Method( t, this, "to<<Rogue::Object>>" )
              m.return_type = boxed_type
              m.statements.add( Return(t,TypeAccess(t,boxed_type,Args(t,This(t,this)))) )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

          block m = methods["to<<Rogue::String>>()"]
            if (not m)
              m = Method( t, this, "to<<Rogue::String>>" )
              m.return_type = Program.type_String

              local n = 0
              if ((forEach in properties).type is not Program.type_NativeProperty) ++n

              if (n == 0)
                m.statements.add( Return(t,LiteralString(t,"()")) )
              else
                local format = "($"
                format += ",$" * (n-1)
                format += ')'
                local args = Args(t)
                forEach (property in properties)
                  if (property.type is not Program.type_NativeProperty)
                    args.add( Access(t, property.name) )
                  endIf
                endForEach
                m.statements.add( Return(t,FormattedString(t,format,args)) )
              endIf
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

          block m = methods["operator==($::$)"(library_context,name)]
            if (not m)
              m = Method( t, this, "operator==" )
              m.parameters.add( Local(t,"other",null,this) )
              m.return_type = Program.type_Logical
              m.statements.add( Return(t,
                  NativeExpression( t, "0 == memcmp(&$this,&$other,sizeof($<<this>>))", Program.type_Logical )
              ) )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

        endIf
      endIf

      # Enums
      if (is_enum)
        # create(Int) constructor
        block
          local m = GlobalMethod( t, this, "create" )
          m.parameters.add( Local(t,"value",Program.type_Int) )
          m.return_type = this
          m.statements.add( Return(t, CreateCompound(t,this)) )
          m.attributes.is_primary = true
          m.attributes.is_global = true
          m.organize
          global_methods[ m.signature ] = m
        endBlock

        # create(String) constructor
        block
          local m = GlobalMethod( t, this, "create" )
          m.parameters.add( Local(t,"name",Program.type_String) )
          m.return_type = this
          m.statements.add(
            ForEach( t,
            ForEachInControl( t, "category", null, null,
                ForEachCollection(t,null,Access(t,"categories"),null,null) ),
              Statements( t,
                If( t, CompareEQ(t,Access(t,"name"),Access(t,"category")),
                  Statements( t, Return(t,Access(t,"category")) ), null
                )
              )
            )
          )
          m.statements.add( Return(t,TypeAccess(t,this,Args(t,LiteralInt(t,0)))) )
          m.attributes.is_global = true
          m.organize
          global_methods[ m.signature ] = m
        endBlock

        # operator?()->Logical
        block
          local m = methods[ "operator?()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "operator?" )
            m.return_type = Program.type_Logical
            m.statements.add( Return(t,Logicalize(t,Access(t,"value"))) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # name()->String
        block
          local m = Method( t, this, "name" )
          m.return_type = Program.type_String

          local cmd_cases = WhichCases(t)
          local cmd_which = Which( t, This(t,this), cmd_cases, Statements(t) )
          forEach (category in categories)
            local t = category.t
            local args = Args(t)
            args.add( Access(t,category.name) )
            cmd_cases.add( WhichCase(t,args,Statements(t,Return(t,LiteralString(t,category.name)))) )
          endForEach
          cmd_which.statements.add( Return(t,FormattedString(t,name+"($)",Args(t,Access(t,"value")))) )
          m.statements.add( cmd_which )

          m.organize
          methods[ m.signature ] = m
        endBlock

        # operator==(EnumType)->Logical
        block
          local m = methods[ "operator==($)"(scoped_name) ]
          if (not m)
            m = Method( t, this, "operator==" )
            m.parameters.add( Local(t,"other",this) )
            m.return_type = Program.type_Logical
            m.statements.add( Return(t,CompareEQ(t,Access(t,"value"),ContextAccess(t,Access(t,"other"),"value"))) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # to->Int
        block
          local m = methods[ "to<<Rogue::Int>>()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "to<<Rogue::Int>>" )
            m.return_type = Program.type_Int
            m.statements.add( Return(t,Access(t,"value")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # hashcode->Int
        block
          local m = methods[ "hashcode()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "hashcode" )
            m.return_type = Program.type_Int
            m.statements.add( Return(t,Access(t,"value")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # to->String
        block
          local m = methods[ "to<<Rogue::String>>()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "to<<Rogue::String>>" )
            m.return_type = Program.type_String

            local cmd_cases = WhichCases(t)
            local cmd_which = Which( t, This(t,this), cmd_cases, Statements(t) )
            forEach (category in categories)
              local t = category.t
              local args = Args(t)
              args.add( Access(t,category.name) )
              cmd_cases.add( WhichCase(t,args,Statements(t,Return(t,LiteralString(t,category.name)))) )
            endForEach
            cmd_which.statements.add( Return(t,FormattedString(t,name+"($)",Args(t,Access(t,"value")))) )
            m.statements.add( cmd_which )

            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        block m = methods["to<<Rogue::Object>>()"]
          if (not m)
            m = Method( t, this, "to<<Rogue::Object>>" )
            m.return_type = Program.type_Object
            m.statements.add( Return(t,Access(t,"to<<Rogue::String>>")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # Create a getter method with hard-coded results for each property of each category
        block
          forEach (p at i in class_def->(as Class).constructor_properties)
            if (not p.type) throw p.t.error( "Enum property '$' must specify a ':Type'."(p.name) )
            local m = Method( t, this, p.name )
            m.return_type = p.type

            local cmd_cases = WhichCases(t)
            local cmd_which = Which( t, This(t,this), cmd_cases, Statements(t) )
            forEach (category in categories)
              if (category.args[i])
                local args = Args(category.t)
                args.add( Access(category.t,category.name) )
                cmd_cases.add( WhichCase(category.t,args,Statements(category.t,Return(category.t,category.args[i]))) )
              endIf
            endForEach
            if (p.initial_value)
              cmd_which.statements.add( Return(p.t,p.initial_value) )
            else
              cmd_which.statements.add( Return(p.t,p.type.cmd_default_value(p.t)) )
            endIf
            m.statements.add( cmd_which )

            m.organize
            methods[ m.signature ] = m
          endForEach
        endBlock

        if (attributes.bitflags)
          # Each CATEGORY_NAME gets .category_name()->Logical and .set_category_name(setting:Logical) methods.
          forEach (category in categories)
            # .category_name()->Logical
            block
              local m_name = category.name.to_lowercase
              local m = methods[ "$()"(m_name) ]
              if (not m)
                m = Method( t, this, m_name )
                m.return_type = Program.type_Logical
                m.statements.add(
                  Return( t,
                    Logicalize( t,
                      BitwiseAnd( t, Access(t,"value"), EnumValue(t,this,category.name) )
                    )
                  )
                )
                m.organize
                methods[ m.signature ] = m
              endIf
            endBlock

            # .set_category_name(Logical)
            block
              local m_name = "set_" + category.name.to_lowercase
              local m = methods[ "$(Rogue::Logical)"(m_name) ]
              if (not m)
                m = Method( t, this, m_name )
                m.attributes.is_mutating = true
                m.parameters.add( Local(t,"setting",Program.type_Logical) )
                m.statements.add(
                  If( t, Access(t,"setting"),
                    Statements( t, BitwiseOrAndAssign(t, Access(t,"value"), EnumValue(t,this,category.name)) ),
                    Statements( t, If( t, null,
                      Statements( t, BitwiseAndAndAssign(t, Access(t,"value"), BitwiseNot(t,EnumValue(t,this,category.name))) ),
                      null ) )
                  )
                )
                m.organize
                methods[ m.signature ] = m
              endIf
            endBlock
          endForEach

          # operator&(EnumType)->EnumType
          block
            local m = methods[ "operator&($)"(scoped_name) ]
            if (not m)
              m = Method( t, this, "operator&" )
              m.parameters.add( Local(t,"flag",this) )
              m.return_type = this
              m.statements.add(
                Return( t,
                  TypeAccess( t, this,
                    Args( t,
                      BitwiseAnd( t, Access(t,"value"), ContextAccess(t,Access(t,"flag"),"value") )
                    )
                  )
                )
              )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

          # operator|(EnumType)->EnumType
          block
            local m = methods[ "operator|($)"(scoped_name) ]
            if (not m)
              m = Method( t, this, "operator|" )
              m.parameters.add( Local(t,"flag",this) )
              m.return_type = this
              m.statements.add(
                Return( t,
                  TypeAccess( t, this,
                    Args( t,
                      BitwiseOr( t, Access(t,"value"), ContextAccess(t,Access(t,"flag"),"value") )
                    )
                  )
                )
              )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

          # operator!()->EnumType
          block
            local m = methods[ "operator!()" ]
            if (not m)
              m = Method( t, this, "operator!" )
              m.return_type = this
              m.statements.add( Return(t,TypeAccess(t,this,Args(t,BitwiseNot(t,Access(t,"value"))))) )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock

        endIf

      endIf

      block
        local m = methods["on_cleanup()"]
        if (m and m.return_type)
          throw m.t.error( "on_cleanup() cannot return a value." )
        endIf
        if (base_class)
          local prior_m = base_class.methods[ "on_cleanup()" ]
          if (prior_m and prior_m is not m)
            # on_cleanup() auto-calls prior.on_cleanup() after other statements
            m.statements.add( CallThisStaticMethod(m.t,prior_m,Args(m.t)) )
          endIf
        endIf
      endBlock

      forEach (m in global_methods.values)
        if (methods.contains(m.signature))
          throw m.t.error( "Duplicate definitions of $ as both a global method and an object method."(m) )
        endIf
      endForEach

      # Add object methods to dynamic method table
      forEach (m in methods.values) m.dynamic_signature  # Each method adds itself

      TransformInlineForEach().visit_type( this )

      if (not is_aspect)
        forEach (pattern in Program.api_patterns)
          contingent
            if (pattern.contains("::"))
              necessary (FilePattern(pattern).matches(scoped_name))
            else
              necessary (FilePattern(pattern).matches(name))
            endIf
          satisfied
            this.attributes.is_api = true
            this.attributes.is_essential = true
          endContingent
        endForEach
      endIf

      # Any [essential] routine makes class Routine [essential] as well
      if (this.name == "Routine")
        forEach (r in global_methods.values)
          if (r.attributes.is_essential or r.attributes.is_api)
            this.attributes.is_essential = true
            escapeForEach
          endIf
        endForEach
      endIf

      if (attributes.is_singleton)
        local m = methods["init()"]
        if (m) m.attributes.is_essential = true
      endIf

      if (attributes.is_api)
        forEach (m in global_methods.values)
          if (m is not m_init_class) m.attributes.is_essential = true
        endForEach
        (forEach in methods.values).attributes.is_essential = true
      endIf

      methods_organized = true

    method inherit_methods( &missing_only )
      # Inherit base class methods
      if (base_class)
        local has_init = false
        forEach (m in methods.values)
          if (m.name == "init")
            has_init = true
            escapeForEach
          endIf
        endForEach

        forEach (base_m in base_class.methods.values)
          local m = methods[ base_m.signature ]

          if (has_init and base_m.name == "init")
            if (m) m.overridden_method = base_m
            nextIteration
          endIf

          if (m)
            if (m.return_type? xor base_m.return_type?)
              if (m.return_type?)
                throw m.t.error( "Return type mismatch - overridden method $ does not return a value."(base_m.context_signature) )
              else
                throw m.t.error( "Return type mismatch - overridden method $ returns a value."(base_m.context_signature) )
              endIf
            endIf

            if (m.return_type)
              m.return_type.organize
              base_m.return_type.organize
              if (not m.return_type.instance_of(base_m.return_type))
                throw m.t.error( "Return type mismatch - override return type $ is not instanceOf overridden return type $."...
                  (m.return_type,base_m.return_type) )
              endIf
            endIf

            m.overridden_method = base_m
          else
            if (base_m.attributes.is_propagated)
              # 'ThisType' -> (actual type)
              add( base_m.propagated_to(this).[overridden_method=m] )
            else
              add( base_m )
            endIf
          endIf
        endForEach
      endIf

      local this_is_abstract = this.attributes.is_abstract

      # Incorporate aspect/augment global methods
      if (aspects)
        # Merge method templates.
        if (not this.attributes.is_augment)
          forEach (incorporated_aspect in aspects)
            forEach (entry in incorporated_aspect.global_method_templates.entries)
              forEach (template in entry.value)
                global_method_templates.add( entry.key, template )
              endForEach
            endForEach
            forEach (entry in incorporated_aspect.method_templates.entries)
              forEach (template in entry.value)
                method_templates.add( entry.key, template.cloned.[type_context=this] )
              endForEach
            endForEach
          endForEach
        endIf

        # Incorporate non-insert, non-append, non-replace methods first
        forEach (incorporated_aspect in aspects)
          if (incorporated_aspect.attributes.is_augment)
            forEach (aspect_m in incorporated_aspect.global_methods.values)
              if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append or aspect_m.attributes.is_replace))
                if (not missing_only or not global_methods.contains(aspect_m.signature))
                  if (this_is_abstract or not aspect_m.attributes.is_abstract)
                    incorporate_global( aspect_m, &is_augment )
                  endIf
                endIf
              endIf
            endForEach
          endIf
        endForEach

        # Incorporate [insert], [append], and [replace] methods
        forEach (incorporated_aspect in aspects)
          if (incorporated_aspect.attributes.is_augment)
            forEach (aspect_m in incorporated_aspect.global_methods.values)
              if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append or aspect_m.attributes.is_replace)
                if (not missing_only or not global_methods.contains(aspect_m.signature))
                  if (this_is_abstract or not aspect_m.attributes.is_abstract)
                    incorporate_global( aspect_m )
                  endIf
                endIf
              endIf
            endForEach
          endIf
        endForEach

        # Create an error if no implementation of an abstract aspect method has been supplied.
        if (not this_is_abstract)
          forEach (incorporated_aspect in aspects)
            forEach (aspect_m in incorporated_aspect.global_methods.values)
              if (aspect_m.attributes.is_abstract and not global_methods.contains(aspect_m.signature))
                throw aspect_m.t.error(
                "Illegal abstract global method $ in class $." (aspect_m,this) )
              endIf
            endForEach
          endForEach
        endIf
      endIf

      # Incorporate aspect/augment object methods
      if (aspects)
        # Incorporate non-insert, non-append, non-replace methods first
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods.values)
            if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append or aspect_m.attributes.is_replace))
              if (not missing_only or not methods.contains(aspect_m.signature))
                if (this_is_abstract or not aspect_m.attributes.is_abstract)
                  if (aspect_m.parameters.count == 0 and aspect_m.name == "init_object")
                    if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append))
                      throw aspect_m.t.error(
                      "In aspects and augments, init_object() must be declared either [append] or [insert]. For example, 'method init_object [append]'."
                      )
                    endIf
                  endIf
                  incorporate( aspect_m, &is_augment=incorporated_aspect.attributes.is_augment )
                endIf
              endIf
            endIf
          endForEach
        endForEach

        # Incorporate [insert], [append], and [replace] methods
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods.values)
            if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append or aspect_m.attributes.is_replace)
              if (not missing_only or not methods.contains(aspect_m.signature))
                if (this_is_abstract or not aspect_m.attributes.is_abstract)
                  incorporate( aspect_m )
                endIf
              endIf
            endIf
          endForEach
        endForEach

        forEach (m in methods)
          if (m.method_template and m.type_context is not this)
            instantiate_overriding_template( m )
          endIf
        endForEach

        # Create an error if no implementation of an abstract aspect method has been supplied.
        if (not this_is_abstract)
          forEach (incorporated_aspect in aspects)
            forEach (aspect_m in incorporated_aspect.methods.values)
              if (aspect_m.attributes.is_abstract and not methods.contains(aspect_m.signature))
                throw aspect_m.t.error(
                  "Class $ must either be declared [abstract] or else supply a definition for abstract aspect method $." ...
                  (this,aspect_m) )
              endIf
            endForEach
          endForEach
        endIf
      endIf

      # Inherit method templates
      if (base_class)
        forEach (key in base_class.method_templates.keys)
          if (not this.method_templates.contains(key))
            forEach (template in base_class.method_templates[key])
              this.method_templates.add( key, template )
            endForEach
          endIf
        endForEach
      endIf

      if (not this.is_aspect)
        # Verify that every [override] method is indeed overriding a prior method.
        forEach (m in methods.values)
          if (m.attributes.is_override)
            if (not m.overridden_method)
              throw m.t.error( "Method $.$ does not override any prior definition. Check for signature type errors or remove the [override] attribute."(m.type_context,m) )
            endIf
          endIf
        endForEach

        forEach (m in global_methods.values)
          if (m.attributes.is_override)
            throw m.t.error( "A global method cannot [override] a prior definition." )
          endIf
        endForEach
      endIf

      # Any [abstract] methods require an [abstract] class.
      if (not this.attributes.is_abstract)
        forEach (m in methods.values)
          if (m.attributes.is_abstract)
            if (m.type_context is this)
              throw m.t.error( "Method $ can only be declared [abstract] in an [abstract] class."(m) )
            else
              throw m.t.error( "Inherited abstract method $.$ must be overridden or class $ must be declared [abstract]."...
                               (m.type_context,m,this) )
            endIf
          endIf
        endForEach

        forEach (m in global_methods.values)
          if (m.attributes.is_abstract)
            throw m.t.error( "Global methods cannot be [abstract]." )
          endIf
        endForEach
      endIf

    method inject_inherited_method( m:Method )
      if (methods_organized)
        local sig = m.signature
        if (not methods.contains(sig))
          if (not instantiate_overriding_template(m))
            method_template_instances.add( m.name )
            if (m.attributes.is_propagated)
              methods[sig] = m.propagated_to( this )
            else
              methods[sig] = m
            endIf
            (forEach in extended_types).inject_inherited_method( m )
          endIf
        endIf
      endIf

    method instantiate_doc_method_templates
      if (this.attributes.is_augment) return

      forEach (template_set in global_method_templates)
        forEach (m_template in template_set)
          local args = TemplateArgs( m_template.t )
          forEach (placeholder in m_template.placeholders)
            local placeholder_t = library_context.create_placeholder_data_type( placeholder->(as Placeholder).t ).t
            args.add( TokenList( m_template.t, [placeholder_t] ) )
          endForEach
          if (not global_method_template_instances.contains(args->String(m_template.name)))
            m_template.instantiate( args, this )
          endIf
        endForEach
      endForEach

      forEach (t_name in method_templates.keys)
        local template_set = method_templates[t_name]
        local m_template = template_set.first
        local args = TemplateArgs( m_template.t )
        forEach (placeholder in m_template.placeholders)
          local placeholder_t = library_context.create_placeholder_data_type( placeholder->(as Placeholder).t ).t
          args.add( TokenList( m_template.t, [placeholder_t] ) )
        endForEach
        if (not method_template_instances.contains(args->String(m_template.name)))
          instantiate_object_method_templates( t_name, args )
        endIf
      endForEach

    method instantiate_object_method_templates( t_name:String, template_args:TemplateArgs )
      # Drill down to start at the oldest ancestor class with a compatible method template
      local root_type : Type
      if (this.method_templates.contains(t_name)) root_type = this

      local base_type = base_class
      while (base_type)
        if (base_type.method_templates.contains(t_name)) root_type = this
        base_type .= base_class
      endWhile

      if (root_type)
        (forEach in root_type.method_templates[t_name]).instantiate( template_args )
      endIf

    method instantiate_overriding_template( m:Method )->Logical
      # Instantiate an overriding method template if it exists
      local group = method_templates[ "$<<$>>"(m.method_template.name,m.method_template.placeholders.count) ]
      if (not group or group.is_empty) return false
      if (group.first.type_context is not this) return false

      forEach (template in group)
        template.instantiate( m.template_args )
      endForEach
      return true

    method precision_index->Int
      return PRECISION_OBJECT

    method resolve
      if (is_resolved) return

      use resolver = ObjectPool<<Resolver>>
        temporarily resolver.this_library=library_context, resolver.this_procedure=null
          resolver.visit_type( this )
        endTemporarily
      endUse

    method scoped_name->String
      if (@scoped_name) return @scoped_name

      if (name.begins_with('(') or name.begins_with('['))
        # Type names beginning with ( are (tuples) or (Functions)
        # Type names beginning with [ are [KeyType:ValueType] tables
        # Neither use an explicit scope.
        @scoped_name = name
      else
        local builder = String()
        builder.print library_context.name
        builder.print "::"
        builder.print name
        @scoped_name = builder
      endIf

      return @scoped_name

    method to->Character
      return Cmd.to_character(name)


    method to->Int:     return name
    method to->Logical: return name?

    method to->String: return name

endClass

class StateMethod( state_def:StateDef, m:Method ) [compound]
  METHODS
    method to->String
      return "StateMethod($,$,$)"(%state_def,m,%m.body)
endClass

class BuiltInType : Type;

class TypeLogical : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Logical", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_LOGICAL
endClass

class TypeByte : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Byte", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_BYTE
endClass

class TypeCharacter : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Character", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_CHARACTER
endClass

class TypeInt32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int32", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_INT32
endClass

class TypeInt : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_INT
endClass

class TypeInt64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int64", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_INT64
endClass

class TypeReal32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real32", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_REAL32
endClass

class TypeReal : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_REAL
endClass

class TypeReal64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real64", Attribute.PRIMITIVE )

    method precision_index->Int
      return PRECISION_REAL64
endClass

class TypeString : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "String", Attribute.OBJECT )
endClass
