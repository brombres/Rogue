$include "Definition.rogue"

class Type
  PROPERTIES
    t               : Token
    name            : String
    attributes      = Attributes()
    index           = -1

    source_template : Template
    specializers    : TypeSpecializer[]

    defined           : Logical
    organized         : Logical
    organizing        : Logical
    resolved          : Logical
    culled            : Logical

    base_class         : Type
    base_types         = Type[]
    extended_types     = Type[]

    is_array     : Logical
    is_list      : Logical
    is_optional  : Logical
    element_type : Type

    is_used      : Logical

    simplify_name : Logical
      # RogueInt32 instead of RoguePrimitiveInt32, etc. - used for classes that are predefined
      # in the infrastructure and that developers will often use directly.

    definition_list   = Definition[]
    definition_lookup = Table<<String,Definition>>()
    prev_enum_cmd     : Cmd
    next_enum_offset  = 0

    global_list   = Property[]
    global_lookup = Table<<String,Property>>() : Table<<String,Property>>

    property_list   = Property[]
    property_lookup = Table<<String,Property>>() : Table<<String,Property>>

    global_method_list          = Method[]                   : Method[]
    global_method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    global_method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    dynamic_method_table_index : Int32

    callback_parameter_types : Type[]
    callback_return_type     : Type

    method_templates = MethodTemplates(this)

    dependencies : CmdStatementList

  METHODS
    method init( t, name )

    method add_method( m_t:Token, m_name:String )->Method
      return add_method( Method(m_t, this, m_name) )

    method add_method( m:Method )->Method
      method_list.add( m )
      local list = method_lookup_by_name[ m.name ]
      if (not list)
        list = Method[]
        method_lookup_by_name[ m.name ] = list
      endIf
      list.add( m )

      return m

    method replace_method( existing:Method, m_t:Token, m_name:String )->Method
      local m = Method( m_t, this, m_name )
      m.index = existing.index
      method_list[ m.index ] = m
      local list = method_lookup_by_name[ m_name ]
      list.remove( existing )
      list.add( m )
      return m

    method add_global_method( r_t:Token, r_name:String )->Method
      return add_global_method( Method(r_t, this, r_name) )

    method add_global_method( m:Method )->Method
      m.attributes.add( Attribute.is_global )

      if (organized and not organizing) inject_global_method( m ); return m

      global_method_list.add( m )
      local list = global_method_lookup_by_name[ m.name ]
      if (not list)
        list = Method[]
        global_method_lookup_by_name[ m.name ] = list
      endIf
      list.add( m )

      return m

    method add_global( s_t:Token, s_name:String )->Property
      local s = Property( s_t, this, s_name )
      global_list.add( s )
      global_lookup[s_name] = s
      return s

    method add_property( p_t:Token, p_name:String, p_type=null:Type, initial_value=null:Cmd )->Property
      return add_property( Property(p_t, this, p_name, p_type, initial_value) )

    method add_property( p:Property )->Property
      property_list.add( p )
      property_lookup[p.name] = p
      return p

    method collect_type_info( info:Int32[] )
      info.add( 0 )  # allocator 0

      if (is_primitive)
        info.add( 0 )
      else
        info.add( dynamic_method_table_index )
      endIf

      local flat_base_types = Type[]
      if (base_class) base_class.collect_base_types( flat_base_types )
      forEach (base_type in base_types)
        base_type.collect_base_types( flat_base_types )
      endForEach

      info.add( flat_base_types.count )
      forEach (base_type in flat_base_types) info.add( base_type.index )

      info.add( global_list.count )
      forEach (p in global_list) info.add( Program.add_literal_string(p.name) )
      forEach (p in global_list) info.add( p.type.index )

      info.add( property_list.count )
      forEach (p in property_list) info.add( Program.add_literal_string(p.name) )
      forEach (p in property_list) info.add( p.type.index )

    method compile_type->Type
      return this

    method create_default_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method create_flag_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method dispatch( v:Visitor )
      v.visit( this )

    method extends_object->Logical
      return instance_of( Program.type_Object )

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m) return m

      return find_global_method( signature )

    method find_global_method( signature:String )->Method
      local m = global_method_lookup_by_signature[signature]
      if (m) return m

      return null

    method find_property( p_name:String )->Property
      if (p_name[0] == '@') p_name = p_name.rightmost(-1)
      return property_lookup[p_name]

    method find_global( s_name:String )->Property
      if (s_name[0] == '@') s_name = s_name.rightmost(-1)
      return global_lookup[s_name]

    method has_extended_class->Logical
      return extended_types.count?

    method has_method_named( m_name:String )->Logical
      local list = method_lookup_by_name[m_name]
      if (list and list.count) return true

      return has_global_method_named( m_name )

    method has_global_method_named( m_name:String )->Logical
      local list = global_method_lookup_by_name[m_name]
      return (list and list.count)

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true
      if (this is Program.type_null and ancestor_type.is_reference) return true
      if (this.is_reference and ancestor_type is Program.type_Object) return true

      forEach (base_type in base_types)
        if (base_type.instance_of(ancestor_type)) return true
      endForEach

      return false

    method is_compatible_with( other:Type )->Logical
      if (this is other) return true
      if (this.is_primitive and other.is_primitive)
        if (this is Program.type_Logical xor other is Program.type_Logical) return false
        return true
      endIf
      if (other.is_optional)
        if (other.element_type is this) return true
        if (this is Program.type_null) return true
      endIf
      if (this.is_aspect and other is Program.type_Object) return true
      return (this.instance_of(other))

    method is_real->Logical
      return this is Program.type_Real64 or this is Program.type_Real32

    method widening_distance_to( other:Type )->Int32
      if (this is other) return 0
      if (this.is_primitive and other.is_primitive)
        return other.primitive_rank - this.primitive_rank
      endIf
      if (other.is_optional)
        if (other.element_type is this) return 1
        if (this is Program.type_null) return 1
      endIf
      if (this.is_aspect and other is Program.type_Object) return 1

      if (this is Program.type_null and other.is_reference) return 1

      forEach (base_type in base_types)
        if (base_type.instance_of(other)) return 1 + base_type.widening_distance_to( other )
      endForEach

      if (this.is_reference and other is Program.type_Object) return 1

      return -10

    method is_equivalent_or_more_specific_than( other:Type )->Logical
      if (this is other) return true
      if (this.is_primitive and other.is_primitive)
        return this.primitive_rank >= other.primitive_rank
      endIf
      if (this.instance_of(other)) return true
      if (other.is_list and other.element_type is this) return true
      return false

    method is_direct->Logical
      return not is_reference

    method is_aspect->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_aspect

    method is_class->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_class

    method is_compound->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_compound

    method is_immutable->Logical
      return (attributes.flags & Attribute.is_immutable)

    method is_native->Logical
      return (attributes.flags & Attribute.is_native)

    method is_primitive->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_primitive

    method is_reference->Logical
      which (attributes.flags & Attribute.type_mask)
        case Attribute.is_class, Attribute.is_aspect
          return true
        others
          return false
      endWhich

    method is_requisite->Logical
      return (attributes.flags & Attribute.is_requisite)

    method is_routine->Logical
      return (attributes.flags & Attribute.is_routine)

    method is_singleton->Logical
      return (attributes.flags & Attribute.is_singleton)

    method is_special->Logical
      return (attributes.flags & Attribute.is_special)

    method make_requisite->this
      attributes.add( Attribute.is_requisite )
      return this

    method organize( scope=null:Scope )->Type
      if (organized) return this
      organized = true
      organizing = true

      index = Program.type_list.count
      Program.type_list.add( this )

      if (not defined)
        defined = true
        local template = Program.find_template( name )
        if (template)
          template.instantiate( this, scope )
        else
          throw t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      forEach (base_type in base_types)
        base_type.organize( scope )

        if (not base_type.is_aspect)
          if (is_aspect)
            throw t.error( "Aspects can only extend other aspects." )
          elseIf (is_compound)
            throw t.error( "Compounds can only extend aspects." )
          endIf
        endIf

        if (base_type.instance_of(this))
          throw t.error( "Cyclic inheritance attempted - $ cannot extend $ because $ already extends $." ...
              (this,base_type,base_type,this) )
        endIf
      endForEach

      if (is_class)
        forEach (base_type in base_types)
          if (base_type.is_class)
            if (base_class and base_class isNot base_type)
              throw t.error( "Class $ can only have one base class ($ and $ are both specified as base classes)." (name,base_class,base_type) )
            else
              base_class = base_type
            endIf
          endIf
        endForEach

        if (not base_class and this isNot Program.type_Object)
          Program.type_Object.organize
          base_class = Program.type_Object
          base_types.insert( base_class )
        endIf
      endIf

      if (base_class) base_types.insert( base_types.remove(base_class) )

      # Mark classes that are extended
      forEach (base_type in base_types)
        base_type.extended_types.add( this )
      endForEach

      # Organize properties
      if (element_type) element_type.organize

      forEach (s in global_list) s.type.organize

      forEach (p in property_list)
        p.type.organize
      endForEach


      # Inherit definitions
      forEach (base_type in base_types)
        inherit_definitions( base_type )
      endForEach

      # Inherit properties
      local full_property_list = Property[]
      property_lookup.clear
      inherit_properties( full_property_list, property_lookup )
      property_list = full_property_list

      create_introspection_methods( scope )

      inherit_methods( scope )

      # Clear base_types list for compounds - they can incorporate aspects for
      # modularization but compounds are not polymorphic.
      if (this.is_compound) base_types.clear

      # Mark any existing init_class() as requisite
      local m_init_class = find_global_method( "init_class()" )
      if (m_init_class)
        if (m_init_class.type_context is this)
          m_init_class.make_requisite
        endIf
      else
        m_init_class = find_method( "init_class()" )
        if (m_init_class)
          throw m_init_class.t.error( "$::init_class() must be declared under GLOBAL METHODS." (name) )
        endIf
      endIf

      if (global_list.count)
        # Create or locate init_class() to initialize global properties
        local m = find_global_method( "init_class()" )
        if (not m or m.type_context isNot this) m = add_global_method( t, "init_class" ).organize( scope )
        m.make_requisite

        # Insert global initializations
        local i = global_list.count - 1
        while (i >= 0)
          local s = global_list[i]
          if (s.initial_value)
            m.statements.insert( CmdWriteGlobal(s.t, s, s.initial_value.cloned) )
          endIf
          --i
        endWhile
      endIf

      # Create or find init_object() method to initialize properties
      if (is_class and not is_native)
        local m = find_method( "init_object()" )
        local prior_m = m
        if (m and m.type_context is this)
          m.make_requisite
        else
          m = add_method( t, "init_object" ).organize( scope )
          m.make_requisite

          # The regular system won't figure out that init_object() is
          # dynamically called so give it a flag.
          m.attributes.add( Attribute.is_dynamic )

          if (prior_m)
            method_list.remove( m )
            method_list[ method_list.locate( prior_m ).value ] = m
            method_lookup_by_name[ m.name ].remove( prior_m )
            method_lookup_by_signature[ m.signature ] = m
            m.overridden_method = prior_m
            prior_m.overriding_methods.add( m )
          endIf
        endIf
        m.return_type = this
        if (m.overridden_method)
          m.statements.insert( CmdCallPriorMethod(t, "init_object", null, null) )
        endIf
        m.statements.add( CmdReturn(t,CmdLiteralThis(t,this)) )

        # Insert property initializations
        local i = property_list.count - 1
        while (i >= 0)
          local p = property_list[i]
          if (p.initial_value and p.type_context is this)
            m.statements.insert( CmdWriteProperty(p.t, CmdLiteralThis(p.t,p.type_context), p, p.initial_value.cloned) )
          endIf
          --i
        endWhile

        m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
      endIf

      # Mark any clean_up() method as requisite
      if (is_class and not is_native)
        local m = find_method( "clean_up()" )
        if (m and m.type_context is this)
          if (m.return_type)
            throw m.t.error( "clean_up() cannot return a value." )
          endIf
          m.make_requisite
        endIf
      endIf

      # to->String is requisite for Exception and extended classes
      if (is_class and instance_of(Program.type_Exception))
        local m = find_method( "to_String()" )
        if (m) m.make_requisite
      endIf

      # Add a default to->String to compounds
      if (is_compound or is_primitive)
        local m = find_method( "to_String()" )
        if (not m)
          m = add_method( t, "to_String" )
          m.return_type = Program.type_String
          m.statements.add( CmdReturn(t,CmdLiteralString(t,"($)"(name))) )
          m.organize( scope )
        endIf
      endIf

      # Add a default to->Object to compounds, primitives, and functional types
      if (is_aspect)
        forEach (p in property_list)
          local m = find_method( p.name + "()" )
          if (not m)
            m = add_method( p.t, p.name )
            m.attributes.add( Attribute.is_fallback )
            m.return_type = p.type
            m.statements.add( CmdReturn(p.t,CmdAccess(p.t,"@"+p.name)) )
            m.organize( scope )
          endIf

          m = find_method( "set_$($)" (p.name,p.type) )
          if (not m)
            m = add_method( p.t, "set_" + p.name )
            m.add_parameter( p.t, "@"+p.name )
            m.attributes.add( Attribute.is_fallback )
            m.return_type = this
            m.statements.add( CmdReturn(p.t,CmdLiteralThis(p.t, this)) )
            m.organize( scope )
          endIf
        endForEach
      endIf

      if (this isNot Program.type_NativeArray)
        is_array = this.instance_of( Program.type_NativeArray )
        if (is_array)
          local cur_type = this
          while (not cur_type.name.begins_with("Array<<"))
            cur_type = cur_type.base_class
            if (cur_type is null) throw t.error( "A class that is instanceOf NativeArray must also be instanceOf Array<<DataType>>." )
          endWhile

          local element_type_name = cur_type.name.after_first("<<").before_last(">>")
          element_type = Program.get_type_reference( t, element_type_name ).organize( scope )
        endIf
      endIf

      index_and_move_inline_to_end( global_method_list )
      index_and_move_inline_to_end( method_list )

      organizing = false

      return this

    method primitive_rank->Int32
      if (this is Program.type_Real64)    return 7
      if (this is Program.type_Real32)    return 6
      if (this is Program.type_Int64)     return 5
      if (this is Program.type_Character) return 4
      if (this is Program.type_Int32)     return 3
      if (this is Program.type_Byte)      return 2
      if (this is Program.type_Logical)   return 1
      return 0

    method collect_base_types( list:Type[] )
      if (list.contains(this)) return
      list.add( this )
      forEach (base_type in base_types)
        base_type.collect_base_types( list )
      endForEach

    method cull_unused_methods
      if (culled) return
      culled = true

      forEach (base_type in base_types) base_type.cull_unused_methods

      # Remove macros only to start with
      local i = method_list.count - 1
      while (i >= 0)
        local m = method_list[i]
        if (m.is_macro) method_list.remove( m )
        --i
      endWhile

      if (not has_extended_class)
        # Don't mess up the slots for extended classes.  No big deal since
        # code isn't actually generated for unused methods; cull_unused_methods()
        # merely prevents some extra 0's in the dynamic call table.

        i = method_list.count - 1
        while (i >= 0)
          local m = method_list[i]
          if (not m.is_used)
            if (not base_class or base_class.method_list.count <= i)
              method_list.remove( m )
            endIf
          endIf
          --i
        endWhile
      endIf

      i = 0
      forEach (m in method_list)
        m.index = i
        ++i
      endForEach

    method has_global_references->Logical
      forEach (g in global_list)
        if (g.type.is_reference) return true
        if (g.type.is_compound and g.type.has_object_references) return true
      endForEach

      return false

    method has_object_references->Logical
      # Returns true when:
      # - This class has a property that is a reference
      # - This class is a reference array
      # - This class is a compound array and the compound type contains references

      forEach (p in property_list)
        if (p.type.is_reference) return true
        if (p.type.is_compound and p.type.has_object_references) return true
      endForEach

      return (is_array and element_type.has_object_references)

    method is_reference_array->Logical
      return (is_array and element_type.is_reference)

    method inherit_definitions( from_type:Type )
      forEach (def in from_type.definition_list)
        if (not definition_lookup.contains(def.name))
          definition_list.add( def )
          definition_lookup[ def.name ] = from_type.definition_lookup[ def.name ]
        endIf
      endForEach

      forEach (base_type in from_type.base_types)
        inherit_definitions( base_type )
      endForEach

    method inherit_properties( list:Property[], lookup:Table<<String,Property>> )
      forEach (base_type in base_types)
        forEach (base_p in base_type.property_list)
          inherit_property( base_p, list, lookup )
        endForEach
      endForEach

      forEach (p in property_list)
        inherit_property( p, list, lookup )
      endForEach

    method inherit_property( p:Property, list:Property[], lookup:Table<<String,Property>> )
      local existing_p = lookup[ p.name ]
      if (existing_p)
        local i = list.locate( existing_p ).value

        if (p.type_context is existing_p.type_context and not p.is_incorporated and not existing_p.is_incorporated)
          throw p.t.error( ''A property named "$" already exists.'' (p.name) )
        else
          if (p.type is existing_p.type)
            if (p.initial_value)
              if (existing_p.initial_value)
                if (p.type.instance_of(existing_p.type))
                  # Use the new declaration with its updated initial value
                  if (p.type_context.is_aspect)
                    p = p.cloned.set_type_context( this )
                    p.mark_incorporated
                  endIf
                  list[i] = p
                  lookup[p.name] = p
                else
                  throw p.t.error( ''Conflicting initial values are given for property "$" in unrelated types $ and $.'' ...
                      (p.name,p.type_context,existing_p.type_context) )
                endIf
              else
                # Use newer property with its existing value instead of old property without a value
                if (p.type_context.is_aspect)
                  p = p.cloned.set_type_context( this )
                  p.mark_incorporated
                endIf
                list[i] = p
                lookup[p.name] = p
              endIf

              # Else either the original property is the one with the initial value or neither of them
              # has an initial value.  In either case leave the original property definition as the one
              # in the list.
            endIf
          else
            throw p.t.error( ''Conflicting types given for property "$" - $:$ in $ and $:$ in $.'' ...
              (p.name,p.name,p.type,p.type_context,p.name,existing_p.type,existing_p.type_context) )
          endIf
        endIf

      else
        if (p.type_context.is_aspect)
          p = p.cloned.set_type_context( this )
          p.mark_incorporated
        endIf
        list.add( p )
        lookup[p.name] = p
      endIf

    method create_introspection_methods( scope:Scope )
      # Create type_name() method
      local m_type_name = add_method( t, "type_name" )
      m_type_name.return_type = Program.type_String
      m_type_name.statements.add( CmdReturn( t, CmdLiteralString(t,name) ) )

      if (this.is_compound or this.is_primitive)
        local m_type_info = add_method( t, "type_info" )
        m_type_info.return_type = Program.get_type_reference( t, "TypeInfo" )
        m_type_info.statements.add( CmdReturn( t, CmdAccess( t, CmdAccess(t,"Runtime"), "type_info",
          CmdArgs(CmdLiteralString(t,name)) ) ) )
      endIf

    method inherit_methods( scope=null:Scope )
      # Inherit method templates
      forEach (base_type in base_types)
        if (base_type.method_templates)
          ensure this.method_templates( this )
          method_templates.inherit( base_type.method_templates, this )
        endIf
      endForEach

      # Organize methods and create signatures
      forEach (m in global_method_list)
        m.organize( scope )
      endForEach

      forEach (m in method_list)
        m.organize( scope )
      endForEach

      global_method_lookup_by_signature.clear
      global_method_lookup_by_name.clear
      method_lookup_by_signature.clear
      method_lookup_by_name.clear

      # Inherit routines and methods
      local full_routine_list = Method[]
      inherit_global_methods( full_routine_list, global_method_lookup_by_signature )
      global_method_list = full_routine_list
      forEach (r in global_method_list)
        local list = global_method_lookup_by_name[r.name]
        if (not list)
          list = Method[]
          global_method_lookup_by_name[r.name] = list
        endIf
        list.add( r )
      endForEach

      local full_method_list = Method[]
      inherit_methods( full_method_list, method_lookup_by_signature )
      method_list = full_method_list
      forEach (m in method_list)
        local list = method_lookup_by_name[m.name]
        if (not list)
          list = Method[]
          method_lookup_by_name[m.name] = list
        endIf
        list.add( m )
      endForEach

      # Attempt to instantiate our own overrides of any method templates.
      if (method_templates)
        forEach (m in method_list)
          if (m.type_context isNot this)
            local st = m.source_template
            if (st)
              method_templates.instantiate( st.name, st.type_parameters.count, st.parameter_count, st.t, m.name )
            endIf
          endIf
        endForEach
      endIf

    method inherit_methods( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.method_list)
          inherit_method( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in method_list)
        inherit_method( m, list, lookup )
      endForEach

    method inherit_method( m:Method, list:Method[], lookup:Table<<String,Method>> )
      local existing_m = lookup[ m.signature ]
      if (existing_m)
        if (m.return_type isNot existing_m.return_type)
          if (m.return_type is null or existing_m.return_type is null or not m.return_type.instance_of(existing_m.return_type))
            throw m.t.error( "In $::$ the overridden return type ($) is not compatible with the prior definition return type ($)." (m.type_context.name, m.signature,m.return_type,existing_m.return_type) )
          endIf
        endIf

        if (existing_m.is_macro xor m.is_macro)
          if (m.is_macro) throw existing_m.t.error( "A macro method cannot override an existing non-macro method." )
          else            throw existing_m.t.error( "Macro methods cannot be overridden by a non-macro method." )
        endIf

        local i = list.locate( existing_m ).value

        if (not existing_m.is_incorporated)
          if (m.type_context is existing_m.type_context)
            if (m.is_augment)
              apply_augment_labels( m, existing_m )
              return
            else
              throw m.t.error( "Type $ already defines method $." (m.type_context,m.signature) )
            endIf
          endIf
        endIf

        if (m.type_context.is_aspect)
          m.overriding_methods.add( existing_m )
          if (m.is_abstract) return

          m = m.incorporate( this )

        elseIf (m.is_augment)
          m.convert_augment_to_standalone

        endIf

        m.overridden_method = existing_m
        while (m.overridden_method and m.type_context is m.overridden_method.type_context)
          # Make sure that the overridden method is in a different type context - if it's
          # not then we're replacing an aspect method and need to dig down further to get
          # the actual overridden method.
          if (m.overridden_method.overridden_method)
            # Remove the aspect method from the list of overriding methods since it won't
            # be reachable or resolved otherwise.
            m.overridden_method.overridden_method.overriding_methods.remove( m.overridden_method )
          endIf
          m.overridden_method = m.overridden_method.overridden_method
        endWhile
        if (m.overridden_method)
          m.overridden_method.overriding_methods.add( m )
        endIf

        # Inherit select attributes
        if (existing_m.is_requisite) m.make_requisite

        list[i] = m
        lookup[m.signature] = m
        override_inherited_propagated_method( m, list, lookup )

      else
        # No existing method
        if (m.type_context.is_aspect)
          m = m.incorporate( this )
          m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
        elseIf (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
        override_inherited_propagated_method( m, list, lookup )

      endIf

    method override_inherited_propagated_method( m:Method, list:Method[], lookup:Table<<String,Method>> )
      if (m.is_propagated and m.type_context isNot this)
        # Override a copy of the method which will have the correct 'this' context.
        m = m.cloned.set_type_context( this )
        m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
        inherit_method( m, list, lookup )
      endIf

    method inherit_global_methods( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.global_method_list)
          inherit_global_method( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in global_method_list)
        inherit_global_method( m, list, lookup )
      endForEach

    method inherit_global_method( m:Method, list:Method[], lookup:Table<<String,Method>> )
      local existing_m = lookup[ m.signature ]

      if (existing_m)
        if (m.type_context is existing_m.type_context)
          if (m.is_augment)
            apply_augment_labels( m, existing_m )
            return
          else
            throw m.t.error( "Type $ already defines global method $." (m.type_context,m.signature) )
          endIf
        endIf

        local i = list.locate( existing_m ).value

        # Global aspect methods are not incorporated
        if (m.type_context.is_aspect) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        # New method replaces old method in lookup
        list[i] = m
        lookup[m.signature] = m

      else
        # Global aspect methods are not incorporated
        if (m.type_context.is_aspect) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
      endIf

    method inject_global_method( m:Method, at_index=null:Int32? )
      if (this.is_aspect) return
      m.assign_signature

      local existing_m = find_global_method( m.signature )
      if (existing_m)
        if (m is existing_m)
          if (at_index.value)
            global_method_list.remove( m )
            global_method_list.insert( m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i

            forEach (extended_class in extended_types)
              if (extended_class.organized)
                extended_class.inject_global_method( m, at_index )
              endIf
            endForEach
          endIf

        elseIf (m.type_context.instance_of(existing_m.type_context))
          # Our injected method overrides the existing one
          local overrides = existing_m.overriding_methods
          existing_m.overriding_methods = Method[]

          if (at_index.value)
            global_method_list.remove( existing_m )
            global_method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
          endIf

          inherit_method( m, global_method_list, global_method_lookup_by_signature )

          m.overriding_methods = overrides
          forEach (overriding_m in overrides) overriding_m.overridden_method = m

          global_method_lookup_by_name[m.name].remove( existing_m )
          global_method_lookup_by_name[m.name].add( m )

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach

        else
          # The existing method overrides the one we're trying to inject - leave
          # the existing one but set up the links and ensure the indices are correct.
          existing_m.overridden_method = m
          m.overriding_methods.add( existing_m )

          if (at_index.value)
            global_method_list.remove( existing_m )
            global_method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
          endIf

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( existing_m, at_index )
            endIf
          endForEach
        endIf

      elseIf (at_index.exists)
        inherit_method( m, global_method_list, global_method_lookup_by_signature )
        global_method_list.insert( global_method_list.remove_last, at_index.value )
        forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
        global_method_lookup_by_name[m.name].add( m )

        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach
        endIf
      else
        m.organize( &!add_to_lookup )
        m.index = global_method_list.count
        at_index = global_method_list.count
        inherit_method( m, global_method_list, global_method_lookup_by_signature )
        global_method_lookup_by_name[m.name].add( m )
        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach
        endIf
      endIf

      if (resolved) m.resolve

    method inject_method( m:Method, at_index=null:Int32? )
      if (this.is_aspect) return
      if (m.is_global) inject_global_method( m, at_index ); return

      m.assign_signature

      ensure method_lookup_by_name[m.name]

      local existing_m = find_method( m.signature )
      if (existing_m)
        if (m is existing_m)
          if (at_index.value)
            method_list.remove( m )
            method_list.insert( m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i

            forEach (extended_class in extended_types)
              if (extended_class.organized)
                extended_class.inject_method( m, at_index )
              endIf
            endForEach
          endIf

        elseIf (m.type_context.instance_of(existing_m.type_context))
          # Our injected method overrides the existing one
          local overrides = existing_m.overriding_methods
          existing_m.overriding_methods = Method[]

          if (at_index.value)
            method_list.remove( existing_m )
            method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
          endIf

          inherit_method( m, method_list, method_lookup_by_signature )

          m.overriding_methods = overrides
          forEach (overriding_m in overrides) overriding_m.overridden_method = m

          method_lookup_by_name[m.name].remove( existing_m )
          method_lookup_by_name[m.name].add( m )

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach

        else
          # The existing method overrides the one we're trying to inject - leave
          # the existing one but set up the links and ensure the indices are correct.
          existing_m.overridden_method = m
          m.overriding_methods.add( existing_m )

          if (at_index.value)
            method_list.remove( existing_m )
            method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
          endIf

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( existing_m, at_index )
            endIf
          endForEach
        endIf

      elseIf (at_index.exists)
        inherit_method( m, method_list, method_lookup_by_signature )
        method_list.insert( method_list.remove_last, at_index.value )
        forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
        method_lookup_by_name[m.name].add( m )

        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach
        endIf
      else
        m.organize( &!add_to_lookup )
        m.index = method_list.count
        at_index = method_list.count
        inherit_method( m, method_list, method_lookup_by_signature )
        method_lookup_by_name[m.name].add( m )
        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach
        endIf
      endIf

      if (resolved) m.resolve

    method apply_augment_labels( aug_m:Method, existing_m:Method )
      # Apply augment to existing method
      forEach (method_label in existing_m.label_list)
        local aug_label = aug_m.label_lookup[ method_label.name ]
        if (aug_label)
          method_label.statements.add( aug_label.statements )
          aug_label.is_referenced = true
        endIf
      endForEach

      forEach (label in aug_m.label_list)
        if (not label.is_referenced)
          throw label.t.error( "No corresponding label <<$>> in augmented code." (label.name) )
        endIf
      endForEach

    method index_and_move_inline_to_end( list:Method[] )
      local i = list.count - 1
      while (i >= 0)
        local m = list[i]
        if (m.is_macro)
          list.remove( m )
          list.add( m )
        endIf
        --i
      endWhile

      i = 0
      forEach (m in list)
        m.index = i
        ++i
      endForEach

    method omit_output->Logical
      return is_native or not is_used

    method resolve->Type
      if (resolved) return this
      resolved = true

      organize

      forEach (r in global_method_list)
        r.resolve
      endForEach

      forEach (m in method_list)
        m.resolve
      endForEach

      return this

    method should_cull->Logical
      return not is_used

    method to->String
      return name

    method trace_used_code
      if (is_used) return   # Already traced
      is_used = true

      if (is_singleton)
        local m = find_method( "init()" )
        if (m)
          m.make_requisite
        endIf
      endIf

      if (element_type) element_type.trace_used_code

      forEach (base_type in base_types)
        base_type.trace_used_code
      endForEach

      forEach (s in global_list)
        s.type.trace_used_code
      endForEach

      forEach (p in property_list)
        p.type.trace_used_code
      endForEach

      forEach (r in global_method_list)
        if (r.is_requisite) r.trace_used_code
      endForEach

      forEach (m in method_list)
        if (m.is_requisite) m.trace_used_code
      endForEach

    method validate
      # Perform miscellaneous validation
      forEach (m in method_list) m.validate

endClass
