$include "Definition.rogue"

class Type
  PROPERTIES
    t               : Token
    name            : String
    attributes      = Attributes()
    index           = -1

    source_template : Template
    specializers    : TypeSpecializer[]

    defined      : Logical
    organized    : Logical
    resolved     : Logical
    culled       : Logical

    base_class : Type
    base_types = Type[]
    flat_base_types = Type[]
    has_extended_class : Logical

    is_array     : Logical
    is_list      : Logical
    is_optional  : Logical
    element_type : Type

    is_used      : Logical

    simplify_name : Logical
      # RogueInt32 instead of RoguePrimitiveInt32, etc. - used for classes that are predefined
      # in the infrastructure and that developers will often use directly.

    definition_list   = Definition[]
    definition_lookup = Table<<String,Definition>>()
    prev_enum_cmd     : Cmd
    next_enum_offset  = 0

    native_properties : NativeProperty[]

    global_list   = Property[]
    global_lookup = Table<<String,Property>>() : Table<<String,Property>>

    property_list   = Property[]
    property_lookup = Table<<String,Property>>() : Table<<String,Property>>

    global_method_list          = Method[]                   : Method[]
    global_method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    routine_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    dynamic_method_table_index : Int32

    callback_parameter_types : Type[]
    callback_return_type     : Type

  METHODS
    method init( t, name )

    method add_method( m_t:Token, m_name:String )->Method
      return add_method( Method(m_t, this, m_name) )

    method add_method( m:Method )->Method
      method_list.add( m )
      local list = method_lookup_by_name[ m.name ]
      if (not list)
        list = Method[]
        method_lookup_by_name[ m.name ] = list
      endIf
      list.add( m )

      return m

    method replace_method( existing:Method, m_t:Token, m_name:String )->Method
      local m = Method( m_t, this, m_name )
      m.index = existing.index
      method_list[ m.index ] = m
      local list = method_lookup_by_name[ m_name ]
      list.remove( existing )
      list.add( m )
      return m

    method add_global_method( r_t:Token, r_name:String )->Method
      return add_global_method( Method(r_t, this, r_name) )

    method add_global_method( r:Method )->Method
      r.attributes.add( Attribute.is_global )

      global_method_list.add( r )
      local list = global_method_lookup_by_name[ r.name ]
      if (not list)
        list = Method[]
        global_method_lookup_by_name[ r.name ] = list
      endIf
      list.add( r )

      return r

    method add_global( s_t:Token, s_name:String )->Property
      local s = Property( s_t, this, s_name )
      global_list.add( s )
      global_lookup[s_name] = s
      return s

    method add_property( p_t:Token, p_name:String, p_type=null:Type, initial_value=null:Cmd )->Property
      return add_property( Property(p_t, this, p_name, p_type, initial_value) )

    method add_property( p:Property )->Property
      property_list.add( p )
      property_lookup[p.name] = p
      return p

    method collect_type_info( info:Int32[] )
      info.add( 0 )  # allocator 0

      if (is_primitive)
        info.add( 0 )
      else
        info.add( dynamic_method_table_index )
      endIf

      info.add( base_types.count )
      forEach (base_type in base_types) info.add( base_type.index )

    method compile_type->Type
      return this

    method create_default_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method create_flag_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method extends_object->Logical
      return instance_of( Program.type_Object )

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m) return m

      return find_routine( signature )

    method find_routine( signature:String )->Method
      local m = routine_lookup_by_signature[signature]
      if (m) return m

      return null

    method find_property( p_name:String )->Property
      if (p_name[0] == '@') p_name = p_name.rightmost(-1)
      return property_lookup[p_name]

    method find_global( s_name:String )->Property
      if (s_name[0] == '@') s_name = s_name.rightmost(-1)
      return global_lookup[s_name]

    method has_method_named( m_name:String )->Logical
      local list = method_lookup_by_name[m_name]
      return (list and list.count)

    method has_routine_named( r_name:String )->Logical
      local list = global_method_lookup_by_name[r_name]
      return (list and list.count)

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true
      if (this is Program.type_null and ancestor_type.is_reference) return true
      if (this.is_reference and ancestor_type is Program.type_Object and not this.is_foreign) return true

      forEach (base_type in base_types)
        if (base_type.instance_of(ancestor_type)) return true
      endForEach

      return false

    method is_compatible_with( other:Type )->Logical
      if (this is other) return true
      if (this.is_primitive and other.is_primitive)
        if (this is Program.type_Logical xor other is Program.type_Logical) return false
        return true
      endIf
      if (other.is_optional and other.element_type is this) return true
      if (this.is_aspect and other is Program.type_Object) return true
      return (this.instance_of(other))

    method is_equivalent_or_more_specific_than( other:Type )->Logical
      if (this is other) return true
      if (this.is_primitive and other.is_primitive)
        return this.primitive_rank >= other.primitive_rank
      endIf
      if (this.instance_of(other)) return true
      if (other.is_list and other.element_type is this) return true
      return false

    method is_direct->Logical
      return not is_reference

    method is_aspect->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_aspect

    method is_class->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_class

    method is_compound->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_compound

    method is_foreign->Logical
      return (attributes.flags & Attribute.is_foreign)

    method is_immutable->Logical
      return (attributes.flags & Attribute.is_immutable)

    method is_native->Logical
      return (attributes.flags & Attribute.is_native)

    method is_primitive->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_primitive

    method is_reference->Logical
      which (attributes.flags & Attribute.type_mask)
        case Attribute.is_class, Attribute.is_aspect
          return true
        others
          return false
      endWhich

    method is_requisite->Logical
      return (attributes.flags & Attribute.is_requisite)

    method is_routine->Logical
      return (attributes.flags & Attribute.is_routine)

    method is_singleton->Logical
      return (attributes.flags & Attribute.is_singleton)

    method is_special->Logical
      return (attributes.flags & Attribute.is_special)

    method make_requisite->this
      attributes.add( Attribute.is_requisite )
      return this

    method organize( scope=null:Scope )->Type
      if (organized) return this
      organized = true

      index = Program.type_list.count
      Program.type_list.add( this )

      if (not defined)
        defined = true
        local template = Program.find_template( name )
        if (template)
          template.instantiate( this, scope )
        else
          throw t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      forEach (base_type in base_types)
        base_type.organize( scope )

        if (not base_type.is_aspect)
          if (is_aspect)
            throw t.error( "Aspects can only extend other aspects." )
          elseIf (is_compound)
            throw t.error( "Compounds can only extend aspects." )
          endIf
        endIf

        if (base_type.instance_of(this))
          throw t.error( "Cyclic inheritance attempted - $ cannot extend $ because $ already extends $." ...
              (this,base_type,base_type,this) )
        endIf
      endForEach

      if (is_class)
        forEach (base_type in base_types)
          if (base_type.is_class)
            if (base_class and base_class isNot base_type)
              throw t.error( "Class $ can only have one base class ($ and $ are both specified as base classes)." (name,base_class,base_type) )
            else
              base_class = base_type
            endIf
          endIf
        endForEach

        if (not base_class and not is_foreign and this isNot Program.type_Object)
          Program.type_Object.organize
          base_class = Program.type_Object
          base_types.insert( base_class )
        endIf
      endIf

      if (base_class) base_types.insert( base_types.remove(base_class) )

      # Collect flat list base types while removing duplicates
      flat_base_types.clear
      if (base_class) base_class.collect_base_types( flat_base_types )
      forEach (base_type in base_types)
        base_type.collect_base_types( flat_base_types )
      endForEach

      # Inherit definitions
      forEach (base_type in base_types)
        inherit_definitions( base_type )
      endForEach

      # Inherit properties
      local full_property_list = Property[]
      property_lookup.clear
      inherit_properties( full_property_list, property_lookup )
      property_list = full_property_list

      # Create type_name() method
      local m_type_name = add_method( t, "type_name" )
      m_type_name.return_type = Program.type_String
      m_type_name.statements.add( CmdReturn( t, CmdLiteralString(t,name) ) )

      # Organize routines and methods and create signatures
      forEach (r in global_method_list)
        r.organize( scope )
      endForEach

      forEach (m in method_list)
        m.organize( scope )
      endForEach

      # Inherit routines and methods
      local full_routine_list = Method[]
      routine_lookup_by_signature.clear
      inherit_routines( full_routine_list, routine_lookup_by_signature )
      global_method_list = full_routine_list
      global_method_lookup_by_name.clear
      forEach (r in global_method_list)
        local list = global_method_lookup_by_name[r.name]
        if (not list)
          list = Method[]
          global_method_lookup_by_name[r.name] = list
        endIf
        list.add( r )
      endForEach

      local full_method_list = Method[]
      method_lookup_by_signature.clear
      inherit_methods( full_method_list, method_lookup_by_signature )
      method_list = full_method_list
      method_lookup_by_name.clear
      forEach (m in method_list)
        local list = method_lookup_by_name[m.name]
        if (not list)
          list = Method[]
          method_lookup_by_name[m.name] = list
        endIf
        list.add( m )
      endForEach

      # Mark any existing init_class() as requisite
      local m_init_class = find_routine( "init_class()" )
      if (m_init_class)
        if (m_init_class.type_context is this)
          m_init_class.make_requisite
        endIf
      else
        m_init_class = find_method( "init_class()" )
        if (m_init_class)
          throw m_init_class.t.error( "$::init_class() must be declared under GLOBAL METHODS." (name) )
        endIf
      endIf

      if (global_list.count)
        # Create or locate init_class() to initialize global properties
        local m = find_routine( "init_class()" )
        if (not m or m.type_context isNot this) m = add_global_method( t, "init_class" ).organize( scope )
        m.make_requisite

        # Insert global initializations
        local i = global_list.count - 1
        while (i >= 0)
          local s = global_list[i]
          if (s.initial_value)
            m.statements.insert( CmdWriteGlobal(s.t, s, s.initial_value.clone) )
          endIf
          --i
        endWhile
      endIf

      # Create or find init_object() method to initialize properties
      if (is_class and not is_native)
        local m = find_method( "init_object()" )
        local prior_m = m
        if (m and m.type_context is this)
          m.make_requisite
        else
          m = add_method( t, "init_object" ).organize( scope )
          m.make_requisite
          if (prior_m)
            prior_m.attributes.add( Attribute.is_dynamic )
            prior_m.attributes.add( Attribute.is_overridden )
            m.attributes.add( Attribute.is_dynamic )
            method_list.remove( m )
            method_list[ method_list.locate( prior_m ).value ] = m
          endIf
        endIf
        m.return_type = this
        m.statements.add( CmdReturn(t,CmdLiteralThis(t,this)) )

        # Insert property initializations
        local i = property_list.count - 1
        while (i >= 0)
          local p = property_list[i]
          if (p.initial_value)
            m.statements.insert( CmdWriteProperty(p.t, CmdLiteralThis(p.t,p.type_context), p, p.initial_value.clone) )
          endIf
          --i
        endWhile
      endIf

      # Mark any clean_up() method as requisite
      if (is_class and not is_native)
        if (name == "Alpha") println
        local m = find_method( "clean_up()" )
        if (m and m.type_context is this)
          if (m.return_type)
            throw m.t.error( "clean_up() cannot return a value." )
          endIf
          m.make_requisite
        endIf
      endIf

      # Add a default to->String to compounds
      if (is_compound or is_primitive or is_foreign)
        local m = find_method( "to_String()" )
        if (not m)
          m = add_method( t, "to_String" )
          m.return_type = Program.type_String
          m.statements.add( CmdReturn(t,CmdLiteralString(t,"($)"(name))) )
          m.organize( scope )
        endIf
      endIf

      # Add a default to->Object to compounds, primitives, and functional types
      if (is_compound or is_primitive or is_foreign)
        local m = find_method( "to_Object()" )
        if (not m)
          m = add_method( t, "to_Object" )
          local boxed_name = "Boxed<<$>>" (name)
          m.return_type = Program.get_type_reference( t, boxed_name )
          m.statements.add( CmdReturn(t,CmdAccess(t,boxed_name,CmdArgs(CmdLiteralThis(t,this)))) )
          m.organize( scope )
        endIf
      endIf

      if (this isNot Program.type_NativeArray)
        is_array = this.instance_of( Program.type_NativeArray )
        if (is_array)
          local cur_type = this
          while (not cur_type.name.begins_with("Array<<"))
            cur_type = cur_type.base_class
            if (cur_type is null) throw t.error( "A class that is instanceOf NativeArray must also be instanceOf Array<<DataType>>." )
          endWhile

          local element_type_name = cur_type.name.after_first("<<").before_last(">>")
          element_type = Program.get_type_reference( t, element_type_name ).organize( scope )
        endIf
      endIf

      index_and_move_inline_to_end( global_method_list )
      index_and_move_inline_to_end( method_list )

      return this

    method primitive_rank->Int32
      if (this is Program.type_Real64)      return 7
      if (this is Program.type_Real32)     return 6
      if (this is Program.type_Int64)      return 5
      if (this is Program.type_Int32)   return 4
      if (this is Program.type_Character) return 3
      if (this is Program.type_Byte)      return 2
      if (this is Program.type_Logical)   return 1
      return 0

    method collect_base_types( list:Type[] )
      has_extended_class = true
      if (list.contains(this)) return
      list.add( this )
      forEach (base_type in base_types)
        base_type.collect_base_types( list )
      endForEach

    method cull_unused_methods
      if (culled) return
      culled = true

      forEach (base_type in base_types) base_type.cull_unused_methods

      # Remove macros only to start with
      local i = method_list.count - 1
      while (i >= 0)
        local m = method_list[i]
        if (m.is_macro) method_list.remove( m )
        --i
      endWhile

      if (not has_extended_class)
        # Don't mess up the slots for extended classes.  No big deal since
        # code isn't actually generated for unused methods; cull_unused_methods()
        # merely prevents some extra 0's in the dynamic call table.

        i = method_list.count - 1
        while (i >= 0)
          local m = method_list[i]
          if (not m.is_used)
            if (not base_class or base_class.method_list.count <= i)
              method_list.remove( m )
            endIf
          endIf
          --i
        endWhile
      endIf

      i = 0
      forEach (m in method_list)
        m.index = i
        ++i
      endForEach

    method has_global_references->Logical
      forEach (g in global_list)
        if (g.type.is_reference) return true
        if (g.type.is_compound and g.type.has_object_references) return true
      endForEach

      return false

    method has_object_references->Logical
      # Returns true when:
      # - This class has a property that is a reference
      # - This class is a reference array
      # - This class is a compound array and the compound type contains references

      forEach (p in property_list)
        if (p.type.is_reference) return true
        if (p.type.is_compound and p.type.has_object_references) return true
      endForEach

      return (is_array and element_type.has_object_references)

    method is_reference_array->Logical
      return (is_array and element_type.is_reference)

    method inherit_definitions( from_type:Type )
      forEach (def in from_type.definition_list)
        if (not definition_lookup.contains(def.name))
          definition_list.add( def )
          definition_lookup[ def.name ] = from_type.definition_lookup[ def.name ]
        endIf
      endForEach

      forEach (base_type in from_type.base_types)
        inherit_definitions( base_type )
      endForEach

    method inherit_properties( list:Property[], lookup:Table<<String,Property>> )
      forEach (base_type in base_types)
        forEach (base_p in base_type.property_list)
          inherit_property( base_p, list, lookup )
        endForEach
      endForEach

      forEach (p in property_list)
        inherit_property( p, list, lookup )
      endForEach

    method inherit_property( p:Property, list:Property[], lookup:Table<<String,Property>> )
      local existing_p = lookup[ p.name ]
      if (existing_p)
        local i = list.locate( existing_p ).value

        if (p.type_context is existing_p.type_context and not p.is_incorporated and not existing_p.is_incorporated)
          throw p.t.error( ''A property named "$" already exists.'' (p.name) )
        else
          if (p.type is existing_p.type)
            if (p.initial_value)
              if (existing_p.initial_value)
                if (p.type.instance_of(existing_p.type))
                  # Use the new declaration with its updated initial value
                  if (p.type_context.is_aspect)
                    p = p.clone.set_type_context( this )
                    p.mark_incorporated
                  endIf
                  list[i] = p
                  lookup[p.name] = p
                else
                  throw p.t.error( ''Conflicting initial values are given for property "$" in unrelated types $ and $.'' ...
                      (p.name,p.type_context,existing_p.type_context) )
                endIf
              else
                # Use newer property with its existing value instead of old property without a value
                if (p.type_context.is_aspect)
                  p = p.clone.set_type_context( this )
                  p.mark_incorporated
                endIf
                list[i] = p
                lookup[p.name] = p
              endIf

              # Else either the original property is the one with the initial value or neither of them
              # has an initial value.  In either case leave the original property definition as the one
              # in the list.
            endIf
          else
            throw p.t.error( ''Conflicting types given for property "$" - $:$ in $ and $:$ in $.'' ...
              (p.name,p.name,p.type,p.type_context,p.name,existing_p.type,existing_p.type_context) )
          endIf
        endIf

      else
        if (p.type_context.is_aspect)
          p = p.clone.set_type_context( this )
          p.mark_incorporated
        endIf
        list.add( p )
        lookup[p.name] = p
      endIf

    method inherit_methods( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.method_list)
          inherit_method( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in method_list)
        inherit_method( m, list, lookup )
      endForEach

    method inherit_method( m:Method, list:Method[], lookup:Table<<String,Method>> )
      local existing_m = lookup[ m.signature ]

      if (existing_m)
        if (m.return_type isNot existing_m.return_type)
          if (m.return_type is null or existing_m.return_type is null or not m.return_type.instance_of(existing_m.return_type))
            throw m.t.error( "In $::$ the overridden return type ($) is not compatible with the prior definition return type ($)." (m.type_context.name, m.signature,m.return_type,existing_m.return_type) )
          endIf
        endIf

        local i = list.locate( existing_m ).value

        if (not existing_m.is_incorporated)
          if (m.type_context is existing_m.type_context)
            if (m.is_augment)
              apply_augment_labels( m, existing_m )
              return
            else
              throw m.t.error( "Type $ already defines method $." (m.type_context,m.signature) )
            endIf
          endIf
        endIf

        if (m.type_context.is_aspect)
          m.overriding_methods.add( existing_m )
          if (m.is_abstract) return

          m = m.incorporate( this )

        elseIf (m.is_augment)
          m.convert_augment_to_standalone

        endIf

        if (not existing_m.type_context.is_aspect)
          existing_m.attributes.add( Attribute.is_dynamic )
          existing_m.attributes.add( Attribute.is_overridden )
          m.attributes.add( Attribute.is_dynamic )
        endIf

        m.overridden_method = existing_m
        while (m.overridden_method and m.type_context is m.overridden_method.type_context)
          # Make sure that the overridden method is in a different type context - if it's
          # not then we're replacing an aspect method and need to dig down further to get
          # the actual overridden method.
          if (m.overridden_method.overridden_method)
            # Remove the aspect method from the list of overriding methods since it won't
            # be reachable or resolved otherwise.
            m.overridden_method.overridden_method.overriding_methods.remove( m.overridden_method )
          endIf
          m.overridden_method = m.overridden_method.overridden_method
        endWhile
        if (m.overridden_method)
          m.overridden_method.overriding_methods.add( m )
        endIf
        list[i] = m
        lookup[m.signature] = m

      else
        # No existing method
        if (m.type_context.is_aspect)
          m = m.incorporate( this )
        elseIf (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
      endIf

    method inherit_routines( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.global_method_list)
          inherit_routine( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in global_method_list)
        inherit_routine( m, list, lookup )
      endForEach

    method inherit_routine( m:Method, list:Method[], lookup:Table<<String,Method>> )
      local existing_m = lookup[ m.signature ]

      if (existing_m)
        if (m.type_context is existing_m.type_context)
          if (m.is_augment)
            apply_augment_labels( m, existing_m )
            return
          else
            throw m.t.error( "Type $ already defines global method $." (m.type_context,m.signature) )
          endIf
        endIf

        local i = list.locate( existing_m ).value

        # Aspect routines are not incorporated
        if (m.type_context.is_aspect) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        # New method replaces old method in lookup
        list[i] = m
        lookup[m.signature] = m

      else
        # Aspect routines are not incorporated
        if (m.type_context.is_aspect) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
      endIf

    method apply_augment_labels( aug_m:Method, existing_m:Method )
      # Apply augment to existing method
      forEach (method_label in existing_m.label_list)
        local aug_label = aug_m.label_lookup[ method_label.name ]
        if (aug_label)
          method_label.statements.add( aug_label.statements )
          aug_label.is_referenced = true
        endIf
      endForEach

      forEach (label in aug_m.label_list)
        if (not label.is_referenced)
          throw label.t.error( "No corresponding label <<$>> in augmented code." (label.name) )
        endIf
      endForEach

    method index_and_move_inline_to_end( list:Method[] )
      local i = list.count - 1
      while (i >= 0)
        local m = list[i]
        if (m.is_macro)
          list.remove( m )
          list.add( m )
        endIf
        --i
      endWhile

      i = 0
      forEach (m in list)
        m.index = i
        ++i
      endForEach

    method omit_output->Logical
      return is_native or not is_used

    method resolve->Type
      if (resolved) return this
      resolved = true

      organize

      if (element_type) element_type.organize

      forEach (s in global_list) s.type.organize

      forEach (p in property_list)
        p.type.organize
      endForEach

      forEach (r in global_method_list)
        r.resolve
      endForEach

      forEach (m in method_list)
        m.resolve
      endForEach

      return this

    method should_cull->Logical
      return not is_used

    method to->String
      return name

    method trace_used_code
      if (is_used) return   # Already traced
      is_used = true

      if (is_singleton)
        local m = find_method( "init()" )
        if (m)
          m.make_requisite
        endIf
      endIf

      if (element_type) element_type.trace_used_code

      forEach (base_type in base_types)
        base_type.trace_used_code
      endForEach

      forEach (s in global_list)
        s.type.trace_used_code
      endForEach

      forEach (p in property_list)
        p.type.trace_used_code
      endForEach

      forEach (r in global_method_list)
        if (r.is_requisite) r.trace_used_code
      endForEach

      forEach (m in method_list)
        if (m.is_requisite) m.trace_used_code
      endForEach

endClass
