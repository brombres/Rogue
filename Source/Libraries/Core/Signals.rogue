class Signals [singleton]
  PROPERTIES
    standard_connections = [GlobalID:SignalConnection[]]
    one_time_connections = [GlobalID:SignalConnection[]]

  METHODS
    method disconnect( signal_id:GlobalID )
      one_time_connections[signal_id]?.clear
      standard_connections[signal_id]?.clear

    method disconnect( signal_id:GlobalID, context:Object )
      if local group = standard_connections[ signal_id ]
        group.discard( $.context == context )
      endIf

      if local group = one_time_connections[ signal_id ]
        group.discard( $.context == context )
      endIf

    method disconnect( context:Object )
      forEach (group in standard_connections)
        group.discard( $.context == context )
      endForEach

      forEach (group in one_time_connections)
        group.discard( $.context == context )
      endForEach

    method disconnect( connection:SignalConnection )
      standard_connections[ connection.signal_id ]?.remove( connection )
      one_time_connections[ connection.signal_id ]?.remove( connection )

    method dispatch( signal_id:GlobalID, args=undefined:Variant )
      if local group = one_time_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )
          group.clear
          (forEach in list)( args )
        endUse
      endIf

      if local group = standard_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )

          local has_broken_connections = false
          forEach (connection in list)
            if (connection) connection( args )
            else            has_broken_connections = true
          endForEach
          if (has_broken_connections)
            group.discard( not $ )
          endIf
        endUse
      endIf

    method on( signal_id:GlobalID, context:Object, callback:Function(Variant), &once )->SignalConnection
      if (not context) context = this

      if (once)
        local group = one_time_connections[signal_id]
        if (not group)
          ensure<<group>>
          one_time_connections[signal_id] = group
        endIf
        local connection = SignalConnection( signal_id, context, callback )
        group.add( connection )
        return connection
      else
        local group = standard_connections[signal_id]
        if (not group)
          ensure<<group>>
          standard_connections[signal_id] = group
        endIf
        local connection = SignalConnection( signal_id, context, callback )
        group.add( connection )
        return connection
      endIf

    method on( signal_id:GlobalID, callback:Function(Variant), &once )->SignalConnection
      return on( signal_id, null, callback, &=once )

    method on( signal_id:GlobalID, context:Object, callback:Function(), &once )->SignalConnection
      return on( signal_id, context, (args) => callback(), &=once )

    method on( signal_id:GlobalID, callback:Function(), &once )->SignalConnection
      return on( signal_id, null, (args) => callback(), &=once )

endClass

class SignalConnection( signal_id:GlobalID, context:WeakReference<<Object>>,
    callback:Function(Variant) ) [compound]
  GLOBAL METHODS
    method create( signal_id:GlobalID, context:Object, callback:Function(Variant) )->SignalConnection
      return SignalConnection( signal_id, WeakReference<<Object>>(context), callback )

  METHODS
    method call( args:Variant )
      if (context) callback( args )

    method disconnect
      Signals.disconnect( this )
      context.object = null

    method operator==( other_object:Object )->Logical
      local other = other_object->(as SignalConnection)
      return signal_id == other.signal_id and context == other.context and callback is other.callback

    method operator?()->Logical
      return context?
endClass

class SignalGroup
  PROPERTIES
    connections : SignalConnection[]

  METHODS
    method on_cleanup
      disconnect

    method disconnect
      if (connections)
        (forEach in connections).disconnect
        connections.clear
      endIf

    method on( signal_id:GlobalID, callback:Function(Variant), &once )->SignalConnection
      local connection = Signals.on( signal_id, callback, &=once )
      ensure<<connections>>.add( connection )
      return connection

    method on( signal_id:GlobalID, callback:Function(), &once )->SignalConnection
      local connection = Signals.on( signal_id, callback, &=once )
      ensure<<connections>>.add( connection )
      return connection
endClass

augment Rogue::Global
  METHODS
    method signal( signal_id:GlobalID, args=undefined:Variant )
      Signals.dispatch( signal_id, args )
endAugment

augment GlobalID
  METHODS
    method disconnect_signal
      Signals.disconnect( this )

    method disconnect_signal( context:Object )
      Signals.disconnect( this, context )

    method on_signal( context:Object, callback:Function(Variant) )->SignalConnection
      return Signals.on( this, context, callback )

    method on_signal( context:Object, callback:Function() )->SignalConnection
      return Signals.on( this, context, callback )

    method on_signal( callback:Function(Variant) )->SignalConnection
      return Signals.on( this, callback )

    method on_signal( callback:Function() )->SignalConnection
      return Signals.on( this, callback )

    method signal( args=undefined:Variant )
      Signals.dispatch( this, args )
endAugment

