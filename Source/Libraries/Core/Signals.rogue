class Signals [singleton]
  PROPERTIES
    standard_connections = [GlobalID:SignalConnection[]]
    one_time_connections = [GlobalID:SignalConnection[]]

  METHODS
    method disconnect( signal_id:GlobalID )
      one_time_connections[signal_id]?.clear
      standard_connections[signal_id]?.clear

    method disconnect( signal_id:GlobalID, context:Object )
      local signal_id = connection.signal_id

      if local group = standard_connections[ signal_id ]
        group.discard( $.context.object is context )
      endIf

      if local group = one_time_connections[ signal_id ]
        group.discard( $.callback.object is callback )
      endIf

    method disconnect( context:Object )
      forEach (group in standard_connections)
        group.discard( $.context.object is context )
      endForEach

      forEach (group in one_time_connections)
        group.discard( $.context.object is context )
      endForEach

    method disconnect( connection:SignalConnection )
      local signal_id = connection.signal_id
      local callback = connection.callback.object

      if local group = standard_connections[ signal_id ]
        group.discard( $.callback.object is callback )
      endIf

      if local group = one_time_connections[ signal_id ]
        group.discard( $.callback.object is callback )
      endIf

    method dispatch( signal_id:GlobalID, args=undefined:Variant )
      if local group = one_time_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )
          group.clear
          forEach (callback in list)
            callback( args )
          endForEach
        endUse
      endIf

      if local group = standard_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )

          local has_broken_connections = false
          forEach (connection in list)
            if (connection) connection( args )
            else            has_broken_connections = true
          endForEach
          if (has_broken_connections)
            forEach (connection in rewriter=group.rewriter)
              if (connection) rewriter.write( connection )
            endForEach
          endIf

        endUse
      endIf

    method on( signal_id:GlobalID, context:Object, callback:Function(Variant), &once )->SignalConnection
      if (once)
        local group = one_time_connections[signal_id]
        if (not group)
          ensure<<group>>
          one_time_connections[signal_id] = group
        endIf
        local connection = SignalConnection( signal_id, context, callback )
        group.add( connection )
        return connection
      else
        local group = standard_connections[signal_id]
        if (not group)
          ensure<<group>>
          standard_connections[signal_id] = group
        endIf
        local connection = SignalConnection( signal_id, context, callback )
        group.add( connection )
        return connection
      endIf

    method on( signal_id:GlobalID, callback:Function(Variant), &once )->SignalConnection
      return on( signal_id, null, callback, &=once )

    method on( signal_id:GlobalID, context:Object, callback:Function(), &once )->SignalConnection
      return on( signal_id, context, (args) => callback(), &=once )

    method on( signal_id:GlobalID, callback:Function(), &once )->SignalConnection
      return on( signal_id, null, (args) => callback(), &=once )

endClass

class SignalConnection( signal_id:GlobalID, context:WeakReference<<Object>>,
    callback:WeakReference<<Function(Variant)>> ) [compound]
  GLOBAL METHODS
    method create( signal_id:GlobalID, context:Object, callback:Function(Variant) )->SignalConnection
      return SignalConnection( signal_id, WeakReference<<Object>>(context), WeakReference<<Function(Variant)>>(callback) )

  METHODS
    method call( args:Variant )
      callback.object?.call( args )

    method disconnect
      Signals.disconnect( this )
      callback.object = null

    method operator?()->Logical
      return callback.object?
endClass

class SignalGroup
  PROPERTIES
    connections : SignalConnection[]

  METHODS
    method on_cleanup
      disconnect

    method disconnect
      if (connections)
        (forEach in connections).disconnect
        connections.clear
      endIf

    method on( signal_id:GlobalID, callback:Function(Variant), &once )->SignalConnection
      local connection = Signals.on( signal_id, callback, &=once )
      ensure<<connections>>.add( connection )
      return connection

    method on( signal_id:GlobalID, callback:Function(), &once )->SignalConnection
      local connection = Signals.on( signal_id, callback, &=once )
      ensure<<connections>>.add( connection )
      return connection
endClass

augment Rogue::Global
  METHODS
    method signal( signal_id:GlobalID, args=undefined:Variant )
      Signals.dispatch( signal_id, args )
endAugment

