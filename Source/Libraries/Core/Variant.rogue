# This library is included by RogueC as needed.

$include IO/Scanner
$include Codec/JSON

uses Geometry
uses Graphics [noInclude]
$include Graphics/Color

class Variant [compound]
  DEFINITIONS
    TYPE_UNDEFINED =  0

    # Numbers
    TYPE_BYTE      =  1
    TYPE_CHARACTER =  2
    TYPE_INT32     =  3
    TYPE_COLOR     =  4
    TYPE_INT       =  5
    TYPE_INT64     =  6
    TYPE_REAL32    =  7
    TYPE_REAL      =  8
    TYPE_REAL64    =  9
    TYPE_DEGREES   = 10
    TYPE_RADIANS   = 11
    TYPE_FIRST_NUMBER = TYPE_BYTE
    TYPE_LAST_NUMBER  = TYPE_RADIANS

    # Compounds and non-numeric primitives

    # Geometry
    TYPE_ANCHOR    = 20
    TYPE_BOX       = 21
    TYPE_CIRCLE    = 22
    TYPE_LINE      = 23
    TYPE_QUAD32    = 24
    TYPE_TRIANGLE  = 25
    TYPE_XY        = 26
    TYPE_XYZ       = 27
    TYPE_XYZW      = 28

    # Non-numeric primitives
    TYPE_LOGICAL   = 30
    TYPE_GLOBAL_ID = 31

    # Object-adjacent
    TYPE_NULL      = 39

    # Object types
    TYPE_OBJECT           = 40
    TYPE_STRING           = 41
    TYPE_FILE             = 42
    TYPE_FIRST_STRINGLIKE = 41
    TYPE_LAST_STRINGLIKE  = 42

    TYPE_LIST             = 43
    TYPE_TABLE            = 44

  NATIVE
    nativeHeader
      @|#define %NS%ROGUE_VARIANT_TYPE_UNDEFINED  0
       |#define %NS%ROGUE_VARIANT_TYPE_BYTE       1
       |#define %NS%ROGUE_VARIANT_TYPE_CHARACTER  2
       |#define %NS%ROGUE_VARIANT_TYPE_INT32      3
       |#define %NS%ROGUE_VARIANT_TYPE_COLOR      4
       |#define %NS%ROGUE_VARIANT_TYPE_INT        5
       |#define %NS%ROGUE_VARIANT_TYPE_INT64      6
       |#define %NS%ROGUE_VARIANT_TYPE_REAL32     7
       |#define %NS%ROGUE_VARIANT_TYPE_REAL       8
       |#define %NS%ROGUE_VARIANT_TYPE_REAL64     9
       |#define %NS%ROGUE_VARIANT_TYPE_DEGREES   10
       |#define %NS%ROGUE_VARIANT_TYPE_RADIANS   11
       |
       |#define %NS%ROGUE_VARIANT_TYPE_ANCHOR    20
       |#define %NS%ROGUE_VARIANT_TYPE_BOX       21
       |#define %NS%ROGUE_VARIANT_TYPE_CIRCLE    22
       |#define %NS%ROGUE_VARIANT_TYPE_LINE      23
       |#define %NS%ROGUE_VARIANT_TYPE_QUAD32    24
       |#define %NS%ROGUE_VARIANT_TYPE_TRIANGLE  25
       |#define %NS%ROGUE_VARIANT_TYPE_XY        26
       |#define %NS%ROGUE_VARIANT_TYPE_XYZ       27
       |#define %NS%ROGUE_VARIANT_TYPE_XYZW      28
       |
       |#define %NS%ROGUE_VARIANT_TYPE_LOGICAL   30
       |#define %NS%ROGUE_VARIANT_TYPE_GLOBAL_ID 31
       |
       |#define %NS%ROGUE_VARIANT_TYPE_NULL      39
       |
       |#define %NS%ROGUE_VARIANT_TYPE_OBJECT         40
       |#define %NS%ROGUE_VARIANT_TYPE_STRING         41
       |#define %NS%ROGUE_VARIANT_TYPE_FILE           42
       |
       |#define %NS%ROGUE_VARIANT_TYPE_LIST           43
       |#define %NS%ROGUE_VARIANT_TYPE_TABLE          44

  PROPERTIES
    # All properties should be considered INTERNAL USE ONLY because they are
    # tricky - .type must be checked to know which property is valid.
    type      : Int
    object    : Object # Can't be mixed into the union due to GC constraints

    box       : Box       [faux]
    byte      : Byte      [faux]
    character : Character [faux]
    circle    : Circle    [faux]
    color     : Color     [faux]
    degrees   : Degrees   [faux]
    global_id : GlobalID  [faux]
    int32     : Int32     [faux]
    integer   : Int       [faux]
    int64     : Int64     [faux]
    line      : Line      [faux]
    logical   : Logical   [faux]
    quad32    : Quad32    [faux]
    radians   : Radians   [faux]
    real32    : Real32    [faux]
    real      : Real      [faux]
    real64    : Real64    [faux]
    triangle  : Triangle  [faux]
    xy        : XY        [faux]
    xyz       : XYZ       [faux]
    xyzw      : XYZW      [faux]

    native @|union
            |{
            |  %Ns%GeometryBox      box;
            |  %Ns%RogueByte        byte;
            |  %Ns%RogueCharacter   character;
            |  %Ns%GeometryCircle   circle;
            |  %Ns%GraphicsColor    color;
            |  %Ns%RogueDegrees     degrees;
            |  %Ns%RogueGlobalID    global_id;
            |  %Ns%RogueInt32       int32;
            |  %Ns%RogueInt         integer;
            |  %Ns%RogueInt64       int64;
            |  %Ns%RogueLogical     logical;
            |  %Ns%GeometryLine     line;
            |  %Ns%GeometryQuad32   quad32;
            |  %Ns%RogueRadians     radians;
            |  %Ns%RogueReal32      real32;
            |  %Ns%RogueReal        real;
            |  %Ns%RogueReal64      real64;
            |  %Ns%GeometryTriangle triangle;
            |  %Ns%GeometryXY       xy;
            |  %Ns%GeometryXYZ      xyz;
            |  %Ns%GeometryXYZW     xyzw;
            |};

  GLOBAL METHODS
    method create->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_UNDEFINED }" )->Variant  # undefined

    method create( value:Logical )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_LOGICAL, 0, {.logical=$value} }" )->Variant

    method create( value:Byte )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_BYTE, 0, {.byte=$value} }" )->Variant

    method create( value:Character )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_CHARACTER, 0, {.character=$value} }" )->Variant

    method create( value:Color )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_COLOR, 0, {.color=$value} }" )->Variant

    method create( value:Degrees )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_DEGREES, 0, {.degrees=$value} }" )->Variant

    method create( value:File )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_FILE, (%Ns%RogueObject*)$value.filepath }" )->Variant

    method create( value:Int32 )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_INT32, 0, {.int32=$value} }" )->Variant

    method create( value:Int )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_INT, 0, {.integer=$value} }" )->Variant

    method create( value:Int64 )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_INT64, 0, {.int64=$value} }" )->Variant

    method create( value:Radians )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_RADIANS, 0, {.radians=$value} }" )->Variant

    method create( value:Real32 )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_REAL32, 0, {.real32=$value} }" )->Variant

    method create( value:Real )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_REAL, 0, {.real=$value} }" )->Variant

    method create( value:Real64 )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_REAL64, 0, {.real64=$value} }" )->Variant

    method create( value:XY )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_XY, 0, {.xy=$value} }" )->Variant

    method create( value:XYZ )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_XYZ, 0, {.xyz=$value} }" )->Variant

    method create( value:XYZW )->Variant
      return native( "(%Ns%RogueVariant) {  %NS%ROGUE_VARIANT_TYPE_XYZW, 0, {.xyzw=$value} }" )->Variant

    method create( value:Anchor )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_ANCHOR, 0, {.xy=$value.position} }" )->Variant

    method create( value:Box )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_BOX, 0, {.box=$value} }" )->Variant

    method create( value:Quad )->Variant
      local quad32 = Quad32( value )
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_QUAD32, 0, {.quad32=$quad32} }" )->Variant

    method create( value:Quad32 )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_QUAD32, 0, {.quad32=$value} }" )->Variant

    method create( value:Circle )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_CIRCLE, 0, {.circle=$value} }" )->Variant

    method create( value:GlobalID )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_GLOBAL_ID, 0, {.global_id=$value} }" )->Variant

    method create( value:Triangle )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_TRIANGLE, 0, {.triangle=$value} }" )->Variant

    method create( value:Line )->Variant
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_LINE, 0, {.line=$value} }" )->Variant

    method create( value:Object )->Variant [preferred]
      if (value) return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_OBJECT, $value }" )->Variant
      else       return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_NULL }" )->Variant  # null value

    method create( value:String )->Variant
      if (value) return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_STRING, (%Ns%RogueObject*)$value }" )->Variant
      else       return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_NULL }" )->Variant  # null value

    method create( value:Variant[] )->Variant
      if (value) return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_LIST, (%Ns%RogueObject*)$value }" )->Variant
      else       return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_NULL }" )->Variant  # null value

    method create( value:[Variant:Variant] )->Variant
      if (value) return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_TABLE, (%Ns%RogueObject*)$value }" )->Variant
      else       return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_NULL }" )->Variant  # null value

    method create_list->Variant
      # Convenience syntax: @[] is equivalent to Variant.create_list()
      local data = Variant[]
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_LIST, (%Ns%RogueObject*)$data }" )->Variant

    method create_table->Variant
      # Convenience syntax: @{} is equivalent to Variant.create_table()
      local data = [Variant:Variant]
      return native( "(%Ns%RogueVariant) { %NS%ROGUE_VARIANT_TYPE_TABLE, (%Ns%RogueObject*)$data }" )->Variant

  METHODS
    method add( value:Variant )
      which (type)
        case TYPE_LIST
          object->(as Variant[]).add( value )
        case TYPE_TABLE
          object->(as [Variant:Variant])[ value ] = true
      endWhich

    method add_all( value:Variant )
      which (type)
        case TYPE_LIST
          local list = object->(as Variant[]).[ reserve(value.count) ]
          list.add( forEach in value )
        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          if (value.is_table)
            forEach (entry in value.entries)
              table[entry.key] = entry.value
            endForEach
          else
            table[forEach in value] = true
          endIf
      endWhich

    method as_list->Variant[]
      # If this value .is_list, returns the backing Variant[] list; otherwise returns null.
      if (type != TYPE_LIST) return null
      return object->(as Variant[])

    method as_string->String
      # If this value .is_string, returns the backing String; otherwise returns null.
      #
      #   Variant     | ->String  |  .as_string
      #   ------------|-----------|------------
      #   null        | "null"    | null
      #   undefined   | ""        | null
      #   "ABC"       | "ABC"     | ABC
      #   [3,4]       | "[3,4]"   | null
      #   {x:22}      | "{x:22}"  | null
      if (type != TYPE_STRING) return null
      return object->(as String)

    method as_table->[Variant:Variant]
      # If this value .is_table, returns the backing [Variant:Variant] table; otherwise returns null.
      if (type != TYPE_TABLE) return null
      return object->(as [Variant:Variant])

    method at( index:Int )->Variant
      which (type)
        case TYPE_LIST
          local list = object->(as Variant[])
          if (index < 0 or index >= list.count) return undefined
          return list[index]

        case TYPE_STRING, TYPE_FILE
          local st = object->(as String)
          if (index < 0 or index >= st.count) return undefined
          return st[index]

        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          if (index < 0 or index >= table.count) return undefined
          return table.at(index)

        others
          if (index == 0) return this
          return undefined
      endWhich

    method clear
      which (type)
        case TYPE_LIST
          object->(as Variant[]).clear
        case TYPE_TABLE
          object->(as [Variant:Variant]).clear
      endWhich

    method cloned->Variant
      local result : Variant
      if (type <= TYPE_NULL)
        native @|memcpy( &$result, &$this, sizeof($<<Variant>>) );
      else
        which (type)
          case TYPE_LIST
            result = @[]
            result.object->(as Variant[]).reserve( count )
            forEach (item in this)
              result.add( item.cloned )
            endForEach
          case TYPE_TABLE
            result = @{}
            forEach (entry in entries)
              result[entry.key.cloned] = entry.value.cloned
            endForEach
          others
            result.type = type
            result.object = object
        endWhich
      endIf
      return result

    method contains( value:Variant )->Logical
      which (type)
        case TYPE_STRING, TYPE_FILE
          which (value.type)
            case TYPE_CHARACTER:         return object->(as String).contains( value.character )
            case TYPE_STRING, TYPE_FILE: return object->(as String).contains( value.object->(as String) )
            others:                      return false
          endWhich
        case TYPE_LIST
          return object->(as Variant[]).contains( value )
        case TYPE_TABLE
          return object->(as [Variant:Variant]).contains( value->String )
        others
          return false
      endWhich

    method count->Int
      which (type)
        case TYPE_STRING, TYPE_FILE
          return object->(as String).count
        case TYPE_LIST
          return object->(as Variant[]).count
        case TYPE_TABLE
          return object->(as [Variant:Variant]).count
        case TYPE_UNDEFINED
          return 0
        others
          return 1
      endWhich

    method entries->TableEntriesIterator<<Variant,Variant>>
      if (type != TYPE_TABLE) return TableEntriesIterator<<Variant,Variant>>( null )
      return object->(as [Variant:Variant]).entries

    method ensure_list( name:String )->Variant
      if (not is_table) return @[]

      local list = this[name]
      if (list) return list

      list = @[]
      this[name] = list
      return list

    method ensure_table( name:String )->Variant
      if (not is_table) return @{}

      local table = this[name]
      if (table) return table

      table = @{}
      this[name] = table
      return table

    method exists->Logical
      return (type != TYPE_UNDEFINED)

    method first->Variant
      which (type)
        case TYPE_STRING, TYPE_FILE
          local st = object->(as String)
          if (st.count == 0) return undefined
          return st[0]

        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          if (table.count == 0) return undefined
          return table.at(0)

        others
          return at(0)
      endWhich

    method first( query:Function(Variant)->Logical )->Variant
      forEach (value in this)
        if (query(value)) return value
      endForEach
      return undefined

    method get( index:Int )->Variant
      return get( Variant(index) )

    method get( key:String )->Variant
      return get( Variant(key) )

    method get( key:Variant )->Variant [preferred]
      which (type)
        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          local entry = table.find( key )
          if (entry) return entry.value
          else       return undefined

        others
          if (key.is_integer) return at( key->Int )
          else                return undefined
      endWhich

    method hashcode->Int
      which (type)
        case TYPE_UNDEFINED: return 0
        case TYPE_NULL:      return 0
        case TYPE_LOGICAL:   return which{ logical:1 || 0 }
        case TYPE_BYTE:      return byte.hashcode
        case TYPE_CHARACTER: return character.hashcode
        case TYPE_COLOR:     return color.hashcode
        case TYPE_DEGREES:   return degrees.hashcode
        case TYPE_GLOBAL_ID: return global_id.hashcode
        case TYPE_INT32:     return int32.hashcode
        case TYPE_INT:       return integer.hashcode
        case TYPE_INT64:     return int64.hashcode
        case TYPE_RADIANS:   return radians.hashcode
        case TYPE_REAL32:    return real32.hashcode
        case TYPE_REAL:      return real.hashcode
        case TYPE_REAL64:    return real64.hashcode
        case TYPE_XY:        return xy.hashcode
        case TYPE_XYZ:       return xyz.hashcode
        case TYPE_XYZW:      return xyzw.hashcode
        case TYPE_ANCHOR:    return xy.hashcode
        case TYPE_BOX:       return box.hashcode
        case TYPE_QUAD32:    return quad32.hashcode
        case TYPE_CIRCLE:    return circle.hashcode
        case TYPE_TRIANGLE:  return triangle.hashcode
        case TYPE_LINE:      return line.hashcode
        others
          if (object) return object.hashcode
          Global.error.print( "[Variant.hashcode()] Undefined type $"(type) )
          return 0
      endWhich

    method insert( value:Variant, before_index=0:Int )
      which (type)
        case TYPE_LIST
          object->(as Variant[]).insert( value, before_index )
      endWhich

    method is_collection->Logical
      return type > TYPE_OBJECT

    method is_anchor->Logical
      return (type == TYPE_ANCHOR)

    method is_box->Logical
      return (type == TYPE_BOX)

    method is_byte->Logical
      return (type == TYPE_BYTE)

    method is_character->Logical
      return (type == TYPE_CHARACTER)

    method is_circle->Logical
      return (type == TYPE_CIRCLE)

    method is_color->Logical
      return (type == TYPE_COLOR)

    method is_degrees->Logical
      return (type == TYPE_DEGREES)

    method is_empty->Logical
      return (count == 0)

    method is_file->Logical
      return (type == TYPE_FILE)

    method is_geometry->Logical
      return (type >= TYPE_ANCHOR and type <= TYPE_XYZW)

    method is_global_id->Logical
      return (type == TYPE_GLOBAL_ID)

    method is_int32->Logical
      return (type == TYPE_INT32)

    method is_int->Logical
      return (type == TYPE_INT)

    method is_int64->Logical
      return (type == TYPE_INT64)

    method is_integer->Logical
      return (type >= TYPE_BYTE and type <= TYPE_INT64)

    method is_line->Logical
      return (type == TYPE_LINE)

    method is_logical->Logical
      return (type == TYPE_LOGICAL)

    method is_list->Logical
      return (type == TYPE_LIST)

    method is_null->Logical
      return (type == TYPE_NULL)

    method is_number->Logical
      return (type >= TYPE_FIRST_NUMBER and type <= TYPE_LAST_NUMBER)

    method is_object->Logical
      return (type == TYPE_OBJECT)

    method is_quad->Logical
      return (type == TYPE_QUAD32)

    method is_radians->Logical
      return (type == TYPE_RADIANS)

    method is_real32->Logical
      return (type == TYPE_REAL32)

    method is_real->Logical
      return (type == TYPE_REAL)

    method is_real64->Logical
      return (type == TYPE_REAL64)

    method is_string->Logical
      return (type == TYPE_STRING)

    method is_table->Logical
      return (type == TYPE_TABLE)

    method is_triangle->Logical
      return (type == TYPE_TRIANGLE)

    method is_undefined->Logical
      return (type == TYPE_UNDEFINED)

    method is_xy->Logical
      return (type == TYPE_XY)

    method is_xyz->Logical
      return (type == TYPE_XYZ)

    method is_xyzw->Logical
      return (type == TYPE_XYZW)

    method keys->TableKeysIterator<<Variant,Variant>>
      if (type != TYPE_TABLE) return TableKeysIterator<<Variant,Variant>>( null )
      return object->(as [Variant:Variant]).keys

    method last->Variant
      which (type)
        case TYPE_STRING, TYPE_FILE
          local st = object->(as String)
          if (st.count == 0) return undefined
          return st[st.count-1]

        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          if (table.count == 0) return undefined
          return table.at( table.count-1 )

        others
          return at(count-1)
      endWhich

    method last( query:Function(Variant)->Logical )->Variant
      forEach (value in this step -1)
        if (query(value)) return value
      endForEach
      return undefined

    method locate( value:Variant, i1=null:Int? )->Int?
      which (type)
        case TYPE_STRING, TYPE_FILE
          which (value.type)
            case TYPE_CHARACTER:         return object->(as String).locate( value.character, i1 )
            case TYPE_STRING, TYPE_FILE: return object->(as String).locate( value.object->(as String), i1 )
            others:                      return null
          endWhich
        case TYPE_LIST
          return object->(as Variant[]).locate( value, i1 )
        others
          return null
      endWhich

    method locate_last( value:Variant, i1=null:Int? )->Int?
      which (type)
        case TYPE_STRING, TYPE_FILE
          which (value.type)
            case TYPE_CHARACTER:         return object->(as String).locate_last( value.character, i1 )
            case TYPE_STRING, TYPE_FILE: return object->(as String).locate_last( value.object->(as String), i1 )
            others:                      return null
          endWhich
        case TYPE_LIST
          return object->(as Variant[]).locate_last( value, i1 )
        others
          return null
      endWhich

    method map_list<<$NewListElementType>>( fn=null:Function(Variant)->$NewListElementType )->$NewListElementType[]
      if (not fn)
        fn = function( element:Variant )->$NewListElementType
          return element->$NewListElementType
        endFunction
      endIf

      which (type)
        case TYPE_LIST
          return object->(as Variant[]).map<<$NewListElementType>>( fn )
        case TYPE_TABLE
          local result = $NewListElementType[].[ reserve(count) ]
          forEach (element in this)
            result.add( fn(element) )
          endForEach
          return result
        others
          return undefined
      endWhich

    method map_table<<$NewTableType>>( fn=null:Function(Variant,Variant,$NewTableType) )->$NewTableType
      if (not fn)
        fn = function( key:Variant, value:Variant, table:$NewTableType )
          table[key] = value
        endFunction
      endIf

      which (type)
        case TYPE_TABLE
          return object->(as [Variant:Variant]).map<<$NewTableType>>( fn )
        others
          return undefined
      endWhich

    method operator?->Logical
      if (type == TYPE_NULL or type == TYPE_UNDEFINED) return false
      return this->Logical

    method operator==(other:Variant)->Int
      return (this <> other) == 0

    method operator<>(other:Variant)->Int
      if (type == TYPE_UNDEFINED) return (other.type != TYPE_UNDEFINED)

      if (type <= TYPE_LAST_NUMBER and other.type <= TYPE_LAST_NUMBER)
        # Both are numbers
        if (type >= TYPE_REAL64 or other.type >= TYPE_REAL64) return (real64 <> other.real64).sign
        if (type == TYPE_REAL   or other.type == TYPE_REAL)   return (real   <> other.real  ).sign
        if (type == TYPE_REAL32 or other.type == TYPE_REAL32) return (real32 <> other.real32).sign
        return (int64 <> other.int64).sign
      endIf

      if (type >= TYPE_FIRST_STRINGLIKE and type <= TYPE_LAST_STRINGLIKE and
          other.type >= TYPE_FIRST_STRINGLIKE and other.type <= TYPE_LAST_STRINGLIKE)
        return object->(as String) <> other.object->(as String)
      endIf

      if (type != other.type) return type <> other.type

      which (type)
        case TYPE_LOGICAL
          return logical <> other.logical
        case TYPE_NULL
          return 0  # equal
        case TYPE_XY, TYPE_ANCHOR
          return xy <> other.xy
        case TYPE_XYZ
          return xyz <> other.xyz
        case TYPE_XYZW
          return xyzw <> other.xyzw
        case TYPE_BOX
          return box <> other.box
        case TYPE_QUAD32
          return quad32 <> other.quad32
        case TYPE_CIRCLE
          return circle <> other.circle
        case TYPE_GLOBAL_ID
          return global_id.value <> other.global_id.value
        case TYPE_TRIANGLE
          return triangle <> other.triangle
        case TYPE_LINE
          return line <> other.line
        case TYPE_OBJECT
          if (object == other.object) return 0
          return object.object_id <> other.object.object_id
        case TYPE_STRING, TYPE_FILE
          return object->(as String) <> other.object->(as String)
        case TYPE_LIST
          if (object->(as Variant[]) == other.object->(as Variant[])) return 0
          return object.object_id <> other.object.object_id
        case TYPE_TABLE
          if (object->(as [Variant:Variant]) == other.object->(as [Variant:Variant])) return 0
          return object.object_id <> other.object.object_id
        others
          return type <> other.type
      endWhich

    method operator-()->Variant
      which (type)
        case TYPE_BYTE:      return Variant( -byte )
        case TYPE_INT:       return Variant( -integer )
        case TYPE_REAL:      return Variant( -real )
        case TYPE_LOGICAL:   return Variant( -logical )
        case TYPE_XY:        return Variant( -xy )
        case TYPE_XYZ:       return Variant( -xyz )
        case TYPE_XYZW:      return Variant( -xyzw )
        others
          return undefined
      endWhich

    method operator!()->Variant
      if (this.is_number)
        return Variant( !(this->Int) )
      else
        return undefined
      endIf

    method operator+( other:Variant )->Variant
      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      + b.byte )
        case TYPE_CHARACTER: return Variant( a.character + b.character )
        case TYPE_INT32:     return Variant( a.int32     + b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 + b.int32) )
        case TYPE_INT:       return Variant( a.integer   + b.integer )
        case TYPE_INT64:     return Variant( a.int64     + b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    + b.real32 )
        case TYPE_REAL:      return Variant( a.real      + b.real )
        case TYPE_REAL64:    return Variant( a.real64    + b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   + b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   + b.radians )
        case TYPE_LOGICAL:   return Variant( a.logical or b.logical )
        case TYPE_XY:        return Variant( a.xy        + b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       + b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      + b.xyzw )
        case TYPE_STRING:    return Variant( a->String   + b->String )
        case TYPE_FILE:      return Variant( File(a->String + b->String) )
        others
          return undefined
      endWhich

    method operator-( other:Variant )->Variant
      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      - b.byte )
        case TYPE_CHARACTER: return Variant( a.character - b.character )
        case TYPE_INT32:     return Variant( a.int32     - b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 - b.int32) )
        case TYPE_INT:       return Variant( a.integer   - b.integer )
        case TYPE_INT64:     return Variant( a.int64     - b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    - b.real32 )
        case TYPE_REAL:      return Variant( a.real      - b.real )
        case TYPE_REAL64:    return Variant( a.real64    - b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   - b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   - b.radians )
        case TYPE_XY:        return Variant( a.xy        - b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       - b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      - b.xyzw )
        others
          return undefined
      endWhich

    method operator*( other:Variant )->Variant
      if (other.is_number)
        if (this.type == TYPE_STRING) return Variant( this->String * other->Int )
        if (this.type == TYPE_FILE)   return Variant( File(this->String * other->Int) )
      endIf
      if (this.is_number)
        if (other.type == TYPE_STRING) return Variant( other->String * this->Int )
        if (other.type == TYPE_FILE)   return Variant( File(other->String * this->Int) )
      endIf

      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      * b.byte )
        case TYPE_CHARACTER: return Variant( a.character * b.character )
        case TYPE_INT32:     return Variant( a.int32     * b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 * b.int32) )
        case TYPE_INT:       return Variant( a.integer   * b.integer )
        case TYPE_INT64:     return Variant( a.int64     * b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    * b.real32 )
        case TYPE_REAL:      return Variant( a.real      * b.real )
        case TYPE_REAL64:    return Variant( a.real64    * b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   * b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   * b.radians )
        case TYPE_LOGICAL:   return Variant( a.logical and b.logical )
        case TYPE_XY:        return Variant( a.xy        * b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       * b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      * b.xyzw )
        others
          return undefined
      endWhich

    method operator/( other:Variant )->Variant
      if (type == TYPE_STRING)
        if (other.type == TYPE_STRING) return Variant( this->String / other->String )
        if (other.type == TYPE_FILE)   return Variant( File(this->String / other->String) )
      elseIf (type == TYPE_FILE)
        if (other.type == TYPE_STRING or other.type == TYPE_FILE)
          return Variant( File(this->String / other->String) )
        endIf
      endIf

      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      / b.byte )
        case TYPE_CHARACTER: return Variant( a.character / b.character )
        case TYPE_INT32:     return Variant( a.int32     / b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 / b.int32) )
        case TYPE_INT:       return Variant( a.integer   / b.integer )
        case TYPE_INT64:     return Variant( a.int64     / b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    / b.real32 )
        case TYPE_REAL:      return Variant( a.real      / b.real )
        case TYPE_REAL64:    return Variant( a.real64    / b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   / b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   / b.radians )
        case TYPE_XY:        return Variant( a.xy        / b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       / b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      / b.xyzw )
        others
          return undefined
      endWhich

    method operator%( other:Variant )->Variant
      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      % b.byte )
        case TYPE_CHARACTER: return Variant( a.character % b.character )
        case TYPE_INT32:     return Variant( a.int32     % b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 % b.int32) )
        case TYPE_INT:       return Variant( a.integer   % b.integer )
        case TYPE_INT64:     return Variant( a.int64     % b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    % b.real32 )
        case TYPE_REAL:      return Variant( a.real      % b.real )
        case TYPE_REAL64:    return Variant( a.real64    % b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   % b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   % b.radians )
        case TYPE_XY:        return Variant( a.xy        % b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       % b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      % b.xyzw )
        others
          return undefined
      endWhich

    method operator^( other:Variant )->Variant
      local (a,b) = to_compatible_values( other )
      which (a.type)
        case TYPE_BYTE:      return Variant( a.byte      ^ b.byte )
        case TYPE_CHARACTER: return Variant( a.character ^ b.character )
        case TYPE_INT32:     return Variant( a.int32     ^ b.int32 )
        case TYPE_COLOR:     return Variant( Color(a.int32 ^ b.int32) )
        case TYPE_INT:       return Variant( a.integer   ^ b.integer )
        case TYPE_INT64:     return Variant( a.int64     ^ b.int64 )
        case TYPE_REAL32:    return Variant( a.real32    ^ b.real32 )
        case TYPE_REAL:      return Variant( a.real      ^ b.real )
        case TYPE_REAL64:    return Variant( a.real64    ^ b.real64 )
        case TYPE_DEGREES:   return Variant( a.degrees   ^ b.degrees )
        case TYPE_RADIANS:   return Variant( a.radians   ^ b.radians )
        case TYPE_XY:        return Variant( a.xy        ^ b.xy )
        case TYPE_XYZ:       return Variant( a.xyz       ^ b.xyz )
        case TYPE_XYZW:      return Variant( a.xyzw      ^ b.xyzw )
        others
          return undefined
      endWhich

    method operator&( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 & other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   & other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32 & other->Int32))
        else                                                return Variant( this->Int32 & other->Int32 )
      else
        return undefined
      endIf

    method operator|( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 | other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   | other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32 | other->Int32))
        else                                                return Variant( this->Int32 | other->Int32 )
      else
        return undefined
      endIf

    method operator~( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 ~ other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   ~ other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32 ~ other->Int32))
        else                                                return Variant( this->Int32 ~ other->Int32 )
      else
        return undefined
      endIf

    method operator:<<:( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 :<<: other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   :<<: other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32:<<:other->Int32))
        else                                                return Variant( this->Int32 :<<: other->Int32 )
      else
        return undefined
      endIf

    method operator:>>:( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 :>>: other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   :>>: other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32:>>:other->Int32))
        else                                                return Variant( this->Int32 :>>: other->Int32 )
      else
        return undefined
      endIf

    method operator:>>>:( other:Variant )->Variant
      if (this.is_number and other.is_number)
        if (type == TYPE_INT64 or other.type == TYPE_INT64) return Variant( this->Int64 :>>>: other->Int64 )
        elseIf (type == TYPE_INT or other.type == TYPE_INT) return Variant( this->Int   :>>>: other->Int )
        elseIf (type == TYPE_COLOR or other.type == TYPE_COLOR) return Variant(Color(this->Int32:>>>:other->Int32))
        else                                                return Variant( this->Int32 :>>>: other->Int32 )
      else
        return undefined
      endIf

    method print_to( buffer:PrintWriter )
      which (type)
        case TYPE_UNDEFINED: return
        case TYPE_NULL:      buffer.print( "null" )
        case TYPE_LOGICAL:   buffer.print( which{logical:"true" || "false"} )
        case TYPE_BYTE:      byte.print_to( buffer )
        case TYPE_CHARACTER: character.print_to( buffer )
        case TYPE_COLOR:     color.print_to( buffer )
        case TYPE_FILE:      buffer.print( object->(as String) )
        case TYPE_GLOBAL_ID: global_id.print_to( buffer )
        case TYPE_INT32:     int32.print_to( buffer )
        case TYPE_INT:       integer.print_to( buffer )
        case TYPE_INT64:     int64.print_to( buffer )
        case TYPE_REAL32:    real32.print_to( buffer )
        case TYPE_REAL:      real.print_to( buffer )
        case TYPE_REAL64:    real64.print_to( buffer )
        case TYPE_DEGREES:   degrees.print_to( buffer )
        case TYPE_RADIANS:   radians.print_to( buffer )
        case TYPE_XY:        xy.print_to( buffer )
        case TYPE_XYZ:       xyz.print_to( buffer )
        case TYPE_XYZW:      xyzw.print_to( buffer )
        case TYPE_ANCHOR:    Anchor(xy).print_to( buffer )
        case TYPE_BOX:       box.print_to( buffer )
        case TYPE_QUAD32:    quad32.print_to( buffer )
        case TYPE_CIRCLE:    circle.print_to( buffer )
        case TYPE_TRIANGLE:  triangle.print_to( buffer )
        case TYPE_LINE:      line.print_to( buffer )
        case TYPE_STRING:    buffer.print( object->(as String) )
        others
          if (object)
            object.print_to( buffer )
          else
            Global.error.print( "[Variant.print_to()] Undefined type $"(type) )
            buffer.print "undefined"
          endIf
      endWhich

    method remove( value:Variant )->Variant
      which (type)
        case TYPE_LIST
          return object->(as Variant[]).remove( value )
        case TYPE_TABLE
          return object->(as [Variant:Variant]).remove( value )
        others
          return undefined
      endWhich

    method remove_at( index:Int )->Variant
      if (index < 0 or index >= count) return undefined
      which (type)
        case TYPE_LIST
          return object->(as Variant[]).remove_at( index )
        case TYPE_TABLE
          return object->(as [Variant:Variant]).remove_at( index )
        others
          return undefined
      endWhich

    method remove_first->Variant
      return remove_at( 0 )

    method remove_last->Variant
      return remove_at( count - 1 )

    method set( index:Int, value:Variant )
      which (type)
        case TYPE_LIST
          local list = object->(as Variant[])
          if (index < 0 or index >= list.count) return
          list[index] = value
        case TYPE_TABLE
          set( Variant(index), value )
      endWhich

    method set( key:String, value:Variant ) [preferred]
      set( Variant(key), value )

    method set( key:Variant, value:Variant )
      which (type)
        case TYPE_LIST
          if (key.is_number) set( key->Int, value )

        case TYPE_TABLE
          object->(as [Variant:Variant])[ key ] = value
      endWhich

    method sort( compare_fn:(Function(Variant,Variant)->Logical) )
      # 'compare_fn' should return true if the first parameter should be positioned before the second parameter.
      # The values passed will be keys for a Variant Table or elements for a Variant List.
      which (type)
        case TYPE_LIST
          object->(as Variant[]).sort( compare_fn )
        case TYPE_TABLE
          local table = object->(as [Variant:Variant])
          table.sort( (a,b) => compare_fn(a.key,b.key) )
      endWhich

    method to->Anchor
      which (type)
        case TYPE_ANCHOR, TYPE_XY: return Anchor( xy )
        others:                    return Anchor( this->XY )
      endWhich

    method to->Box
      which (type)
        case TYPE_BOX:      return box
        case TYPE_QUAD32:   return quad32->Quad->Box
        case TYPE_CIRCLE:   return circle.bounding_box
        case TYPE_TRIANGLE: return triangle.bounding_box
        case TYPE_LINE:     return line.bounding_box
        case TYPE_XY:       return xy.bounding_box
        others:             return $defaultValue<<Box>>
      endWhich

    method to->Byte
      which (type)
        case TYPE_BYTE:      return byte
        case TYPE_CHARACTER: return character->Byte
        case TYPE_INT32:     return int32->Byte
        case TYPE_COLOR:     return color.argb->Byte
        case TYPE_INT:       return integer->Byte
        case TYPE_INT64:     return int64->Byte
        case TYPE_REAL32:    return real32->Byte
        case TYPE_REAL:      return real->Byte
        case TYPE_REAL64:    return real64->Byte
        case TYPE_DEGREES:   return degrees.value->Byte
        case TYPE_RADIANS:   return radians.value->Byte
        case TYPE_OBJECT:    return (object->String->Int)?
        case TYPE_STRING:    return (object->String->Int)?
        case TYPE_FILE:      return (object->String->Int)?
        others:              return 0
      endWhich

    method to->Character
      which (type)
        case TYPE_BYTE:      return byte->Character
        case TYPE_CHARACTER: return character
        case TYPE_COLOR:     return color.argb->Character
        case TYPE_INT32:     return int32->Character
        case TYPE_INT:       return integer->Character
        case TYPE_INT64:     return int64->Character
        case TYPE_REAL32:    return real32->Character
        case TYPE_REAL:      return real->Character
        case TYPE_REAL64:    return real64->Character
        case TYPE_DEGREES:   return degrees.value->Character
        case TYPE_RADIANS:   return radians.value->Character
        case TYPE_OBJECT, TYPE_STRING, TYPE_FILE
          local st = object->String
          if (st and st.count) return st[0]
          else                 return 0
        others:              return 0
      endWhich

    method to->Circle
      which (type)
        case TYPE_BOX:    return Circle( box.position + box.size/2, box.size.max/2 )
        case TYPE_QUAD32: return this->Box->Circle
        case TYPE_CIRCLE: return circle
        others:           return $defaultValue<<Circle>>
      endWhich

    method to->Color
      which (type)
        case TYPE_COLOR:     return color
        others:              return Color( this->Int32 )
      endWhich

    method to->Degrees
      which (type)
        case TYPE_BYTE:      return Degrees(byte->Real)
        case TYPE_CHARACTER: return Degrees(character->Real)
        case TYPE_COLOR:     return Degrees(color.argb)
        case TYPE_DEGREES:   return degrees
        case TYPE_INT32:     return Degrees(int32->Real)
        case TYPE_INT:       return Degrees(integer->Real)
        case TYPE_INT64:     return Degrees(int64->Real)
        case TYPE_RADIANS:   return Degrees(radians)
        case TYPE_REAL32:    return Degrees(real32->Real)
        case TYPE_REAL:      return Degrees(real->Real)
        case TYPE_REAL64:    return Degrees(real64->Real)
        case TYPE_OBJECT:    return Degrees(object->String->Real)
        case TYPE_STRING:    return Degrees(object->String->Real)
        case TYPE_FILE:      return Degrees(object->String->Real)
        others:              return Degrees(0)
      endWhich

    method to->File
      return File( this->String )

    method to->GlobalID
      which (type)
        case TYPE_INT32:  return GlobalID(int32)
        case TYPE_INT:    return GlobalID(integer)
        case TYPE_INT64:  return GlobalID(int64)
        case TYPE_STRING: return GlobalID(object->String)
        others:           return <Undefined>
      endWhich

    method to->Line
      which (type)
        case TYPE_LINE:   return line
        others:           return $defaultValue<<Line>>
      endWhich

    method to->Quad
      which (type)
        case TYPE_QUAD32: return quad32->Quad
        others:           return this->Box->Quad
      endWhich

    method to->Quad32
      return Quad32( this->Quad )

    method to->Int32
      which (type)
        case TYPE_BYTE:      return byte->Int32
        case TYPE_CHARACTER: return character->Int32
        case TYPE_COLOR:     return color.argb
        case TYPE_GLOBAL_ID: return global_id.value->Int32
        case TYPE_INT32:     return int32->Int32
        case TYPE_INT:       return integer->Int32
        case TYPE_INT64:     return int64->Int32
        case TYPE_REAL32:    return real32->Int32
        case TYPE_REAL:      return real->Int32
        case TYPE_REAL64:    return real64->Int32
        case TYPE_DEGREES:   return degrees.value->Int32
        case TYPE_RADIANS:   return radians.value->Int32
        case TYPE_OBJECT:    return object->String->Int32
        case TYPE_STRING:    return object->String->Int32
        case TYPE_FILE:      return object->String->Int32
        others:              return 0
      endWhich

    method to->Int
      which (type)
        case TYPE_BYTE:      return byte->Int
        case TYPE_CHARACTER: return character->Int
        case TYPE_COLOR:     return color.argb->Int
        case TYPE_GLOBAL_ID: return global_id.value->Int
        case TYPE_INT32:     return int32->Int
        case TYPE_INT:       return integer->Int
        case TYPE_INT64:     return int64->Int
        case TYPE_REAL32:    return real32->Int
        case TYPE_REAL:      return real->Int
        case TYPE_REAL64:    return real64->Int
        case TYPE_DEGREES:   return degrees.value->Int
        case TYPE_RADIANS:   return radians.value->Int
        case TYPE_OBJECT:    return object->String->Int
        case TYPE_STRING:    return object->String->Int
        case TYPE_FILE:      return object->String->Int
        others:              return 0
      endWhich

    method to->Int64
      which (type)
        case TYPE_BYTE:      return byte->Int64
        case TYPE_CHARACTER: return character->Int64
        case TYPE_COLOR:     return color.argb->Int64
        case TYPE_GLOBAL_ID: return global_id.value->Int64
        case TYPE_INT32:     return int32->Int64
        case TYPE_INT:       return integer->Int64
        case TYPE_INT64:     return int64->Int64
        case TYPE_REAL32:    return real32->Int64
        case TYPE_REAL:      return real->Int64
        case TYPE_REAL64:    return real64->Int64
        case TYPE_DEGREES:   return degrees.value->Int64
        case TYPE_RADIANS:   return radians.value->Int64
        case TYPE_OBJECT:    return object->String->Int64
        case TYPE_STRING:    return object->String->Int64
        case TYPE_FILE:      return object->String->Int64
        others:              return 0
      endWhich

    method to->Logical
      which (type)
        case TYPE_LOGICAL:   return logical
        case TYPE_BYTE:      return byte?
        case TYPE_CHARACTER: return character?
        case TYPE_COLOR:     return color.argb?
        case TYPE_INT32:     return int32?
        case TYPE_INT:       return integer?
        case TYPE_INT64:     return int64?
        case TYPE_REAL32:    return real32?
        case TYPE_REAL:      return real?
        case TYPE_REAL64:    return real64?
        case TYPE_DEGREES:   return degrees?
        case TYPE_RADIANS:   return radians?
        case TYPE_XY, TYPE_ANCHOR: return xy.x? or xy.y?
        case TYPE_XYZ:       return xyz.x? or xyz.y? or xyz.z?
        case TYPE_XYZW:      return xyzw.x? or xyzw.y? or xyzw.z? or xyzw.w?
        case TYPE_BOX:       return box.size.x? or box.size.y?
        case TYPE_QUAD32:    return quad32.a? or quad32.b? or quad32.c? or quad32.d?
        case TYPE_CIRCLE:    return circle.radius?
        case TYPE_LINE:      return line.a != line.b;
        others
          return (type >= TYPE_OBJECT)
      endWhich

    method to->Object
      if (type >= TYPE_OBJECT) return object
      else                     return null

    method to->Radians
      which (type)
        case TYPE_BYTE:      return Radians(byte->Real)
        case TYPE_CHARACTER: return Radians(character->Real)
        case TYPE_COLOR:     return Radians(color.argb)
        case TYPE_DEGREES:   return Radians(degrees)
        case TYPE_INT32:     return Radians(int32->Real)
        case TYPE_INT:       return Radians(integer->Real)
        case TYPE_INT64:     return Radians(int64->Real)
        case TYPE_RADIANS:   return radians
        case TYPE_REAL32:    return Radians(real32->Real)
        case TYPE_REAL:      return Radians(real->Real)
        case TYPE_REAL64:    return Radians(real64->Real)
        case TYPE_OBJECT:    return Radians(object->String->Real)
        case TYPE_STRING:    return Radians(object->String->Real)
        case TYPE_FILE:      return Radians(object->String->Real)
        others:              return Radians(0)
      endWhich

    method to->Real32
      which (type)
        case TYPE_BYTE:      return byte->Real32
        case TYPE_CHARACTER: return character->Real32
        case TYPE_COLOR:     return color.argb->Real32
        case TYPE_INT32:     return int32->Real32
        case TYPE_INT:       return integer->Real32
        case TYPE_INT64:     return int64->Real32
        case TYPE_REAL32:    return real32->Real32
        case TYPE_REAL:      return real->Real32
        case TYPE_REAL64:    return real64->Real32
        case TYPE_DEGREES:   return degrees.value->Real32
        case TYPE_RADIANS:   return radians.value->Real32
        case TYPE_OBJECT:    return object->String->Real32
        case TYPE_STRING:    return object->String->Real32
        case TYPE_FILE:      return object->String->Real32
        others:              return 0
      endWhich

    method to->Real
      which (type)
        case TYPE_BYTE:      return byte->Real
        case TYPE_CHARACTER: return character->Real
        case TYPE_COLOR:     return color.argb->Real
        case TYPE_INT32:     return int32->Real
        case TYPE_INT:       return integer->Real
        case TYPE_INT64:     return int64->Real
        case TYPE_REAL32:    return real32->Real
        case TYPE_REAL:      return real->Real
        case TYPE_REAL64:    return real64->Real
        case TYPE_DEGREES:   return degrees.value->Real
        case TYPE_RADIANS:   return radians.value->Real
        case TYPE_OBJECT:    return object->String->Real
        case TYPE_STRING:    return object->String->Real
        case TYPE_FILE:      return object->String->Real
        others:              return 0
      endWhich

    method to->Real64
      which (type)
        case TYPE_BYTE:      return byte->Real64
        case TYPE_CHARACTER: return character->Real64
        case TYPE_COLOR:     return color.argb->Real64
        case TYPE_INT32:     return int32->Real64
        case TYPE_INT:       return integer->Real64
        case TYPE_INT64:     return int64->Real64
        case TYPE_REAL32:    return real32->Real64
        case TYPE_REAL:      return real->Real64
        case TYPE_REAL64:    return real64->Real64
        case TYPE_DEGREES:   return degrees.value->Real64
        case TYPE_RADIANS:   return radians.value->Real64
        case TYPE_OBJECT:    return object->String->Real64
        case TYPE_STRING:    return object->String->Real64
        case TYPE_FILE:      return object->String->Real64
        others:              return 0
      endWhich

    method to->String
      local result = String()
      print_to( result )
      return result

    method to->Triangle
      which (type)
        case TYPE_TRIANGLE: return triangle
        others:             return $defaultValue<<Triangle>>
      endWhich

    method to->XY
      which (type)
        case TYPE_XY, TYPE_ANCHOR: return xy
        case TYPE_XYZ:             return xyz->XY
        case TYPE_XYZW:            return xyzw->XY
        case TYPE_INT32:           return XY(int32,int32)
        case TYPE_INT:             return XY(integer,integer)
        case TYPE_INT64:           return XY(int64,int64)
        case TYPE_REAL32:          return XY(real32,real32)
        case TYPE_REAL:            return XY(real,real)
        case TYPE_REAL64:          return XY(real64,real64)
        others:                    return $defaultValue<<XY>>
      endWhich

    method to->XYZ
      which (type)
        case TYPE_XY:              return XYZ(xy)
        case TYPE_XYZ:             return xyz
        case TYPE_XYZW:            return xyzw->XYZ
        case TYPE_INT32:           return XYZ(int32,int32,int32)
        case TYPE_INT:             return XYZ(integer,integer,integer)
        case TYPE_INT64:           return XYZ(int64,int64,int64)
        case TYPE_REAL32:          return XYZ(real32,real32,real32)
        case TYPE_REAL:            return XYZ(real,real,real)
        case TYPE_REAL64:          return XYZ(real64,real64,real64)
        others:                    return $defaultValue<<XYZ>>
      endWhich

    method to->XYZW
      which (type)
        case TYPE_XY:              return XYZW(xy)
        case TYPE_XYZ:             return XYZW(xyz)
        case TYPE_XYZW:            return xyzw
        case TYPE_INT32:           return XYZW(int32,int32,int32)
        case TYPE_INT:             return XYZW(integer,integer,integer)
        case TYPE_INT64:           return XYZW(int64,int64,int64)
        case TYPE_REAL32:          return XYZW(real32,real32,real32)
        case TYPE_REAL:            return XYZW(real,real,real)
        case TYPE_REAL64:          return XYZW(real64,real64,real64)
        others:                    return $defaultValue<<XYZW>>
      endWhich

    method to<<$Type>>->$Type
      if ($isReference<<$Type>>)
        return this->Object->(as $Type)
      elseIf ($isEnum<<$Type>>)
        local st = this->String
        if (st) return $Type(st)
        else    return $Type(0)
      elseIf ($Type instanceOf OptionalType)
        if (type == TYPE_NULL or type == TYPE_UNDEFINED) return null
        if ($exists<<$Type(this)>>)
          return $Type(this)
        elseIf (type == TYPE_OBJECT)
          local boxed = this->Object->(as Boxed<<$Type>>)
          if (boxed) return boxed->$Type
          return $defaultValue<<$Type>>
        else
          return $defaultValue<<$Type>>
        endIf
      else
        local boxed = this->Object->(as Boxed<<$Type>>)
        if (boxed) return boxed->$Type
        return $defaultValue<<$Type>>
      endIf

    method to->JSON( &formatted, &omit_commas )
      local result = JSON()
      write_json( result, &=formatted, &=omit_commas )
      return result

    method to_optional<<$Type>>->$Type?
      if (type == TYPE_NULL or type == TYPE_UNDEFINED) return null
      return to<<$Type>>

    method to_compatible_values( other:Variant )->(Variant,Variant)
      if (type == other.type) return (this,other)
      if (type == TYPE_FILE or other.type == TYPE_FILE) return (Variant(this->File),Variant(other->File))
      if (type == TYPE_STRING or other.type == TYPE_STRING) return (Variant(this->String),Variant(other->String))
      if (type == TYPE_UNDEFINED or other.type == TYPE_UNDEFINED) return (undefined,undefined)

      if (type <= TYPE_LAST_NUMBER and other.type <= TYPE_LAST_NUMBER)
        if (type == TYPE_RADIANS or other.type == TYPE_RADIANS)
          return (Variant(this->Radians),Variant(other->Radians))
        elseIf (type == TYPE_DEGREES or other.type == TYPE_DEGREES)
          return (Variant(this->Degrees),Variant(other->Degrees))
        endIf
        if (type == TYPE_REAL64 or other.type == TYPE_REAL64) return (Variant(this->Real64),Variant(other->Real64))
        if (type == TYPE_REAL   or other.type == TYPE_REAL)   return (Variant(this->Real),  Variant(other->Real))
        if (type == TYPE_REAL32 or other.type == TYPE_REAL32) return (Variant(this->Real32),Variant(other->Real32))
        if (type == TYPE_INT64 or other.type == TYPE_INT64)   return (Variant(this->Int64), Variant(other->Int64))
        if (type == TYPE_INT   or other.type == TYPE_INT)     return (Variant(this->Int),   Variant(other->Int))
        if (type == TYPE_COLOR or other.type == TYPE_COLOR)   return (Variant(this->Color), Variant(other->Color))
        if (type == TYPE_INT32 or other.type == TYPE_INT32)   return (Variant(this->Int32), Variant(other->Int32))
        if (type == TYPE_CHARACTER or other.type == TYPE_CHARACTER) return (Variant(this->Character),Variant(other->Character))
        return (Variant(this->Byte),Variant(other->Byte))
      endIf

      if (type >= TYPE_XY and type <= TYPE_XYZW and other.type >= TYPE_XY and other.type <= TYPE_XYZW)
        if (type == TYPE_XYZW or other.type == TYPE_XYZW) return (this->XYZW,other->XYZW)
        if (type == TYPE_XYZ  or other.type == TYPE_XYZ)  return (this->XYZ, other->XYZ)
        return (this->XY, other->XY)
      endIf


      return (undefined,undefined)

    method to_json( &formatted, &omit_commas )->JSON
      local result = JSON()
      write_json( result, &=formatted, &=omit_commas )
      return result

    method to_list<<$DataType>>->$DataType[]
      local result = $DataType[]( count )
      forEach (value in this)
        result.add( value->$DataType )
      endForEach
      return result

    method values->TableValuesIterator<<Variant,Variant>>
      if (type != TYPE_TABLE) return TableValuesIterator<<Variant,Variant>>( null )
      return object->(as [Variant:Variant]).values

    method write_json( builder:JSON, &formatted, &omit_commas, &ending_newline=true )
      which (type)
        case TYPE_UNDEFINED
          noAction
        case TYPE_BYTE
          builder.print( byte )
        case TYPE_CHARACTER
          # Write single character as a string
          builder.print '"'
          write_json_character( character, builder )
          builder.print '"'
        case TYPE_COLOR
          builder.print( color.argb )
        case TYPE_INT32
          builder.print( int32 )
        case TYPE_INT
          builder.print( integer )
        case TYPE_INT64
          builder.print( int64 )
        case TYPE_REAL32
          if (real32 == real32->Int) builder.print( real32->Int )
          else                       builder.print( real32 )
        case TYPE_REAL
          if (real == real->Int) builder.print( real->Int )
          else                   builder.print( real )
        case TYPE_REAL64
          if (real64 == real64->Int) builder.print( real64->Int )
          else                       builder.print( real64 )
        case TYPE_DEGREES
          builder.print( degrees.value )
        case TYPE_RADIANS
          builder.print( radians.value )
        case TYPE_LOGICAL
          builder.print( logical )
        case TYPE_NULL
          builder.print( "null" )
        case TYPE_XY:
          .write_json_table_begin( builder, &=formatted )
          .write_json_table_value( builder, "x", xy.x, &=formatted, &=omit_commas, &first )
          .write_json_table_value( builder, "y", xy.y, &=formatted, &=omit_commas )
          .write_json_table_end( builder, &=formatted )
        case TYPE_XYZ
          .write_json_table_begin( builder, &=formatted )
          .write_json_table_value( builder, "x", xyz.x, &=formatted, &=omit_commas, &first )
          .write_json_table_value( builder, "y", xyz.y, &=formatted, &=omit_commas )
          .write_json_table_value( builder, "z", xyz.z, &=formatted, &=omit_commas )
          .write_json_table_end( builder, &=formatted )
        case TYPE_XYZW
          .write_json_table_begin( builder, &=formatted )
          .write_json_table_value( builder, "x", xyzw.x, &=formatted, &=omit_commas, &first )
          .write_json_table_value( builder, "y", xyzw.y, &=formatted, &=omit_commas )
          .write_json_table_value( builder, "z", xyzw.z, &=formatted, &=omit_commas )
          .write_json_table_value( builder, "w", xyzw.w, &=formatted, &=omit_commas )
          .write_json_table_end( builder, &=formatted )
        case TYPE_ANCHOR
          write_json_string( Anchor(xy).name, builder )
        case TYPE_BOX
          builder.[ print('['), print(box.position.x), print(','), print(box.position.y) ]
          builder.[ print(','), print(box.size.x),     print(','), print(box.size.y), print(']') ]
        case TYPE_CIRCLE
          builder.[ print("[["), print(circle.position.x), print(','), print(circle.position.y) ]
          builder.[ print("],"), print(circle.radius), print("]") ]
        case TYPE_FILE
          write_json_string( object->(as String), builder )
        case TYPE_GLOBAL_ID
          write_json_string( global_id->String, builder )
        case TYPE_LINE
          builder.[ print("[["), print(line.a.x), print(','), print(line.a.y), print("],[") ]
          builder.[ print(line.b.x), print(','), print(line.b.y), print("]]") ]
        case TYPE_TRIANGLE
          builder.[ print("[["), print(quad32.a.x), print(','), print(quad32.a.y), print("],[") ]
          builder.[ print(quad32.b.x), print(','), print(quad32.b.y), print("],[") ]
          builder.[ print(quad32.c.x), print(','), print(quad32.c.y), print("]]") ]
        case TYPE_QUAD32
          builder.[ print("[["), print(quad32.a.x), print(','), print(quad32.a.y), print("],[") ]
          builder.[ print(quad32.b.x), print(','), print(quad32.b.y), print("],[") ]
          builder.[ print(quad32.c.x), print(','), print(quad32.c.y), print("],[") ]
          builder.[ print(quad32.d.x), print(','), print(quad32.d.y), print("]]") ]
        case TYPE_OBJECT
          object.write_json( builder, &=formatted, &=omit_commas, &!ending_newline )
        case TYPE_STRING
          write_json_string( object->(as String), builder )
        case TYPE_TABLE
          if (count)
            builder.print '{'
            if (formatted) builder.indent+=2; builder.println
            forEach (entry at i in object->(as [Variant:Variant]).entries)
              if (i)
                if (omit_commas) builder.print ' '
                else             builder.print ','
                if (formatted) builder.println
              endIf
              write_json_string( entry.key, builder )
              builder.print ':'
              entry.value.write_json( builder, &=formatted, &=omit_commas, &!ending_newline )
            endForEach
            if (formatted) builder.indent-=2; builder.println
            builder.print '}'
          else
            builder.print "{}"
          endIf
        others
          if (is_list and count)
            builder.print '['
            if (formatted) builder.indent+=2; builder.println
            forEach (item at i in this)
              if (i)
                if (omit_commas) builder.print ' '
                else             builder.print ','
                if (formatted) builder.println
              endIf
              item.write_json( builder, &=formatted, &=omit_commas, &!ending_newline )
            endForEach
            if (formatted) builder.indent-=2; builder.println
            builder.print ']'
          else
            builder.print "[]"
          endIf
      endWhich

      if (formatted and ending_newline) builder.println

    method write_json_string( st:String, builder:JSON )
      builder.print '"'
      write_json_character( (forEach in st), builder )
      builder.print '"'

    method write_json_character( ch:Character, builder:JSON )
      which (ch)
        case '"':
          builder.print( "\\\"" )
        case '\\':
          builder.print( "\\\\" )
        case '\b':
          builder.print( "\\b" )
        case '\f':
          builder.print( "\\f" )
        case '\n':
          builder.print( "\\n" )
        case '\r':
          builder.print( "\\r" )
        case '\t':
          builder.print( "\\t" )
        others
          if (ch >= 32 and ch <= 126)
            builder.print( ch )
          elseIf (ch < 32 or ch == 127 or ch == 0x2028 or ch == 0x2029)
            # RE: 2028/2029:
            # http://stackoverflow.com/questions/2965293/javascript-parse-error-on-u2028-unicode-character
            builder.print( "\\u" )
            local n = ch : Int
            loop 4
              local digit = (n :>>>: 12) & 15
              n = n:<<:4
              if (digit <= 9)
                builder.print( digit )
              else
                builder.print( ('a' + (digit - 10))->Character )
              endIf
            endLoop
          else
            # Store printable Unicode without encoding as \\uXXXX
            builder.print( ch )
          endIf
      endWhich

    method .write_json_table_begin( builder:JSON, &formatted )
      builder.print '{'
      if (formatted)
        builder.indent += 2
        builder.println
      endIf

    method .write_json_table_value( builder:JSON, key:String, value:Variant,
        &formatted, &omit_commas, &first )
      if (not first)
        if (omit_commas) builder.print ' '
        else             builder.print ','
        if (formatted) builder.println
      endIf

      write_json_string( key, builder )
      builder.print ':'
      value.write_json( builder, &=formatted, &=omit_commas, &!ending_newline )

    method .write_json_table_end( builder:JSON, &formatted )
      if (formatted)
        builder.indent -= 2
        builder.println
      endIf
      builder.print '}'

endClass

augment Object
  METHODS
    method write_json( builder:JSON, &formatted, &omit_commas, &ending_newline=true )
      builder.[ print(''{"type":"''), print(type_name), print(''"}'') ]
endAugment

augment Optional
  GLOBAL METHODS
    method create_from( value:Variant )->$DataType?
      return $DataType?( value->$DataType )
endAugment

augment TableKeysIterator<<Rogue::Variant,Rogue::Variant>>
  METHODS
    method to->Variant
      return Variant(to_list)
endAugment

augment TableValuesIterator<<Rogue::Variant,Rogue::Variant>>
  METHODS
    method to->Variant
      return Variant(to_list)
endAugment

