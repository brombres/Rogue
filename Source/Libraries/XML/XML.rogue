module XML

# Simple XML parser
#
# Usage Sample:
#   uses XML
#
#   local xml = XML( File("Test.html") )
#   println xml
#   println xml->String( &formatted )
#
#   xml = XML( '<p><a href="https://github.com">Link</a></p>' )
#   # the "root" XML element will be a nameless "list" containing children
#
#   println xml.is_list        # true
#   println xml.count          # 1
#   println xml[0].name        # p
#   println xml[0][0].name     # a
#   println xml[0][0]//href    # https://github.com
#   println xml[0][0]["href"]  # https://github.com
#   println xml[0][0][0]       # Link
#
#   local img = XML.element( "img" )  # Creates an element node with the name (tag) "img"
#   img//src = "http://..."           # Set an attribute to a text value
#   local p = XML.element( "p" )
#   p.add( XML.text("ABC") )

enum XMLNodeType
  ELEMENT    # has a name and possibly attributes and child nodes
  LIST       # unnamed element with no attributes, just children
  TEXT       # a text node with no attributes or children
  START_TAG  # intermediate type
  END_TAG    # intermediate type
endEnum

class XML
  GLOBAL PROPERTIES
    next_filepath : String
    next_line     : Int32
    next_column   : Int32

  GLOBAL METHODS
    method create( file:File, line=1:Int32, column=1:Int32 )->XML
      return XMLParser().parse( file, line, column )

    method create( content:String, line=1:Int32, column=1:Int32 )->XML
      return create( "[Internal]", content, line, column )

    method create( filepath:String, content:String, line=1:Int32, column=1:Int32 )->XML
      return XMLParser().parse( filepath, content, line, column )

    method element( name=null:String )->XML
      return XML( XMLNodeType.ELEMENT, name  )

    method list->XML
      return XML( XMLNodeType.LIST )

    method set_position( filepath:String, line:Int32, column:Int32 )
      next_filepath = filepath
      next_line = line
      next_column = column

    method text( text:String )->XML
      return XML( XMLNodeType.TEXT, text )


  PROPERTIES
    filepath   = next_filepath : String
    line       = next_line     : Int32
    column     = next_column   : Int32
    type       : XMLNodeType
    attributes : StringTable<<String>>
    text       : String
    children   = XML[]

  METHODS
    method init( type, text=null )

    method add( child:XML )
      children.add( child )

    method content->String
      # 'children' returns a list of XML nodes but 'content' returns them in string form
      if (is_text) return text
      if (children.is_empty) return ""
      use builder = StringBuilder.pool
        builder.print( forEach in children )
        return builder->String
      endUse

    method count->Int32
      return children.count

    method get( index:Int32 )->XML
      if (index < 0 or index >= children.count) return null
      return children[ index ]

    method get( name:String )->String
      if (attributes is null) return null
      return attributes[ name ]

    method is_end_tag( name=null:String )->Logical
      if (type != XMLNodeType.END_TAG) return false
      if (name is null) return true
      return (name == text)

    method is_list->Logical
      return (type == XMLNodeType.LIST)

    method is_start_tag( name=null:String )->Logical
      if (type != XMLNodeType.START_TAG) return false
      if (name is null) return true
      return (name == text)

    method is_element( name=null:String )->Logical
      if (type != XMLNodeType.ELEMENT) return false
      if (name is null) return true
      return (name == text)

    method is_text->Logical
      return (type == XMLNodeType.TEXT)

    method name->String
      if (is_text or @text is null) return ""
      else                          return text

    method set( name:String, value:String )
      ensure attributes
      attributes[ name ] = value

    method to->String
      use builder = StringBuilder.pool
        return write( builder )->String
      endUse

    method to->String( &formatted )
      use builder = StringBuilder.pool
        return write( builder, &=formatted )->String
      endUse

    method write( builder:StringBuilder, &formatted )->StringBuilder
      if (is_text)
        builder.print( text )
      else
        if (name.count)
          builder.print( "<" )
          builder.print( name )
          if (attributes)
            forEach (entry in attributes.reader)
              builder.print( " " )
              builder.print( entry.key )
              builder.print( "=" )
              if (not entry.value.contains("\""))    builder.print( '"' ).print( entry.value ).print( '"' )
              elseIf (not entry.value.contains("'")) builder.print( "'" ).print( entry.value ).print( "'" )
              else                                   builder.print( '"' ).print( entry.value.replacing("\"","\\\"") ).print( '"' )
            endForEach
          endIf
          if (children.count)
            builder.print( ">" )
            if (formatted) builder.println; builder.indent += 2
            forEach (child in children)
              child.write( builder, &=formatted )
              if (formatted) builder.println
            endForEach
            if (formatted) builder.indent -= 2
            builder.print( "</" )
            builder.print( name )
            builder.print( ">" )
          else
            builder.print( "/>" )
          endIf
        else
          # Unnamed list element
          forEach (child in children)
            child.write( builder, &=formatted )
            if (formatted) builder.println
          endForEach
        endIf
      endIf
      return builder
endClass

augment XML[]
  METHODS
    method to->String
      <replace>
      use builder = StringBuilder.pool
        return write( builder )->String
      endUse

    method to->String( &formatted )
      use builder = StringBuilder.pool
        return write( builder, &=formatted )->String
      endUse

    method write( builder:StringBuilder, &formatted )->StringBuilder
      (forEach in this).write( builder, &=formatted )
      return builder
endAugment


class XMLParser
  GLOBAL PROPERTIES
    default_standalone_tags =
    [
      "area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"
    ]

  PROPERTIES
    standalone_tags = StringTable<<String>>()

  METHODS
    method init
      configure_standalone_tags

    method add_standalone_tag( name:String )
      # name example: image
      standalone_tags[ name ] = name

    method configure_standalone_tags
      add_standalone_tag( forEach in default_standalone_tags )

    method parse( file:File, line=1:Int32, column=1:Int32 )->XML
      return parse( file.filepath, String(file), line, column )

    method parse( filepath:String, content:String, line=1:Int32, column=1:Int32 )->XML
      local nodes = XMLNodifier().nodify( filepath, content, line, column )
      collapse_nodes( nodes )
      local result = XML.list
      result.add( forEach in nodes )
      return result

    method collapse_nodes( nodes:XML[] )
      local queue = XML[]

      forEach (node in nodes)
        if (node.is_start_tag and standalone_tags.contains(node.name))
          node.type = XMLNodeType.ELEMENT
        endIf
      endForEach

      local final_pass = false
      loop
        forEach (node at index in nodes)
          if (node.is_end_tag)
            forEach (start_node at start_i in queue step -1)
              if (start_node.is_start_tag)
                start_node.type = XMLNodeType.ELEMENT
                forEach (child_node in queue from start_i+1)
                  start_node.add( child_node )
                endForEach
                queue.discard_from( start_i + 1 )
                escapeForEach
              endIf
            endForEach
          else
            queue.add( node )
          endIf
        endForEach

        nodes.clear.add( queue )

        if (final_pass) escapeLoop
        final_pass = true

        # Add any missing end tags at the end of the remaining list and repeat collapse one more time
        forEach (node in queue step -1)
          if (node.is_start_tag) nodes.add( XML(XMLNodeType.END_TAG,node.name) )
        endForEach

        queue.clear
      endLoop
endClass


class XMLNodifier
  PROPERTIES
    scanner : XMLScanner
    nodes  : XML[]

  METHODS
    method init

    method nodify( file:File, line=1:Int32, column=1:Int32 )->XML[]
      return nodify( file.filepath, String(file), line, column )

    method nodify( filepath:String, content:String, line=1:Int32, column=1:Int32 )->XML[]
      scanner = XMLScanner( filepath, content, line, column )
      nodes  = XML[]
      while (tokenize_another) noAction
      return nodes

    method tokenize_another->Logical
      XML.set_position( scanner.filepath, scanner.line, scanner.column )
      if (not scanner.has_another) return false
      if (scanner.consume('<'))
        if (scanner.consume("!--"))   discard_comment
        elseIf (scanner.consume('/')) tokenize_end_tag
        else                          tokenize_tag
      else
        tokenize_text
      endIf
      return true

    method discard_comment
      while (scanner.has_another and not scanner.consume("-->")) scanner.read

    method tokenize_tag
      local t = XML( XMLNodeType.START_TAG, scanner.scan_lowercase_id )
      scanner.consume_whitespace
      while (scanner.has_another)
        if (scanner.consume('/'))
          t.type = XMLNodeType.ELEMENT
          scanner.consume_whitespace
        endIf
        if (not scanner.has_another) escapeWhile
        if (scanner.consume('>')) escapeWhile
        local name  = scanner.scan_lowercase_id
        if (name)
          local value = ""
          scanner.consume_whitespace
          if (scanner.consume('='))
            scanner.consume_whitespace
            value = scanner.scan_string
            if (value is null) value = scanner.scan_lowercase_id
            if (value is null) value = ""
          endIf
          t.set( name, value )
        else
          scanner.read  # read & discard
        endIf
        scanner.consume_whitespace
      endWhile
      if (t.name) nodes.add( t )  # otherwise skip an invalid tag

    method tokenize_end_tag
      local t = XML( XMLNodeType.END_TAG, scanner.scan_lowercase_id )
      while (scanner.has_another and not scanner.consume('>')) scanner.read
      if (t.name) nodes.add( t )  # otherwise skip an invalid tag

    method tokenize_text
      use builder = StringBuilder.pool
        if (scanner.consume_whitespace) builder.print( ' ' )
        while (scanner.has_another and not scanner.next_is('<'))
          builder.print( scanner.read )
          if (scanner.consume_whitespace) builder.print( ' ' )
        endWhile
        if (builder.count) nodes.add( XML(XMLNodeType.TEXT,builder->String) )
      endUse
endClass


class XMLScanner : Scanner
  PROPERTIES
    filepath    : String

  METHODS
    method init( filepath, content:String, line=1:Int32, column=1:Int32 )
      prior.init( content, &spaces_per_tab=2 )
      this.line = line
      this.column = column

    method consume_end_tag( name:String )->Logical
      if (not next_is_end_tag(name)) return false
      consume( '<' )
      consume( '/' )
      consume( name )
      consume_whitespace
      while (has_another and not consume('>')) read
      return false

    method consume_whitespace->Logical
      local found_whitespace = false
      while (consume_spaces or consume_eols) found_whitespace = true
      return found_whitespace

    method next_is_end_tag( name:String )->Logical
      if (name is null) return false
      if (not has_another(3+name.count)) return false
      if (peek(0) != '<') return false
      if (peek(1) != '/') return false
      forEach (ch at i in name)
        if (peek(2+i) != ch) return false
      endForEach
      which (peek(2+name.count))
        case '>', ' ', '\t': return true
        others:              return false
      endWhich

    method scan_lowercase_id->String
      local result = scan_identifier
      if (not result) return null
      local ch = peek
      while (ch == '-' or ch == ':')
        result += read
        local next_part = scan_identifier
        if (next_part) result += next_part
        ch = peek
      endWhile
      return result.to_lowercase
endClass

