enum StringEncoding
  UTF8           = 0
  ASCII          = 1
  ASCII_256      = 2
  EXTENDED_ASCII = 2
endEnum

class String
  GLOBAL METHODS
    method create( bytes:Byte[], encoding=StringEncoding.UTF8:StringEncoding )->String
      return create( bytes, 0, bytes.count, encoding )

    method create( bytes:Byte[], i1:Int32, count:Int32, encoding=StringEncoding.UTF8:StringEncoding )->String
      which (encoding)
        case StringEncoding.UTF8, StringEncoding.ASCII
          return native( 'RogueString_create_from_utf8( (char*)($bytes->data->as_bytes+$i1), $count )' )->String
        case StringEncoding.ASCII_256
          local buffer = StringBuilder( bytes.count )
          buffer.print( Character(forEach in bytes) )
          return buffer->String
        others
          throw Error( "Unsupported string encoding: " + encoding )
      endWhich

    method create( characters:Character[] )->String
      return native( 'RogueString_create_from_characters( $characters )' )->String

    method create( characters:StringBuilder )->String
      return create( characters.utf8 )

    method create( characters:StringBuilder, i1:Int32, count:Int32 )->String
      return create( characters.utf8, i1, count )

    method create( file:File, encoding=StringEncoding.UTF8:StringEncoding )->String
      return file.load_as_string( encoding )

    method create( value:Value )->String
      return value->String

    method operator==( a:String, b:String )->Logical
      if (a is null) return (b is null)
      else           return a.operator==( b )

    method operator==( a:String, b:StringBuilder )->Logical
      if (b is null) return (a is null)
      else           return b.operator==( a )

    method operator<>( a:String, b:String )->Int32
      if (a is null)
        if (b is null) return  0
        else           return -1
      else
        return a.operator<>( b )
      endIf

    method operator+( st:String, value:Byte )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Character )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Int32 )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Logical )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Int64 )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Object )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Real64 )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:Real32 )->String
      return which{ st || "null" }.operator+( value )

    method operator+( st:String, value:String )->String
      return which{ st || "null" }.operator+( value )

    method operator*( st:String, value:Int32 )->String
      if (st is null) return null
      return st.operator*( value )

    method operator*( count:Int32, string:String )->String
      if (string is null) return null
      return string.operator*( count )


  METHODS
    method cloned->String
      return native( 'RogueString_create_from_utf8( ($this->utf8), $this->byte_count )' )->String

    method after( index:Int32 )->String
      # Returns the substring of this string that occurs after
      # the given index.
      #
      # Equivalent to `from(index+1)`.
      return from(index+1)

    method after_any( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( i.value+1 )
      else          return this

    method after_any( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( i.value+st.count )
      else          return this

    method after_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method after_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method after_prefix( ch:Character, &ignore_case )->String
      if (begins_with(ch,&=ignore_case)) return after_first( ch, &=ignore_case )
      else                               return this

    method after_prefix( st:String, &ignore_case )->String
      if (begins_with(st,&=ignore_case)) return after_first( st, &=ignore_case )
      else                               return this

    method before( index:Int32 )->String
      # Returns the substring of this string that occur before
      # the given index.
      #
      # Equivalent to ''leftmost(index)''.
      return from(0,index-1)

    method before_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_suffix( ch:Character, &ignore_case )->String
      if (ends_with(ch,&=ignore_case)) return before_last( ch, &=ignore_case )
      else                             return this

    method before_suffix( st:String, &ignore_case )->String
      if (ends_with(st,&=ignore_case)) return before_last( st, &=ignore_case )
      else                             return this

    method begins_with( ch:Character, &ignore_case )->Logical
      if (ignore_case)
        return (count and this[0].to_lowercase == ch.to_lowercase)
      else
        return (count and this[0] == ch)
      endIf

    method begins_with( other:String, &ignore_case )->Logical
      return (count >= other.count and contains_at(other,0,&=ignore_case))

    method byte( byte_index:Int32 )->Byte
      return native( "$this->utf8[ $byte_index ]" )->Byte

    method byte_count->Int32
      return native( "$this->byte_count" )->Int32

    method capitalized->String
      if (count == 0) return this

      # Find the first letter
      forEach (ch at index in this)
        if (ch.is_letter)
          if (ch.is_uppercase) return this  # Already capitalized
          return this.leftmost(index) + Character(ch + ('A'-'a')) + this.from( index+1 )
        endIf
      endForEach

      # No letters found
      return this

    method clipped( &left=0:Int32, &right=0:Int32 )->String
      return from( left, count-(right+1) )

    method compare_to( other:String, &ignore_case )->Int32
      if (other is null) return 1
      if (ignore_case)
        $if (target("C++"))
          native @|if ($this == $other) return 0;
                  |
                  |RogueInt32 other_count = $other->byte_count;
                  |RogueInt32 limit = $this->byte_count;
                  |
                  |int result;
                  |if (limit == other_count)
                  |{
                  |  // Strings are same length
                  |  #ifdef ROGUE_PLATFORM_WINDOWS
                  |    result = strnicmp( $this->utf8, $other->utf8, limit );
                  |  #else
                  |    result = strncasecmp( $this->utf8, $other->utf8, limit );
                  |  #endif
                  |  if (result == 0) return 0;
                  |}
                  |else
                  |{
                  |  // Strings differ in length.  Compare the part that matches first.
                  |  if (limit > other_count) limit = other_count;
                  |  #ifdef ROGUE_PLATFORM_WINDOWS
                  |    result = strnicmp( $this->utf8, $other->utf8, limit );
                  |  #else
                  |    result = strncasecmp( $this->utf8, $other->utf8, limit );
                  |  #endif
                  |  if (result == 0)
                  |  {
                  |    // Equal so far - the shorter string comes before the longer one.
                  |    if (limit == other_count) return 1;
                  |    return -1;
                  |  }
                  |}
                  |if (result < 0) return -1;
                  |else            return 1;
        $endIf
      else
        return this <> other
      endIf

    method consolidated->String
      return StringConsolidationTable[ this ]

    method contains( ch:Character, &ignore_case )->Logical
      return locate(ch,&=ignore_case)?

    method contains( substring:String, &ignore_case )->Logical
      return locate(substring,&=ignore_case)?

    method contains_at( substring:String, at_index:Int32, &ignore_case )->Logical
      if (at_index < 0) return false

      if (ignore_case)
        if (at_index + substring.count > count) return false
        forEach (other_ch in substring)
          if (other_ch.to_lowercase != this[at_index].to_lowercase) return false
          ++at_index
        endForEach
        return true
      else
        $if (target("C++"))
          native @|RogueInt32 offset = RogueString_set_cursor( $this, $at_index );
                  |RogueInt32 other_count = $substring->byte_count;
                  |if (offset + other_count > $this->byte_count) return false;
                  |
                  |return (0 == memcmp($this->utf8 + offset, $substring->utf8, other_count));
        $endIf
      endIf

    method contains_pattern( pattern:String )->Logical
      # Returns true if this string contains the pattern "*<pattern>*" - in other words any number of characters
      # can come before and after the matching pattern.
      #
      # The pattern is matched literally apart from the following special sequences and behavior:
      #   *    - Matches any number of characters.
      #   ?    - Matches any single character.
      #   $    - Like '*' but discards leading whitespace; is used as a marker in extract_string(s).
      #   $(I) - Matches an integer character sequence.
      #   $(R) - Matches a real number character sequence.
      #   $($) - Matches a single literal '$'.
      #   ' '  - A space matches 1 or more spaces and tabs.
      #
      # Finally, extra whitespace in this string that isn't matched in the pattern string is ignored as long
      # as the whitespace doesn't have alphanumeric characters on both sides.
      #
      # For example, "a += c".contains_pattern("a+=c") -> true
      # For example, "a b c".contains_pattern("abc") -> false
      return _extraction_point( 0, count, pattern, 0, pattern.count, -1, &wildcard_start, &wildcard_end )._1

    method count->Int32
      return native( '$this->character_count' )->Int32

    method count( look_for:Character )->Int32
      local result = 0
      forEach (ch in this)
        if (ch == look_for) ++result
      endForEach
      return result

    method count( look_for:String )->Int32
      local result = 0
      local n = look_for.count
      local pos = locate( look_for )
      while (pos.exists)
        ++result
        pos = locate( look_for, pos.value + n )
      endWhile
      return result


    method decode_base64->Byte[]
      local builder = StringBuilder( count+2 )
      forEach (ch in this)
        if (ch.is_base64_digit) builder.print( ch )
      endForEach
      local remove_count = 0
      while ((builder.count & 3) != 0) builder.print( '=' ); ++remove_count

      local base64 = builder->String
      local output_count = (base64.count * 3) / 4

      local result = Byte[]( output_count )
      local writer = BitWriter( result )
      local reader = base64.reader
      while (reader.has_another)
        loop (4) writer.write( reader.read.to_base64_value, 6 )
      endWhile
      writer.flush

      loop (remove_count) result.remove_last
      return result

    method ends_with( ch:Character, &ignore_case )->Logical
      if (ignore_case)
        return (count > 0 and this[count-1].to_lowercase == ch.to_lowercase)
      else
        return (count > 0 and this[count-1] == ch)
      endIf

    method ends_with( other:String, &ignore_case )->Logical
      local other_count = other.count
      return (count >= other_count and other_count > 0 and contains_at(other,count-other_count,&=ignore_case))

    method equals( other:String, &ignore_case )->Logical
      if (ignore_case)
        if (count != other.count) return false
        forEach (ch at i in this)
          if (ch.to_lowercase != other[i].to_lowercase) return false
        endForEach
        return true
      else
        return this == other
      endIf

    method extract_string( format:String )->String
      # Extracts the string corresponding to the first '$' marker in the given format pattern.
      #
      # The format pattern is matched literally apart from the following special sequences and behavior:
      #   *    - Matches any number of characters.
      #   ?    - Matches any single character.
      #   $    - Like '*' but discards leading whitespace; is used as a marker in extract_string(s).
      #   $(I) - Matches an integer character sequence.
      #   $(R) - Matches a real number character sequence.
      #   $($) - Matches a single literal '$'.
      #   ' '  - A space matches 1 or more spaces and tabs.
      #
      # Finally, extra whitespace in this string that isn't matched in the pattern string is ignored as long
      # as the whitespace doesn't have alphanumeric characters on both sides.
      #
      # EXAMPLE
      #   println "<tag name='abc'/>".extract_string( "*'$'*" )
      #   # prints: abc
      local (success,match_start,match_count) = _extraction_point( 0, count, format, 0, format.count, -1 )
      if (not success) return null
      return substring( match_start, match_count )

    method extract_strings( format:String )->String[]
      # Extracts multiple strings, each corresponding to a '$' marker in the format pattern.
      # See extract_string() for additional details.
      #
      # EXAMPLE
      #   println "position = (x,4)".extract_strings( "*($,$)" )
      #   # prints: [x,4]
      local result = String[]
      if (extract_strings(format,result)) return result
      return null

    method extract_strings( format:String, result:String[] )->Logical
      local i1 = result.count
      local pt = _extraction_point( 0, count, format, 0, format.count, false, result )
      if (not pt._1) return false
      local i2 = result.count - 1
      while (i1 < i2)
        result.swap( i1, i2 )
        ++i1
        --i2
      endWhile
      return true

    method _extraction_point( i0:Int32, remaining_count:Int32, format:String, f0:Int32, fcount:Int32, found_match:Logical,
        result=null:String[], &wildcard_start, &wildcard_end )->(Logical,Int32,Int32)
      # Returns: (success,match_start,match_count)
      if (fcount == 0)
        while (remaining_count and (this[i0]==' ' or this[i0]=='\t') and remaining_count) ++i0; --remaining_count
        if ((remaining_count > 0 and not wildcard_end) or not found_match) return (false,0,0)
        return (true,0,i0)
      endIf

      if (wildcard_start)
        # Match any number of characters
        forEach (n in 0..remaining_count)
          local (success,match_start,match_count) = _extraction_point( i0+n, remaining_count-n, format, f0, fcount,
            found_match, result, &=wildcard_end )
          if (success)
            return (success,match_start+n,match_count-n)
          endIf
        endForEach
      endIf

      local format_ch = format[f0]
      which (format_ch)
        case '*':
          # Match any number of characters
          forEach (n in 0..remaining_count)
            local (success,match_start,match_count) = _extraction_point( i0+n, remaining_count-n, format, f0+1, fcount-1,
              found_match, result, &=wildcard_end )
            if (success) return (success,match_start,match_count)
          endForEach

        case ' ':
          # Match 1 or more spaces or tabs
          local n = 0
          while (n < remaining_count)
            local ch = this[i0+n]
            if (ch != ' ' and ch != '\t') escapeWhile
            ++n
          endWhile

          if (n == 0) return (false,0,0)

          return _extraction_point( i0+n, remaining_count-n, format, f0+1, fcount-1, found_match, result, &=wildcard_end )

        case '$':
          # Match one or more characters and extract as a result
          while (remaining_count and (this[i0]==' ' or this[i0]=='\t')) ++i0; --remaining_count

          local m_start = i0

          if (fcount>=3 and format[f0+1] == '(')
            if (format[f0+2] == ')')
              f0     += 2
              fcount -= 2
            elseIf (fcount>=4 and format[f0+3] == ')')
              which (format[f0+2])
                case 'I'
                  # Integer
                  local i1 = i0
                  local rcount = remaining_count
                  if (rcount and this[i1] == '-') ++i1; --rcount
                  local found_digit = false
                  while (rcount and this[i1].is_number) ++i1; --rcount; found_digit = true
                  if (found_digit)
                    local pt = _extraction_point( i1, rcount, format, f0+4, fcount-4, true, result, &=wildcard_end )
                    if (pt._1)
                      if (result) result.add( substring(m_start,i1-i0) )
                      return (true,m_start,i1-i0)
                    endIf
                  endIf

                case 'R'
                  # Real number
                  local i1 = i0
                  local rcount = remaining_count
                  if (rcount and this[i1] == '-') ++i1; --rcount
                  local found_digit = false
                  while (rcount and this[i1].is_number) ++i1; --rcount; found_digit = true
                  if (rcount and this[i1] == '.') ++i1; --rcount
                  while (rcount and this[i1].is_number) ++i1; --rcount; found_digit = true
                  if (found_digit)
                    local pt = _extraction_point( i1, rcount, format, f0+4, fcount-4, true, result, &=wildcard_end )
                    if (pt._1)
                      if (result) result.add( substring(m_start,i1-i0) )
                      return (true,m_start,i1-i0)
                    endIf
                  endIf

                case '$'
                  # $($) matches a single literal $
                  if (remaining_count and this[i0] == '$')
                    local (success,match_start,match_count) = _extraction_point( i0+1, remaining_count-1, format, f0+4, fcount-4,
                      found_match, result, &=wildcard_end )
                    if (success) return (success,match_start,match_count)
                  endIf
              endWhich

              return (false,0,0)

            endIf
          endIf

          forEach (n in 1..remaining_count)
            local pt = _extraction_point( i0+n, remaining_count-n, format, f0+1, fcount-1, true, result, &=wildcard_end )
            if (pt._1)
              if (result) result.add( substring(m_start,n) )
              return (true,m_start,n)
            endIf
          endForEach

        case '?':
          # Match any single character
          if (remaining_count == 0) return (false,0,0)
          return _extraction_point( i0+1, remaining_count-1, format, f0+1, fcount-1, found_match, result, &=wildcard_end )

        others:
          # Match one specific character
          if (remaining_count == 0) return (false,0,0)
          local ch = this[i0]
          if (format_ch == ch)
            return _extraction_point( i0+1, remaining_count-1, format, f0+1, fcount-1, found_match, result, &=wildcard_end )
          elseIf (ch == ' ' or ch == '\t')
            # Extra spaces and tabs okay as long as they're not between alphanumeric values
            # Count how many spaces and tabs in a row
            local n = 1
            while (n < remaining_count)
              ch = this[i0+n]
              if (ch != ' ' and ch != '\t') escapeWhile
              ++n
            endWhile
            if (i0 == 0 or n == remaining_count or not this[i0-1].is_identifier or not this[i0+n].is_identifier)
              return _extraction_point( i0+n, remaining_count-n, format, f0, fcount, found_match, result, &=wildcard_end )
            endIf
          endIf
      endWhich

      return (false,0,0)

    method from( i1:Int32 )->String
      return from( i1, count-1 )

    method from( i1:Int32, i2:Int32 )->String
      if (i1 < 0)          i1 = 0
      elseIf (i2 >= count) i2 = count - 1

      if (i1 > i2)  return ""
      if (i1 == i2) return ""+this[i1]
      if (i1 == 0 and i2 == count-1) return this

      $if (target("C++"))
        native @|RogueInt32 byte_i1 = RogueString_set_cursor( $this, $i1 );
                |RogueInt32 byte_limit = RogueString_set_cursor( $this, $i2+1 );
                |int new_count = (byte_limit - byte_i1);
                |RogueString* result = RogueString_create_with_byte_count( new_count );
                |memcpy( result->utf8, $this->utf8+byte_i1, new_count );
                |return RogueString_validate( result );
      $endIf

    method from_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (not i) return ""
      return from( i.value )

    method from_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (not i) return ""
      return from( i.value )

    method from_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( i.value )
      else          return ""

    method from_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( i.value )
      else          return ""

    method get( index:Int32 )->Character
      return native( 'RogueString_character_at($this,$index)' )->Character

    method hash_code->Int32
      $if (target("C++")) return native('$this->hash_code')->Int32

    method indented( spaces:Int32 )->String
      local lines = split( '\n' )
      local builder = StringBuilder( count + lines.count*2 )
      forEach (line in lines)
        if (builder.count) builder.println
        if (spaces> 0)      builder.print( " ".times(spaces) ).print( line )
        elseIf (spaces < 0) builder.print( line.rightmost(spaces) )
      endForEach
      return builder->String

    method is_ascii->Logical
      # Returns 'true' if all character codes in this string are in the range 0..127.
      return native( "$this->is_ascii" )->Logical

    method is_false->Logical
      # Returns true if this string is "false", "f", "no", "n", "off", "disable", or "disabled", case-insensitive.
      #
      # The reason there is an is_false() instead of an is_true() is partly illustrated by the following example:
      #
      #   println Value(st)->Logical
      #   # "true" prints:  true
      #   # "false" prints: true (because any non-null Value string is considered logically true)
      #
      #   # Existing is_false()
      #   if (st.is_false) println false
      #   else             println Value(st)->Logical
      #   # "true" prints:  true
      #   # "false" prints: false
      #
      #   # Hypothetical is_true()
      #   if (st.is_true) println true
      #   else            println Value(st)->Logical
      #   # "true" prints:  true
      #   # "false" prints: true
      #
      # In other words, simply converting any string to Value will always give a to->Logical of true,
      # so is_false() provides a way to intercept strings that represent Logical false as a special case.
      if (this.equals( "false",    &ignore_case )) return true
      if (this.equals( "f",        &ignore_case )) return true
      if (this.equals( "no",       &ignore_case )) return true
      if (this.equals( "n",        &ignore_case )) return true
      if (this.equals( "off",      &ignore_case )) return true
      if (this.equals( "disable",  &ignore_case )) return true
      if (this.equals( "disabled", &ignore_case )) return true
      if (this.equals( "0" )) return true
      return false

    method is_integer->Logical
      if (count == 0) return false
      forEach (ch at index in this)
        if (ch == '-')
          if (index > 0) return false
        elseIf (not ch.is_number)
          return false
        endIf
      endForEach
      return true

    method is_number->Logical
      return this.is_real

    method is_real->Logical
      if (count == 0) return false

      local period_count = 0
      forEach (ch at index in this)
        if (ch == '-')
          if (index > 0) return false
        elseIf (ch == '.')
          ++period_count
          if (period_count == 2) return false
        elseIf (not ch.is_number)
          return false
        endIf
      endForEach

      return true

    method join( substrings:String[] )->String
      return join( substrings.reader )

    method join( substrings:Reader<<String>> )->String
      local result = StringBuilder()
      local first = true
      forEach (s in substrings)
        if (not first) result.print(this)
        first = false
        result.print( s )
      endForEach
      return result->String

    method last->Character
      return this[ count-1 ]

    method left_justified( spaces:Int32, fill=' ':Character )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      buffer.print( this )
      forEach (count..<spaces) buffer.print( fill )

      return buffer->String

    method leftmost( n:Int32 )->String
      if (n >= 0) return from( 0, n-1 )
      else        return from( 0, (count + n) - 1 )

    method leftmost_common_substring_count( other:String, max_count=null:Int32? )->Int32
      if (other is null) return false
      local max = count.or_smaller(other.count)
      if (max_count.exists) max = max.or_smaller( max_count.value )
      forEach (i in 0..<max)
        if (this[i] != other[i]) return i
      endForEach
      return max

    method locate( ch:Character, optional_i1=null:Int32?, &ignore_case )->Int32?
      local i = 0
      local limit = count
      if (optional_i1.exists) i = optional_i1.value

      if (ignore_case)
        while (i < limit)
          if (this[i].to_lowercase == ch.to_lowercase) return i
          ++i
        endWhile
      else
        while (i < limit)
          if (this[i] == ch) return i
          ++i
        endWhile
      endIf
      return null

    method locate( other:String, optional_i1=null:Int32?, &ignore_case )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate( other[0], optional_i1 )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i1 : Int32
      if (optional_i1)
        i1 = optional_i1.value - 1
        if (i1 < -1) i1 = -1
      else
        i1 = -1
      endIf

      while (native("++$i1")->Int32 < this_limit)
        if (contains_at(other,i1,&=ignore_case)) return i1
      endWhile

      return null

    method locate_last( ch:Character, starting_index=null:Int32?, &ignore_case )->Int32?
      local i = count - 1
      if (starting_index.exists) i = starting_index.value

      if (ignore_case)
        while (i >= 0)
          if (this[i].to_lowercase == ch.to_lowercase) return i
          --i
        endWhile
      else
        while (i >= 0)
          if (this[i] == ch) return i
          --i
        endWhile
      endIf
      return null

    method locate_last( other:String, starting_index=null:Int32?, &ignore_case )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate_last( other[0], starting_index )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i : Int32
      if (starting_index)
        i = starting_index.value + 1
        if (i > this_limit) i = this_limit
      else
        i = this_limit
      endIf

      while (native("--$i")->Int32 >= 0)
        if (contains_at(other,i,&=ignore_case)) return i
      endWhile

      return null

    method locate_pattern( pattern:String, i1=0:Int32 )->Span?
      # Returns the index of where the first '$' pattern marker occurs in this string, or null.
      # See contains_pattern() or matches_pattern() for a description of the pattern.
      #
      # EXAMPLE
      #   "ab cd ef gh ij".locate_pattern("cd $ gh") -> 6
      local (success,index,count) = _extraction_point( i1, count-i1, pattern, 0, pattern.count, -1, &wildcard_start, &wildcard_end )
      if (success) return Span( index+i1, count-i1 )
      else         return null

    method matches_pattern( pattern:String )->Logical
      # Returns true if this string matches the given pattern.
      #
      # The pattern is matched literally apart from the following special sequences and behavior:
      #   *    - Matches any number of characters.
      #   ?    - Matches any single character.
      #   $    - Like '*' but discards leading whitespace; is used as a marker in extract_string(s).
      #   $(I) - Matches an integer character sequence.
      #   $(R) - Matches a real number character sequence.
      #   $($) - Matches a single literal '$'.
      #   ' '  - A space matches 1 or more spaces and tabs.
      #
      # Finally, extra whitespace in this string that isn't matched in the pattern string is ignored as long
      # as the whitespace doesn't have alphanumeric characters on both sides.
      #
      # For example, "a += c".matches_pattern("a+=c") -> true
      # For example, "a b c".matches_pattern("abc") -> false
      return _extraction_point( 0, count, pattern, 0, pattern.count, -1 )._1

    method operator+( value:Byte )->String
      return (this + value->Int32)

    method operator+( value:Character )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:Int32 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator==( value:String )->Logical
      if (value is null) return false
      if (this.hash_code != value.hash_code or this.count != value.count) return false
      return (native("(0==memcmp($this->utf8,$value->utf8,$this->byte_count))")->Logical)

    method operator==( value:StringBuilder )->Logical
      if (value is null) return false
      return (value == this)  # invoke the existing operator== method on value

    method operator<>( other:String )->Int32
      if (other is null) return 1
      $if (target("C++"))
        native @|if ($this == $other) return 0;
                |
                |RogueInt32 other_count = $other->byte_count;
                |RogueInt32 limit = $this->byte_count;
                |
                |int result;
                |if (limit == other_count)
                |{
                |  // Strings are same length
                |  result = memcmp( $this->utf8, $other->utf8, limit );
                |  if (result == 0) return 0;
                |}
                |else
                |{
                |  // Strings differ in length.  Compare the part that matches first.
                |  if (limit > other_count) limit = other_count;
                |  result = memcmp( $this->utf8, $other->utf8, limit );
                |  if (result == 0)
                |  {
                |    // Equal so far - the shorter string comes before the longer one.
                |    if (limit == other_count) return 1;
                |    return -1;
                |  }
                |}
                |if (result < 0) return -1;
                |else            return 1;
      $endIf

    method operator+( value:Logical )->String
      if (value) return this + "true"
      else       return this + "false"

    method operator+( value:Int64 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:Object )->String
      if (value) return this + value->String
      else       return this + "null"

    method operator+( value:Real64 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:Real32 )->String
      return (this + value->Real64)

    method operator+( value:String )->String
      if (value is null) return this + "null"
      if (count == 0) return value
      if (value.count == 0) return this
      return StringBuilder().print( this ).print( value )->String

    method operator*( value:Int32 )->String
      return this.times( value )

    method pluralized( quantity:Int32 )->String
      # Returns a pluralized form of this string.
      #
      # This string may be of the form "singlar" or "singlar/plural",
      # where both singular and plural parts may contain a "#"
      # to indicate where the given ''quantity'' should be inserted.
      #
      # If the string only contains the "singular" part, first a
      # substring of the form "(s)" or "(es)" (etc.) is looked for.
      # If that exists, it is included in the result if the string
      # is plural and omitted if the string is singular.
      #
      # If there is no "(s)" (etc.) then either "s" or "es" is
      # inserted after the last letter - "es" is used only when the
      # last letter is an "s" already.
      #
      # Examples:
      #
      #   "cat".pluralized(1)   # returns: cat
      #   "cat".pluralized(2)   # returns: cats
      #   "My # glass.".pluralized(1)  # returns: My 1 glass.
      #   "My # glass.".pluralized(2)  # returns: My 2 glasses.
      #   "a thief./# thieves".pluralized(1)   # returns: a thief.
      #   "a thief./# thieves".pluralized(40)  # returns: 40 thieves.
      #   "# match(es) found".pluralized(1)    # returns: 1 match found
      #   "# match(es) found".pluralized(0)    # returns: 0 matches found
      local st = this.replacing( "#", ""+quantity )

      if (st.contains('/'))
        if (quantity == 1) return st.before_first( '/' )
        else               return st.after_last( '/' )

      else
        local alt1 = st.locate('(')
        if (alt1.exists)
          local alt2 = st.locate(')',alt1.value+1)
          if (not alt2.exists) return this

          if (quantity == 1)
            return st.before(alt1.value) + st.after(alt2.value)
          endIf

          # plural
          return "$$$" (st.before(alt1.value),st.from(alt1.value+1,alt2.value-1),st.after(alt2.value))
        else
          if (quantity == 1) return st

          # plural
          local index = 0
          local i = st.count
          while (i > 0)
            --i
            if (st[i].is_letter) index = i; escapeWhile
          endWhile

          if (st[index] == 's') return "$es$" (st.before(index+1),st.after(index))
          else                  return "$s$" (st.before(index+1),st.after(index))
        endIf

      endIf

    method reader->StringReader
      return StringReader( this )

    method replacing( look_for:Character, replace_with:Character, &ignore_case )->String
      if (not contains(look_for,&=ignore_case)) return this

      local result = StringBuilder( count )

      if (ignore_case)
        look_for = look_for.to_lowercase
        forEach (ch in this)
          if (ch.to_lowercase == look_for) result.print( replace_with )
          else                             result.print( ch )
        endForEach
      else
        forEach (ch in this)
          if (ch == look_for) result.print( replace_with )
          else                result.print( ch )
        endForEach
      endIf

      return result->String

    method replacing( look_for:Character, replace_with:String, &ignore_case )->String
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      if (not contains(look_for,&=ignore_case)) return this

      local buffer = StringBuilder(count*1.1)
      if (ignore_case)
        look_for .= to_lowercase
        forEach (ch in this)
          if (ch.to_lowercase == look_for) buffer.print( replace_with )
          else                             buffer.print( ch )
        endForEach
      else
        forEach (ch in this)
          if (ch == look_for) buffer.print( replace_with )
          else                buffer.print( ch )
        endForEach
      endIf

      return buffer->String

    method replacing( look_for:String, replace_with:String, &ignore_case )->String
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      local i1 = this.locate(look_for,&=ignore_case)
      if (not i1.exists) return this

      local i0 = 0

      local buffer = StringBuilder( count*1.1 )
      while (i1.exists)
        forEach (i in i0..<i1.value) buffer.print( this[i] )
        buffer.print( replace_with )
        i0 = i1.value + look_for.count
        i1 = this.locate(look_for,i0,&=ignore_case)
      endWhile
      forEach (i in i0..<this.count) buffer.print( this[i] )
      return buffer->String

    method replacing( begins_with:String, ends_with:String, replace_with:Function(String)->String, &ignore_case )->String
      # Returns a modified string where all substrings beginning with begins_with and
      # ending with ends_with (conservatively) are replaced by replace_with(substring).
      local i1 = this.locate( begins_with, &=ignore_case )
      if (not i1.exists) return this
      local i2 = this.locate( ends_with, i1.value+begins_with.count, &=ignore_case )
      if (not i2.exists) return this

      local i0 = 0

      local buffer = StringBuilder( count*1.1 )
      while (i1.exists)
        forEach (i in i0..<i1.value) buffer.print( this[i] )
        buffer.print( replace_with(this.from(i1.value,i2.value+ends_with.count-1)) )
        i0 = i2.value + ends_with.count
        i1 = this.locate(begins_with,i0,&=ignore_case)
        if (i1.exists) i2 = this.locate( ends_with, i1.value+begins_with.count )
        else           escapeWhile
      endWhile
      forEach (i in i0..<this.count) buffer.print( this[i] )
      return buffer->String

    method reversed->String
      local buffer = StringBuilder(count)
      forEach (ch in this step -1)
        buffer.print( ch )
      endForEach
      return buffer->String

    method right_justified( spaces:Int32, fill=' ':Character )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      forEach (count..<spaces) buffer.print( fill )
      buffer.print( this )

      return buffer->String

    method rightmost( n:Int32 )->String
      local this_count = count
      if (n < 0) return from( -n, this_count-1 )
      else       return from( this_count-n, this_count-1 )

    method rightmost_common_substring_count( other:String )->Int32
      if (other is null) return false
      local max = count.or_smaller(other.count)
      local this_i =  count - 1
      local other_i = other.count - 1
      forEach (i in 0..<max)
        if (this[this_i] != other[other_i]) return i
        --this_i
        --other_i
      endForEach
      return max

    method split( separator:Character, &ignore_case )->String[]
      local result = String[]

      local i1 = 0
      local i2 = locate( separator, i1, &=ignore_case )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + 1
        i2 = locate( separator, i1, &=ignore_case )
      endWhile

      result.add( from(i1) )

      return result

    method split( separator:String, &ignore_case )->String[]
      local result = String[]
      local separator_count = separator.count

      local i1 = 0
      local i2 = locate( separator, i1, &=ignore_case )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + separator_count
        i2 = locate( separator, i1, &=ignore_case )
      endWhile

      result.add( from(i1) )

      return result

    method split->String[]
      # Splits the string on whitespace

      local result = String[]
      local start = -1
      local current = 0
      forEach (ch in this)
        which (ch)
          case ' ', '\t', '\n':
            if start >= 0
              result.add( this.from(start, current-1) )
              start = -1
            endIf
          others:
            if start < 0
              start = current
            endIf
          endWhich
        current++
      endForEach

      if start >= 0
        result.add( this.from(start, current-1) )
      endIf

      return result

    method substring( i1:Int32, n:Int32 )->String
      return from( i1, i1+(n-1) )

    method times( n:Int32 )->String
      if (n <= 0) return ""
      if (n == 1) return this

      local builder = StringBuilder( count * n )
      forEach (1..n) builder.print( this )

      return builder->String

    method to->Byte[]
      local result = Byte[]( byte_count )
      forEach (i in 0..<byte_count) result.add( this.byte(i) )
      return result

    method to->Character[]
      local result = Character[]( count )
      forEach (ch in this) result.add( ch )
      return result

    method to->Int32
      if (count == 0) return 0
      return native( "(RogueInt32)strtol( (char*)$this->utf8, 0, 10 )" )->Int32

    method to->Int64
      if (count == 0) return 0
      return native( "(RogueInt64)strtoll( (char*)$this->utf8, 0, 10 )" )->Int64

    method to->Object
      return this

    method to->Real64
      if (count == 0) return 0
      return native( "strtod( (char*)$this->utf8, 0 )" )->Real64

    method to->String
      return this

    method to->Value
      return Value( this )

    method to_lowercase->String
      local has_uc = false
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') has_uc = true; escapeForEach
      endForEach

      if (not has_uc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') result.print( ((ch-'A')+'a')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method to_escaped_ascii( additional_characters_to_escape="":String )->String
      use builder = StringBuilder.pool
        (forEach in this).print_escaped_ascii( builder, additional_characters_to_escape )
        if (builder == this) return this  # no escapes
        else                 return builder->String
      endUse
      return this  # won't happen but C++ doesn't realize it

    method to_uppercase->String
      local has_lc = false
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'z') has_lc = true; escapeForEach
      endForEach

      if (not has_lc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'z') result.print( ((ch-'a')+'A')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method to_utf8->Byte[]
      return this->Byte[]

    method trimmed->String
      # Trim white spaces on both ends
      local i1 = 0
      local i2 = count - 1

      while (i1 <= i2)
        if     (this[i1] <= ' ') ++i1
        elseIf (this[i2] <= ' ') --i2
        else                     escapeWhile
      endWhile

      if (i1 > i2) return ""
      if (i1 == 0 and i2 == count-1) return this
      return from( i1, i2 )

    method up_to_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value )
      else          return this

    method up_to_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (i.exists) return from( 0, i.value )
      else          return this

    method up_to_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value )
      else          return this

    method up_to_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( 0, i.value )
      else          return this

    method word_wrap( width:Int32, allow_break_after=null:String )->String[]
      # Returns a word-wrapped version of this string as a list of lines.
      # Existing newlines characters will cause a new line to begin
      # immediately.  Spaces immediately following existing newline
      # characters are preserved.
      return word_wrap( width, StringBuilder(), allow_break_after )->String.split('\n')

    method word_wrap( width:Int32, buffer:StringBuilder, allow_break_after=null:String )->StringBuilder
      # Prints a word-wrapped version of this string to the given
      # StringBuilder.  Existing newlines characters will cause a new line to
      # begin immediately.  Spaces immediately following existing newline
      # characters are preserved.
      local i1, i2 : Int32
      local len = count

      if (len == 0) return buffer

      local w = width
      local initial_indent = 0
      forEach (ch in this)
        if (ch != ' ') escapeForEach
        ++initial_indent
        --w
        ++i1
      endForEach

      if (w <= 0)
        w = width
        initial_indent = 0
        buffer.println
      else
        loop (width-w) buffer.print ' '
      endIf

      local needs_newline = false
      while (i2 < len)

        # find first \n, last space, or last break-after character
        while ((i2-i1) < w and i2 < len and this[i2] != '\n') i2++

        if ((i2-i1) == w)
          # No \n in allowed width
          if (i2 >= len)
            # The rest of the text will fit as-is.
            i2 = len
          elseIf (this[i2] != '\n')
            # Look for the last space within the given width
            while (this[i2]!=' ' and i2>i1) i2--

            if (i2 == i1)
              # Not found - move cursor to end and look for the last break-after
              # character.
              i2 = i1 + w
              if (allow_break_after)
                while (i2 > i1 and not allow_break_after.contains(this[i2-1]) and i2>i1) i2--
                if (i2 == i1)
                  # Could not find a break - just use the first 'w' characters.
                  i2 = i1 + w
                endIf
              endIf
            endIf
          endIf
        endIf

        if (needs_newline)
          buffer.println
          if (initial_indent)
            loop (initial_indent) buffer.print( ' ' )
          endIf
        endIf

        forEach (i in i1..(i2-1)) buffer.print( this[i] )
        needs_newline = true

        if (i2 == len)
          return buffer
        else
          which (this[i2])
            case ' ':
              # Discard trailing spaces
              while (i2<len and this[i2]==' ') i2++

              if (i2<len and this[i2]=='\n') i2++

              i1 = i2

            case '\n':
              ++i2

              w = width
              initial_indent = 0
              forEach (i in i2..<len)
                if (this[i] != ' ') escapeForEach
                ++initial_indent
                --w
                ++i2
              endForEach

              if (w <= 0)
                w = width
                initial_indent = 0
              else
                loop (width-w) buffer.print ' '
              endIf
          endWhich

          i1 = i2

        endIf
      endWhile

      return buffer

    method word_wrapped( width:Int32, allow_break_after=null:String )->String
      return word_wrap( width, StringBuilder(), allow_break_after )->String

endClass

class StringReader : Reader<<Character>>
  PROPERTIES
    position   : Int32
    count      : Int32
    string     : String

  METHODS
    method init( string )
      if (string) count = string.count

    method has_another->Logical
      return (position < count)

    method has_another( n:Int32 )->Logical
      return (position + n <= count)

    method peek->Character
      if (position == count) return 0
      return string[ position ]

    method read->Character
      ++position
      return string[ position - 1 ]

    method reset->this
      seek( 0 )
      return this

    method seek( pos:Int32 )->this
      if (pos < 0) pos = 0
      elseIf (pos > count) pos = count
      position = pos
      return this
endClass


class StringConsolidationTable : StringTable<<String>> [singleton]
  # Used by the consolidated() method to map equivalent strings to the same
  # string object.  Reduces memory usage and allows the use of the 'is' test
  # rather than the '==' test.  Similar to Java's intern() method.
  METHODS
    method get( st:String )->String
      local result = prior.get( st )
      if (result) return result
      this[ st ] = st
      return st

    method get( buffer:StringBuilder )->String
      local result = prior.get( buffer )
      if (result) return result

      result = buffer->String
      this[ result ] = result
      return result
endClass


class Span( index:Int32, count:Int32 ) [compound]
  METHODS
    method i2->Int32
      return index + (count-1)

    method limit->Int32
      return index + count

    method to->String
      return "@$ x$"(index,count)
endClass

