# Rogue thread library

# Currently only supports pthreads and g++-like compilers.

nativeHeader

#if ROGUE_THREAD_MODE == ROGUE_THREAD_MODE_PTHREADS

// #include "gc.h" - included elsewhere
#include <pthread.h>
#include <assert.h>
#include <functional>

// Platform-appropriate semaphore
// Based on https://stackoverflow.com/a/27847103/135791
#ifdef __APPLE__
  #include <dispatch/dispatch.h>
#else
  #include <semaphore.h>
#endif

struct RogueSemaphore
{
#ifdef __APPLE__
    dispatch_semaphore_t sem;
#else
    sem_t                sem;
#endif
};


static inline void
RogueSemaphore_init( struct RogueSemaphore *s, uint32_t value )
{
#ifdef __APPLE__
    dispatch_semaphore_t *sem = &s->sem;

    *sem = dispatch_semaphore_create(value);
#else
    sem_init(&s->sem, 0, value);
#endif
}

static inline void
RogueSemaphore_wait( struct RogueSemaphore *s )
{

#ifdef __APPLE__
    dispatch_semaphore_wait(s->sem, DISPATCH_TIME_FOREVER);
#else
    int r;

    do
    {
      r = sem_wait(&s->sem);
    } while (r == -1 && errno == EINTR);
#endif
}

// Returns true if semaphore was decremented.
static inline bool
RogueSemaphore_try_wait( struct RogueSemaphore *s )
{

#ifdef __APPLE__
    return dispatch_semaphore_wait(s->sem, DISPATCH_TIME_NOW) == 0;
#else
    int r;

    do
    {
      r = sem_trywait(&s->sem);
    } while (r == -1 && errno == EINTR);

    if (r == -1) return false;
    return true;
#endif
}

static inline void
RogueSemaphore_post(struct RogueSemaphore *s)
{

#ifdef __APPLE__
    dispatch_semaphore_signal(s->sem);
#else
    sem_post(&s->sem);
#endif
}

static inline void
RogueSemaphore_destroy( struct RogueSemaphore *s )
{
#ifdef __APPLE__
    dispatch_release( s->sem );
#else
    sem_destroy( &s->sem );
#endif
}

pthread_t create_thread (void * (*f)(void *), void * arg)
{
  pthread_t tid;
  int r = pthread_create(&tid, NULL, f, arg);
  if (r) return 0;
  assert(tid != 0);
  return tid;
}

struct thread_start_info
{
  std::function<void()> thread_function;
  RogueSemaphore sem;
};


static inline void * roguethread_entry (void * tsi_)
{
  thread_start_info & si = *(thread_start_info *)tsi_;
  auto thread_function = si.thread_function;
  RogueSemaphore_post(&si.sem); // We've got it.
  thread_function();
  return NULL;
}


pthread_t roguethread_create ( std::function<void()> f )
{
  thread_start_info si = {};
  si.thread_function = f;
  RogueSemaphore_init( &si.sem, 0 );
  auto r = create_thread(roguethread_entry, &si);
  RogueSemaphore_wait(&si.sem);
  RogueSemaphore_destroy(&si.sem);
  return r;
}

#endif

endNativeHeader


nativeCode

inline void roguethread_simple_spin_lock(int *p)
{
    ROGUE_EXIT;
    while(!__sync_bool_compare_and_swap(p, 0, 1)) {};
    ROGUE_ENTER;
}

inline void roguethread_simple_spin_unlock(int volatile *p)
{
    asm volatile ("" : : : "memory");
    *p = 0;
}

#define ROGUE_THREAD_LAMBDA_START(__f) \
  RogueObject_retain(__f);                                                                        \
  std::function<void()> f = [=] () {                                                              \
    Rogue_thread_register();                                                                      \
    Rogue_init_thread();                                                                          \
    ROGUE_THREAD_DEBUG_STATEMENT(RogueDebugTrace __trace( "Thread.lambda()", "thread.rogue", 1)); \
    try                                                                                           \
    {
#define ROGUE_THREAD_LAMBDA_END(__f) \
    }                                                                                             \
    catch (RogueException* err)                                                                   \
    {                                                                                             \
      printf( "Uncaught exception\n" );                                                           \
      RogueException__display( err );                                                             \
    }                                                                                             \
    Rogue_deinit_thread();                                                                        \
    RogueObject_release(__f);                                                                     \
    Rogue_thread_unregister();                                                                    \
  };

endNativeCode


$if (DEBUG)
  nativeCode
    #define ROGUE_THREAD_DEBUG_STATEMENT(_s) _s
  endNativeCode
$else
  nativeCode
    #define ROGUE_THREAD_DEBUG_STATEMENT(_s)
  endNativeCode
$endIf


class Thread
  PROPERTIES
    native "pthread_t thread;" # We assume 0 is invalid

  METHODS
    method has_thread () -> Logical
      return native("$this->thread")->Logical

    method join ()
      if (not has_thread) return
      native @|ROGUE_EXIT;
              |pthread_join($this->thread, NULL);
              |ROGUE_ENTER;

    method detach ()
      if (not has_thread) return
      native @|pthread_detach($this->thread);
              |$this->thread = (pthread_t)0;

    method is_current () -> Logical
      # Doesn't necessarily work for all types of threads
      if (not has_thread) return false
      return this == Thread.current

    method operator== (other:Thread) -> Logical
      # Not all kinds of threads can necessarily do this.
      local eq = 0
      native @|$eq = ($this->thread == $other->thread);
      return eq
    method to -> String
      if (not has_thread)
        return "($ detached)" (type_info.name)
      endIf
      return "($ $)" (type_info.name, id)

    method pin_to_core (core:Int32) -> Logical
      if (not has_thread) return false
      local ok = 0
      native @|#if ROGUE_THREAD_MODE == ROGUE_THREAD_MODE_PTHREADS
              |  $ok = 1;
              |  cpu_set_t cpus;
              |  CPU_ZERO(&cpus);
              |  CPU_SET($core, &cpus);
              |  pthread_setaffinity_np($this->thread, sizeof(cpus), &cpus);
              |#endif
      return ok

    method init (f:Function())
      native @|ROGUE_THREAD_LAMBDA_START($f)
        f()
      native @|ROGUE_THREAD_LAMBDA_END($f)
              |$this->thread = roguethread_create(f);

    method init <<$T1>> (f:Function($T1), a1:$T1)
      native @|ROGUE_THREAD_LAMBDA_START($f)
        f(a1)
      native @|ROGUE_THREAD_LAMBDA_END($f)
              |$this->thread = roguethread_create(f);

    method init <<$T1,$T2>> (f:Function($T1,$T2), a1:$T1, a2:$T2)
      native @|ROGUE_THREAD_LAMBDA_START($f)
        f(a1,a2)
      native @|ROGUE_THREAD_LAMBDA_END($f)
              |$this->thread = roguethread_create(f);

    method init <<$T1,$T2,$T3>> (f:Function($T1,$T2,$T3), a1:$T1, a2:$T2, a3:$T3)
      native @|ROGUE_THREAD_LAMBDA_START($f)
        f(a1,a2,a3)
      native @|ROGUE_THREAD_LAMBDA_END($f)
              |$this->thread = roguethread_create(f);

    method init () -> Thread [essential]
      native @|$this->thread = pthread_self();

    method on_cleanup ()
      detach

    method id () -> Int64
      #TODO: Do nice (but OS-specific) stuff to get a reasonable ID
      if (not has_thread) return 0
      return native("$this->thread")->Int64

  GLOBAL METHODS
    method current () -> Thread [essential]
      return Thread()

endClass


augment Exception
  METHODS
    method display
      message = "In thread " + Thread.current.id + "\n" + message
endAugment


#{
  FastBarrier is a lightweight barrier *that cannot be copied*.

  Since it cannot be copied, FastBarrier is suitable for cases where you
  don't need to pass it as an argument or things like that.

  To use it, someone must create it and then call .initialize on it,
  passing the number of threads that must be "waiting behind the barrier"
  before they are released.
}#
class FastBarrier [compound]
  PROPERTIES
    native "pthread_barrier_t _barrier;"
  METHODS
    method initialize (n:Int32) [macro]
      native "pthread_barrier_init(&$this._barrier, 0, $n);"
    method destroy [macro]
      native "pthread_barrier_destroy(&$this._barrier);"
    method wait -> Logical [macro]
      native("ROGUE_BLOCKING_CALL((RogueInt32)(pthread_barrier_wait(&$this._barrier) == PTHREAD_BARRIER_SERIAL_THREAD))")
    method operator== (other:FastBarrier) -> Logical
      return false # Not comparable
endClass


class Barrier
  PROPERTIES
    native "pthread_barrier_t _barrier;"
  METHODS
    method initialize (n:Int32)
      native "pthread_barrier_init(&$this->_barrier, 0, $n);"
    method destroy
      native "pthread_barrier_destroy(&$this->_barrier);"
    method wait -> Logical [macro]
      native("ROGUE_BLOCKING_CALL((RogueInt32)(pthread_barrier_wait(&$this->_barrier) == PTHREAD_BARRIER_SERIAL_THREAD))")
endClass


class Mutex
  PROPERTIES
    native "pthread_mutex_t _lock;"

  METHODS
    method init
      native "pthread_mutex_init(&$this->_lock, NULL);"

    method on_cleanup
      native "pthread_mutex_destroy(&$this->_lock);"

    method on_use -> this
      lock
      return this

    method lock [macro]
      native "ROGUE_BLOCKING_CALL(pthread_mutex_lock(&$this->_lock));"

    method on_end_use
      unlock

    method unlock [macro]
      native "pthread_mutex_unlock(&$this->_lock);"
endClass


class SpinLock
  PROPERTIES
    native "pthread_spinlock_t _lock;"

  METHODS
    method init
      native "pthread_spin_init(&$this->_lock, 0);"

    method on_cleanup
      native "pthread_spin_destroy(&$this->_lock);"

    method on_use -> this
      lock
      return this

    method lock [macro]
      native "ROGUE_BLOCKING_CALL(pthread_spin_lock(&$this->_lock));"

    method on_end_use
      unlock

    method unlock [macro]
      native "pthread_spin_unlock(&$this->_lock);"
endClass


class SimpleSpinLock [compound]
  PROPERTIES
    native "int _lock = 0;"

  METHODS
    method on_use -> this
      lock
      return this

    method lock [macro]
      native "roguethread_simple_spin_lock(&$this._lock);"

    method on_end_use
      unlock

    method unlock [macro]
      native "roguethread_simple_spin_unlock(&$this._lock);"

    method operator== (other:SimpleSpinLock) -> Logical
      return native("$this._lock == $other._lock")->Logical
endClass


#{
  A Semaphore

  The best way to think of a semaphore is as a pool of n resources (where n
  is the "value" parameter of the constructor).  You say you want to acquire
  a resource, and if any are available, you get it immediately.  You release
  it when you're done.  If there weren't any of the resource available, you
  generally block waiting for it, though you can also just *try* to acquire
  it, in which case you continue immediately whether you got it or not.

  In actuality, it's really just like an integer.  "Acquiring" it requires
  that it be positive.  If it's not, it blocks.  When it acquires, the
  integer is decremented.  When it's released, it's incremented.

  Most other semaphore documentation seems to try to make this as confusing
  as possible.

  This class implements the "use protocol".  Using a Semaphore acquires it
  for the duration of the block.
}#
class Semaphore
  PROPERTIES
    native "RogueSemaphore _sem;"
  METHODS
    method init (value : Int32)
      # Technically the initial value is an int, so it might be that
      # Int64 is a better choice.  But Int32 should be safe.
      native "RogueSemaphore_init(&$this->_sem, $value);"

    method on_cleanup
      native "RogueSemaphore_destroy(&$this->_sem);"

    method acquire
      native "ROGUE_BLOCKING_VOID_CALL(RogueSemaphore_wait(&$this->_sem));"

    method try_acquire -> Logical
      # Returns true if you got it
      local r : Int64
      native "$r = ROGUE_BLOCKING_CALL(RogueSemaphore_try_wait(&$this->_sem));"
      return r == 0

    method release
      native "RogueSemaphore_post(&$this->_sem);"

    method release (n : Int32)
      forEach (_ in 1..n)
        release
      endForEach

    method on_use -> this
      acquire
      return this

    method on_end_use
      release
endClass
