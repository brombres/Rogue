augment Rogue::GlobalID
  # Use the ?=> operator to create weakly referenced callbacks.
  METHODS
    method disconnect_signal
      Signals.disconnect( SignalIDLookup[this] )

    method disconnect_signal( context:Object )
      Signals.disconnect( SignalIDLookup[this], context )

    method disconnect_signal( connection:SignalConnection )
      Signals.disconnect( connection )

    method on_signal( context:Object, callback:Function(Variant), &once )->SignalConnection
      return Signals.on( SignalIDLookup[this], callback, context, &=once )

    method on_signal( context:Object, callback:Function(), &once )->SignalConnection
      return Signals.on( SignalIDLookup[this], callback, context, &=once )

    method on_signal( callback:Function(Variant), &once )->SignalConnection
      return Signals.on( SignalIDLookup[this], callback, &=once )

    method on_signal( callback:Function(), &once )->SignalConnection
      return Signals.on( SignalIDLookup[this], callback, &=once )

    method signal( args=undefined:Variant )
      Signals.dispatch( SignalIDLookup[this], args )
endAugment


class Signals<<$EnumType>> [aspect]
  # Incorporate into enum type, e.g. 'enum MyEnum : Signals<<MyEnum>> ...'.
  # Use the ?=> operator to create weakly referenced callbacks.
  GLOBAL PROPERTIES
    lookup : SignalID[]

  GLOBAL METHODS
    method signal_id_lookup->SignalID[]
      if (Signals<<$EnumType>>.lookup) return Signals<<$EnumType>>.lookup

      Signals<<$EnumType>>.lookup = SignalID[]
      if ($EnumType.categories.count)
        local max_value = $EnumType.categories.first.value
        max_value .= or_larger( (forEach in $EnumType.categories from 1).value )
        Signals<<$EnumType>>.lookup.expand_to_include( max_value )
      endIf

      forEach (category in $EnumType.categories)
        Signals<<$EnumType>>.lookup[category.value] = SignalIDLookup[ "$.$"(category.type_name,category) ]
      endForEach

      return Signals<<$EnumType>>.lookup

  METHODS
    method disconnect_signal
      Signals.disconnect( Signals<<$EnumType>>.signal_id_lookup[this] )

    method disconnect_signal( context:Object )
      Signals.disconnect( Signals<<$EnumType>>.signal_id_lookup[this], context )

    method disconnect_signal( connection:SignalConnection )
      Signals.disconnect( connection )

    method on_signal( context:Object, callback:Function(Variant), &once )->SignalConnection
      return Signals.on( Signals<<$EnumType>>.signal_id_lookup[this], callback, context, &=once )

    method on_signal( context:Object, callback:Function(), &once )->SignalConnection
      return Signals.on( Signals<<$EnumType>>.signal_id_lookup[this], callback, context, &=once )

    method on_signal( callback:Function(Variant), &once )->SignalConnection
      return Signals.on( Signals<<$EnumType>>.signal_id_lookup[this], callback, &=once )

    method on_signal( callback:Function(), &once )->SignalConnection
      return Signals.on( Signals<<$EnumType>>.signal_id_lookup[this], callback, &=once )

    method signal( args=undefined:Variant )
      Signals.dispatch( Signals<<$EnumType>>.signal_id_lookup[this], args )
endClass


class SignalID( value:Int ) [compound]
  METHODS
    method hashcode->Int
      return value.hashcode
endClass

class SignalIDLookup [singleton]
  PROPERTIES
    next_signal_id    = 1
    global_id_lookup  = [GlobalID:SignalID]
    string_key_lookup = [String:SignalID]

  METHODS
    method get( global_id:GlobalID )->SignalID
      if local entry = global_id_lookup.find( global_id )
        return entry.value
      else
        local result = SignalID( next_signal_id )
        ++next_signal_id
        global_id_lookup[global_id] = result
        return result
      endIf

    method get( string_key:String )->SignalID
      if local entry = string_key_lookup.find( string_key )
        return entry.value
      else
        local result = SignalID( next_signal_id )
        ++next_signal_id
        string_key_lookup[string_key] = result
        return result
      endIf
endClass

class Signals [singleton]
  PROPERTIES
    standard_connections = [SignalID:SignalConnection[]]
    one_time_connections = [SignalID:SignalConnection[]]

  METHODS
    method disconnect( signal_id:SignalID, context=null:Object )
      if (context)
        if local group = standard_connections[ signal_id ]
          group.discard( $.context == context )
        endIf

        if local group = one_time_connections[ signal_id ]
          group.discard( $.context == context )
        endIf
      else
        one_time_connections[signal_id]?.clear
        standard_connections[signal_id]?.clear
      endIf

    method disconnect( context:Object )
      # Disconnects all signal connections that have the given object as context.
      forEach (group in standard_connections)
        group.discard( $.context == context )
      endForEach

      forEach (group in one_time_connections)
        group.discard( $.context == context )
      endForEach

    method disconnect( connection:SignalConnection )
      standard_connections[ connection.signal_id ]?.remove( connection )
      one_time_connections[ connection.signal_id ]?.remove( connection )

    method dispatch( signal_id:SignalID, args=undefined:Variant )
      if local group = one_time_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )
          group.clear
          (forEach in list)( args )
        endUse
      endIf

      if local group = standard_connections[ signal_id ]
        use list = WorkList<<SignalConnection>>
          list.add( group )

          local has_invalid_connections = false
          forEach (connection in list)
            if (connection) connection( args )
            else            has_invalid_connections = true
          endForEach
          if (has_invalid_connections)
            group.discard( not $ )
          endIf
        endUse
      endIf

    method on( connection:SignalConnection, &once )->SignalConnection
      if (once)
        local group = one_time_connections[connection.signal_id]
        if (not group)
          ensure<<group>>
          one_time_connections[connection.signal_id] = group
        endIf
        group.add( connection )
      else
        local group = standard_connections[connection.signal_id]
        if (not group)
          ensure<<group>>
          standard_connections[connection.signal_id] = group
        endIf
        group.add( connection )
      endIf
      return connection

    method on( signal_id:SignalID, callback:Function(Variant), context=null:Object, &once )->SignalConnection
      return on( SignalConnection(signal_id, context, callback), &=once )

    method on( signal_id:SignalID, callback:Function(), context=null:Object, &once )->SignalConnection
      return on( SignalConnection(signal_id, context, callback), &=once )

    method remove_invalid_connections
      # Invalid connections are automatically removed during signal dispatch, but
      # remove_invalid_connections can be manually called to examine every connection.
      (forEach in standard_connections).discard( not $? )
      (forEach in one_time_connections).discard( not $? )

endClass

class SignalConnection( signal_id:SignalID, context:WeakReference<<Object>>,
    callback_w_args:Function(Variant),
    callback_noargs:Function() ) [compound]
  # Use the ?=> operator to create weakly referenced callbacks.

  GLOBAL METHODS
    method create( signal_id:SignalID, context:Object, callback:Function(Variant) )->SignalConnection
      if (not context) context = Signals
      return SignalConnection(
        signal_id,
        WeakReference<<Object>>(context),
        callback,
        null
      )

    method create( signal_id:SignalID, context:Object, callback:Function() )->SignalConnection
      if (not context) context = Signals
      return SignalConnection(
        signal_id,
        WeakReference<<Object>>(context),
        null,
        callback
      )

  METHODS
    method call( args:Variant )
      if (context)
        if (callback_noargs) callback_noargs()
        else                 callback_w_args( args )
      endIf

    method disconnect
      Signals.disconnect( this )
      context?.object = null

    method operator==( other_object:Object )->Logical
      local other = other_object->(as SignalConnection)
      if (context? != other.context?) return false
      return signal_id == other.signal_id and callback_noargs is other.callback_noargs and
             callback_w_args is other.callback_w_args

    method operator?()->Logical
      return context? and (callback_noargs?.is_valid or callback_w_args?.is_valid)
endClass

