class FileOptions( flags=0:Int32 ) [compound]
  ENUMERATE
    FLAG_RECURSIVE     = 1
    FLAG_ABSOLUTE      = 2
    FLAG_FILES         = 4
    FLAG_FOLDERS       = 8
    FLAG_BOTH          = 12
    FLAG_IGNORE_HIDDEN = 16

  METHODS
    method absolute->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_ABSOLUTE )

    method ignore_hidden->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_IGNORE_HIDDEN )

    method ignoring_hidden->Logical [macro]
      (this.flags & FileOptions.FLAG_IGNORE_HIDDEN)

    method including_both->Logical
      local f = (flags & FLAG_BOTH)
      return (f == 0) or (f == FLAG_BOTH)

    method including_files->Logical
      return (flags & FLAG_FILES) or not (flags & FLAG_BOTH)

    method including_folders->Logical
      return (flags & FLAG_FOLDERS) or not (flags & FLAG_BOTH)

    method files->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_FILES )

    method folders->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_FOLDERS )

    method is_absolute->Logical [macro]
      (this.flags & FileOptions.FLAG_ABSOLUTE)

    method is_limited->Logical [macro]
      (not (this.flags & FileOptions.FLAG_RECURSIVE))

    method is_recursive->Logical [macro]
      (this.flags & FileOptions.FLAG_RECURSIVE)

    method is_relative->Logical [macro]
      (not (this.flags & FileOptions.FLAG_ABSOLUTE))

    method limited->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_RECURSIVE )

    method relative->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_ABSOLUTE )

    method recursive->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_RECURSIVE )

    method showing_hidden->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_IGNORE_HIDDEN )

    method shows_hidden->Logical [macro]
      (not (this.flags & FileOptions.FLAG_IGNORE_HIDDEN))
endClass

class File
  nativeHeader #include <cstdio>
  GLOBAL METHODS
    method absolute_filepath( filepath:String )->String
      if (not filepath) return null

      if (not exists(filepath))
        local parent = path( filepath )
        if (parent.count == 0) parent = "."
        return "$/$" (absolute_filepath(parent),filename(filepath))
      endIf

      local return_value : String

      native @|#if defined(_WIN32)
              |{
              |  char long_name[PATH_MAX+4];
              |  char full_name[PATH_MAX+4];
              |
              |  if (GetInt64PathName((char*)$filepath->utf8, long_name, PATH_MAX+4) == 0)
              |  {
              |    strcpy_s( long_name, PATH_MAX+4, (char*)$filepath->utf8 );
              |  }
              |
              |  if (GetFullPathName(long_name, PATH_MAX+4, full_name, 0) != 0)
              |  {
              |    $return_value = RogueString_create_from_utf8( full_name, -1 );
              |  }
              |}
              |#else
              |{
              |  int original_dir_fd;
              |  int new_dir_fd;
              |  char filename[PATH_MAX];
              |  char c_filepath[ PATH_MAX ];
              |  bool is_folder;
              |
              |  is_folder = RogueFile__is_folder__String( $filepath );
              |
              |  int len = $filepath->byte_count;
              |  if (len >= PATH_MAX) len = PATH_MAX - 1;
              |  memcpy( c_filepath, (char*)$filepath->utf8, len );
              |  c_filepath[len] = 0;
              |
              |  // A way to get back to the starting folder when finished.
              |  original_dir_fd = open( ".", O_RDONLY );
              |
              |  if (is_folder)
              |  {
              |    filename[0] = 0;
              |  }
              |  else
              |  {
              |    // fchdir only works with a path, not a path+filename (c_filepath).
              |    // Copy out the filename and null terminate the filepath to be just a path.
              |    int i = (int) strlen( c_filepath ) - 1;
              |    while (i >= 0 && c_filepath[i] != '/') --i;
              |    strcpy( filename, c_filepath+i+1 );
              |    if (i == -1) strcpy( c_filepath, "." );
              |    else         c_filepath[i] = 0;
              |  }
              |  new_dir_fd = open( c_filepath, O_RDONLY );
              |
              |  do
              |  {
              |    if (original_dir_fd >= 0 && new_dir_fd >= 0)
              |    {
              |      int r = fchdir( new_dir_fd );
              |      if ( r != 0 ) break;
              |      char * r2 = getcwd( c_filepath, PATH_MAX );
              |      if ( r2 == 0 ) break;
              |      if ( !is_folder )
              |      {
              |        strcat( c_filepath, "/" );
              |        strcat( c_filepath, filename );
              |      }
              |      r = fchdir( original_dir_fd );
              |      if ( r != 0 ) break;
              |    }
              |
              |    $return_value = RogueString_create_from_utf8( c_filepath, -1 );
              |  } while (false);
              |
              |  if (original_dir_fd >= 0) close( original_dir_fd );
              |  if (new_dir_fd >= 0) close( new_dir_fd );
              |}
              |#endif
      if (return_value is null)
        throw IOError("Could not get absolute path")
      endIf
      return return_value

    method create_folder( filepath:String )->Logical
      # Creates the specified folder along with intermediate folders
      # if necessary.  Returns 'true' on success or if the filepath
      # already exists as a folder.  Returns 'false' on failure to
      filepath = File.absolute_filepath( filepath )

      # create or if the filepath already exists but is not a folder.
      if (File.exists(filepath)) return File.is_folder( filepath )

      # Check for the parent folder's existence and recursively create
      # that if necessary.
      local parent = File.path( filepath )
      if (not create_folder(parent)) return false

      # Note: 0777 is a permission mask rather than the actual permission setting.
      native @|return (0 == mkdir((char*)$filepath->utf8, 0777));

    method exists( filepath:String )->Logical
      native @|if ( !$filepath ) return false;
              |
              |FILE* fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !fp ) return false;
              |
              |fclose( fp );
              |return true;

    method extension( filepath:String )->String
      return filepath.after_last( '.' )

    method filename( filepath:String )->String
      local i = filepath.locate_last( '/' )
      if (not i?) i = filepath.locate_last( '\\' )
      if (not i?) return filepath
      return filepath.from( i.value+1 )

    method is_folder( filepath:String )->Logical [requisite]
      native @|if ( !$filepath ) return false;
              |
              |#if defined(_WIN32)
              |  char filepath_copy[PATH_MAX];
              |  strcpy( filepath_copy, (char*)$filepath->utf8 );
              |
              |  int path_len = $filepath->byte_count;
              |  int i = strlen(filepath_copy)-1;
              |  while (i > 0 && (filepath_copy[i] == '/' || filepath_copy[i] == '\\')) filepath_copy[i--] = 0;
              |
              |  // Windows allows dir\* to count as a directory; guard against.
              |  for (i=0; filepath_copy[i]; ++i)
              |  {
              |    if (filepath_copy[i] == '*' || filepath_copy[i] == '?') return 0;
              |  }
              |
              |  WIN32_FIND_DATA entry;
              |  HANDLE dir = FindFirstFile( filepath_copy, &entry );
              |  if (dir != INVALID_HANDLE_VALUE)
              |  {
              |    if (entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              |    {
              |      FindClose( dir );
              |      return 1;
              |    }
              |  }
              |  FindClose( dir );
              |  return 0;
              |
              |#else
              |  DIR* dir = opendir( (char*)$filepath->utf8 );
              |  if ( !dir ) return 0;
              |
              |  closedir( dir );
              |  return 1;
              |#endif

    method listing( folder:String, options=FileOptions():FileOptions, filepath="":String, result=String[]:String[] )->String[]
      if (options.is_absolute)
        filepath = File.absolute_filepath( folder )  # add absolute path to every entry
        folder = ""
        options = options.relative
      endIf

      if (folder.count and not (folder.ends_with('/') or folder.ends_with('\\')))
        folder += '/'
      endIf

      if (filepath.count and not (filepath.ends_with('/') or filepath.ends_with('\\')))
        filepath += '/'
      endIf

      local native_folder = folder + filepath

      if (not is_folder(native_folder)) return result

      native @|{
              |  DIR* dir;
              |  struct dirent* entry;
              |
              |  dir = opendir( $native_folder->utf8 );
              |  if (dir)
              |  {
              |    entry = readdir( dir );
              |    while (entry)
              |    {
              |      int keep = 1;
              |      if (entry->d_name[0] == '.')
              |      {
              |        switch (entry->d_name[1])
              |        {
              |          case 0:
              |            keep = 0;
              |            break;
              |          case '.':
              |            keep = entry->d_name[2] != 0;
              |            break;
              |        }
              |      }
              |      if (keep)
              |      {

                       local entry = native("RogueString_create_from_utf8(entry->d_name,-1)")->String
                       local is_hidden = entry.begins_with('.')
                       entry = filepath + entry
                       if (not (is_hidden and options.ignoring_hidden))
                         local _is_folder = is_folder( folder + entry )
                         if (options.including_both or
                             (_is_folder and options.including_folders) or
                             (not _is_folder and options.including_files))
                           result.add( entry )
                         endIf

                         if (_is_folder and options.is_recursive)
                           listing( folder, options, entry, result )
                         endIf

                       endIf

      native @|
              |      }
              |      entry = readdir( dir );
              |    }
              |    closedir( dir );
              |  }
              |}

      return result


    method load_as_bytes( filepath:String )->Byte[]
      local count = size( filepath )
      local bytes = Byte[]( count )
      local infile = reader( filepath )
      forEach (1..count) bytes.add( infile.read )
      infile.close
      return bytes

    method load_as_string( filepath:String )->String
      local count = size( filepath )
      local buffer = StringBuilder( count )
      local infile = reader( filepath )
      forEach (1..count)
        local b = infile.read
        buffer.utf8.add( b )
        if ((b & 0xC0) != 0x80) ++buffer.count
      endForEach
      infile.close
      return buffer->String

    method options->FileOptions [macro]
      FileOptions()

    method path( filepath:String )->String
      local i = filepath.locate_last( '/' )
      if (not i?) i = filepath.locate_last( '\\' )
      if (not i?) return ""
      return filepath.from( 0, i.value-1 )

    method reader( filepath:String )->FileReader
      return FileReader( filepath )

    method save( filepath:String, data:Byte[] )->Logical
      local outfile = writer( filepath )
      forEach (ch in data) outfile.write( ch )
      outfile.close
      return not outfile.error

    method save( filepath:String, data:String )->Logical
      local outfile = writer( filepath )
      forEach (i in 0..<data.byte_count) outfile.write( data.byte(i) )
      outfile.close
      return not outfile.error

    method size( filepath:String )->Int32
      native @|if ( !$filepath ) return 0;
              |
              |FILE* fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !fp ) return 0;
              |
              |fseek( fp, 0, SEEK_END );
              |RogueInt32 size = (RogueInt32) ftell( fp );
              |fclose( fp );
              |
              |return size;

    method writer( filepath:String )->FileWriter
      return FileWriter( filepath )

  PROPERTIES
    filepath : String

  METHODS
    method init( filepath )

    method absolute_filepath->String [macro]
      File.absolute_filepath( this.filepath )

    method create_folder->Logical [macro]
      File.create_folder( this.filepath )

    method exists->Logical [macro]
      File.exists( this.filepath )

    method extension->String [macro]
      File.extension( this.filepath )

    method filename->String
      return filename( filepath )

    method is_folder->Logical [macro]
      File.is_folder( this.filepath )

    method listing->String[] [macro]
      File.listing( this.filepath )

    method load_as_bytes->Byte[] [macro]
      File.load_as_bytes( this.filepath )

    method load_as_string->String [macro]
      File.load_as_string( this.filepath )

    method path->String [macro]
      File.path( this.filepath )

    method reader->FileReader [macro]
      File.reader( this.filepath )

    method save( data:Byte[] )->Logical [macro]
      File.save( this.filepath, data )

    method save( data:String )->Logical [macro]
      File.save( this.filepath, data )

    method size->Int32 [macro]
      File.size( this.filepath )

    method writer->FileWriter [macro]
      File.writer( this.filepath )

    method to->String
      return filepath
endClass

class FileReader : Reader<<Character>>
  PROPERTIES
    filepath        : String
    count           : Int32
    position        : Int32
    buffer_position : Int32
    buffer          = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String )
      open( _filepath )

    method close->this
      if (fp)
        native @|fclose( $this->fp );
                |$this->fp = 0;
      endIf

      position = 0
      count = 0
      return this

    method fp->Int32 [macro]
      native "$this->fp"

    method has_another->Logical
      return (position < count)

    method open( filepath )->Logical
      close

      native @|$this->fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ($this->fp)
              |{
              |  fseek( $this->fp, 0, SEEK_END );
              |  $count = (RogueInt32) ftell( $this->fp );
              |  fseek( $this->fp, 0, SEEK_SET );
              |}

      # Always close after the last byte is read, so if there are no
      # bytes then close right away.
      if (count == 0) close

      return (position < count)

    method peek->Character
      if (position == count) return 0

      if (buffer_position == buffer.count)
        native @|$buffer->count = (RogueInt32) fread( $buffer->data->bytes, 1, 1024, $this->fp );
        buffer_position = 0
      endIf

      return buffer[ buffer_position ]

    method read->Character
      if (position == count) return 0

      local result = peek

      ++position
      ++buffer_position
      if (position == count) close

      return result

    method remaining->Int32
      return count - position

    method reset->this
      if (not fp) return this
      count = native( "(RogueInt32)ftell($this->fp)" )->Int32
      return seek( 0 )

    method seek( pos:Int32 )->this
      if (not fp) return this

      if (pos < 0) pos = 0
      if (pos > count) pos = count

      position = pos
      native "fseek( $this->fp, $position, SEEK_SET );"

      buffer_position = 0
      buffer.clear
      return this
endClass


class FileWriter : Writer<<Character>>
  PROPERTIES
    filepath : String
    error    : Logical
    buffer   = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String )
      open( _filepath )

    method close->this
      flush

      if (fp)
        native( "fclose( $this->fp ); $this->fp = 0;" )
      endIf

      return this

    method flush->this
      if (buffer.count == 0 or not fp) return this

      native @|fwrite( $buffer->data->bytes, 1, $buffer->count, $this->fp );
      native @|fflush( $this->fp );

      buffer.clear
      return this

    method fp->Int32 [macro]
      native( "$this->fp" )

    method open( filepath )->Logical
      close
      error = false

      native @|$this->fp = fopen( (char*)$filepath->utf8, "wb" );
              |$this->error = !($this->fp);
              |
              |return !$this->error;

    method reset->this
      if (not fp) return this
      flush
      return seek( 0 )

    method seek( pos:Int32 )->this
      if (not fp) return this
      flush
      if (pos < 0) pos = 0
      position = pos

      native "fseek( $this->fp, 0, SEEK_SET );"

      return this

    method seek_end()->this
      if (not fp) return this
      flush

      native "fseek( $this->fp, 0, SEEK_END );"
      position = native( "(RogueInt32)ftell( $this->fp )" )->Int32

      return this

    method write( ch:Character )->this
      if (not fp) return this

      ++position
      buffer.add( ch )
      if (buffer.count == 1024) return flush

      return this
endClass

