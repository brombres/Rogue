class File
  DEPENDENCIES
    nativeHeader #include <cstdio>

  GLOBAL METHODS
    method absolute_filepath( filepath:String )->String
      if (not filepath) return null

      if (not exists(filepath))
        local parent = folder( filepath )
        if (parent.count == 0) parent = "."
        return "$$$" (absolute_filepath(parent),separator,filename(filepath))
      endIf

      local return_value : String

      native @|#if defined(_WIN32)
              |{
              |  char long_name[PATH_MAX+4];
              |  char full_name[PATH_MAX+4];
              |
              |  strcpy_s( long_name, PATH_MAX+4, (char*)$filepath->utf8 );
              |
              |  if (GetFullPathName(long_name, PATH_MAX+4, full_name, 0) != 0)
              |  {
              |    $return_value = RogueString_create_from_utf8( full_name, -1 );
              |  }
              |}
              |#else
              |{
              |  int original_dir_fd;
              |  int new_dir_fd;
              |  char filename[PATH_MAX];
              |  char c_filepath[ PATH_MAX ];
              |  bool is_folder;
              |
              |  is_folder = RogueFile__is_folder__String( $filepath );
              |
              |  int len = $filepath->byte_count;
              |  if (len >= PATH_MAX) len = PATH_MAX - 1;
              |  memcpy( c_filepath, (char*)$filepath->utf8, len );
              |  c_filepath[len] = 0;
              |
              |  // A way to get back to the starting folder when finished.
              |  original_dir_fd = open( ".", O_RDONLY );
              |
              |  if (is_folder)
              |  {
              |    filename[0] = 0;
              |  }
              |  else
              |  {
              |    // fchdir only works with a path, not a path+filename (c_filepath).
              |    // Copy out the filename and null terminate the filepath to be just a path.
              |    int i = (int) strlen( c_filepath ) - 1;
              |    while (i >= 0 && c_filepath[i] != '/' && c_filepath[i] != '\\') --i;
              |    strcpy( filename, c_filepath+i+1 );
              |    if (i == -1) strcpy( c_filepath, "." );
              |    else         c_filepath[i] = 0;
              |  }
              |  new_dir_fd = open( c_filepath, O_RDONLY );
              |
              |  do
              |  {
              |    if (original_dir_fd >= 0 && new_dir_fd >= 0)
              |    {
              |      int r = fchdir( new_dir_fd );
              |      if ( r != 0 ) break;
              |      char * r2 = getcwd( c_filepath, PATH_MAX );
              |      if ( r2 == 0 ) break;
              |      if ( !is_folder )
              |      {
              |        strcat( c_filepath, "/" );
              |        strcat( c_filepath, filename );
              |      }
              |      r = fchdir( original_dir_fd );
              |      if ( r != 0 ) break;
              |    }
              |
              |    $return_value = RogueString_create_from_utf8( c_filepath, -1 );
              |  } while (false);
              |
              |  if (original_dir_fd >= 0) close( original_dir_fd );
              |  if (new_dir_fd >= 0) close( new_dir_fd );
              |}
              |#endif
      if (return_value is null)
        throw IOError("Could not get absolute path")
      endIf
      return return_value

    method before_wildcard_pattern( filepath:String )->String
      # Example: alpha/beta/image*.png -> alpha/beta
      while (filepath.contains('?') or filepath.contains('*'))
        filepath = File.folder( filepath )
      endWhile
      return filepath

    method character_writer( filepath:String )->CharacterToUTF8ByteWriter
      return CharacterToUTF8ByteWriter( File.writer(filepath) )

    method copy( from_filepath:String, to_filepath:String, &if_newer, &if_size_different, &dry_run )->Logical
      # Copy always is the default or else only if newer and/or size different.
      if (if_newer)
        # The if_newer flag is a little convoluted to retain backwards compatibility
        return copy_newer( from_filepath, to_filepath, &=if_size_different, &=dry_run )
      else
        local modified = false

        if (File.is_folder(to_filepath))
          to_filepath += separator + File.filename(from_filepath)
        else
          local containing_folder = File.folder( to_filepath )
          if (not is_folder(containing_folder))
            if (not dry_run) File.create_folder( containing_folder )
            modified = true
          endIf
        endIf

        if (File.is_folder(from_filepath))
          if (not exists(to_filepath))
            if (not dry_run) File.create_folder( to_filepath )
            modified = true
          endIf
        else
          modified = true
          if (not dry_run)
            local reader = File.reader( from_filepath )
            local writer = File.writer( to_filepath )

            while (reader.has_another) writer.write( reader.read )

            writer.close
          endIf
        endIf

        return modified
      endIf

    method copy_newer( from_filepath:String, to_filepath:String, &if_size_different, &dry_run )->Logical
      if (File.is_folder(to_filepath))
        if (filename(from_filepath) != filename(to_filepath))
          return copy_newer( from_filepath, to_filepath + separator + File.filename(from_filepath),
            &=if_size_different, &=dry_run )
        endIf
      elseIf (File.is_newer_than(from_filepath,to_filepath))
        return copy( from_filepath, to_filepath, &=if_size_different, &=dry_run )
      endIf
      return false

    method create_folder( filepath:String )->Logical
      # Creates the specified folder along with intermediate folders
      # if necessary.  Returns 'true' on success or if the filepath
      # already exists as a folder.  Returns 'false' on failure to
      filepath = File.absolute_filepath( filepath )

      # create or if the filepath already exists but is not a folder.
      if (File.exists(filepath)) return File.is_folder( filepath )

      # Check for the parent folder's existence and recursively create
      # that if necessary.
      local parent = File.folder( filepath )
      if (not create_folder(parent)) return false

      # Note: 0777 is a permission mask rather than the actual permission setting.
      native @|#if defined(ROGUE_PLATFORM_WINDOWS)
              |  return (0 == mkdir((char*)$filepath->utf8));
              |#else
              |  return (0 == mkdir((char*)$filepath->utf8, 0777));
              |#endif

    method delete( filepath:String )->Logical
      if (not filepath) return false
      if (is_folder(filepath))
        delete( forEach in listing(filepath) )  # Recursively delete nested content
        return (0 == native( "rmdir( (const char*) $filepath->utf8 )")->Int32)
      endIf
      return (0 == native( "unlink( (const char*) $filepath->utf8 )")->Int32)

    method ends_with_separator( filepath:String )->Logical
      return (filepath.ends_with('/') or filepath.ends_with('\\'))

    method ensure_ends_with_separator( filepath:String )->String
      if (ends_with_separator(filepath)) return filepath
      return filepath + separator

    method exists( filepath:String )->Logical
      native @|if ( !$filepath ) return false;
              |
              |struct stat s;
              |return (stat((char*)$filepath->utf8, &s) == 0);

    method extension( filepath:String )->String
      return filepath.after_last( '.' )

    method filename( filepath:String )->String
      local i = filepath.locate_last( '/' )
      if (not i?) i = filepath.locate_last( '\\' )
      if (not i?) return filepath
      return filepath.from( i.value+1 )

    method fix_slashes( filepath:String )->String
      if (System.os == "Windows") return filepath.replacing( '/', '\\' )
      else                        return filepath.replacing( '\\', '/' )

    method folder( filepath:String )->String
      local i1 = filepath.locate_last( '/' )
      local i2 = filepath.locate_last( '\\' )
      if (i1.exists)
        if (i2.exists) i1 = i1.value.or_larger( i2.value )
      else
        i1 = i2
      endIf

      if (not i1?) return ""
      return filepath.from( 0, i1.value-1 )

    method is_folder( filepath:String )->Logical [essential]
      native @|if ( !$filepath ) return false;
              |
              |#if defined(ROGUE_PLATFORM_WINDOWS)
              |  struct stat s;
              |  if (stat((char*)$filepath->utf8, &s) != 0) return false;
              |  return (s.st_mode & S_IFMT) == S_IFDIR;
              |#else
              |  DIR* dir = opendir( (char*)$filepath->utf8 );
              |  if ( !dir ) return 0;
              |
              |  closedir( dir );
              |  return 1;
              |#endif

    method is_hidden( filepath:String )->Logical
      if (not filepath.begins_with('.'))       return false
      if (filepath == "." or filepath == "..") return false
      if (filepath.begins_with("./") or filepath.begins_with(".\\")) return false
      return true

    method is_newer_than( filepath:String, other_filepath:String )->Logical
      if (not File.exists(filepath))       return false
      if (not File.exists(other_filepath)) return true
      return (File.timestamp(filepath).floor > File.timestamp(other_filepath).floor)

    method join( parts:String[] )->String
      local buffer = StringBuilder()
      local first = true
      forEach part in parts
        if (not part) nextIteration
        if (not first) buffer.print(separator, &!formatted)
        first = false
        buffer.print(part)
      endForEach
      return buffer

    method join( part1:String, part2:String )->String
      return join(String[][part1, part2])

    method join( part1:String, part2:String, part3:String, part4=null:String, part5=null:String, part6=null:String )->String
      return join(String[][part1, part2, part3, part4, part5, part6])

    method listing( folder:String, &ignore_hidden, &recursive, &absolute, &omit_path, &files, &folders )->String[]
      local options = FileOptions()
      if (ignore_hidden) options = options.ignore_hidden
      if (recursive)     options = options.recursive
      if (absolute)      options = options.absolute
      if (omit_path)     options = options.omit_path
      if (files)         options = options.files
      if (folders)       options = options.folders
      return listing( folder, options )

    method listing( folder:String, options:FileOptions )->String[]
      if (folder == "./" or folder == ".\\") folder = "."
      if (folder.begins_with("./") or folder.begins_with(".\\")) folder = folder.from( 2 )

      if (folder.contains('*') or folder.contains('?'))
        local full_pattern = folder

        local parts = folder.replacing('\\','/').split('/')
        local non_wild_parts = String[]
        while (not parts.first.contains('*') and not parts.first.contains('?'))
          non_wild_parts.add( parts.remove_first )
        endWhile

        local non_wild_path = select{ non_wild_parts.count:non_wild_parts.join(separator) || "." }
        if (parts.first.contains("**"))
          # Implied recursion
          local filtered = String[]
          forEach (filepath in File.listing(non_wild_path, options.recursive.include_path))
            if (File.matches_wildcard_pattern(filepath,full_pattern))
              if (options.omitting_path)
                filtered.add( filepath.after_first(folder) )
              elseIf (options.is_absolute)
                filtered.add( File.absolute_filepath( filepath ) )
              else
                filtered.add( filepath )
              endIf
            endIf
          endForEach
          return filtered

        else
          # Wildcards are * or ? only
          local pattern = parts.remove_first
          local results = String[]
          forEach (name in File.listing(non_wild_path,options.limited.omit_path))
            if (is_hidden(name) and options.ignoring_hidden) nextIteration
            if (File.matches_wildcard_pattern(name,pattern))
              if (non_wild_path == ".")
                if (File.is_folder(name))
                  if (parts.count)
                    results.add( File.listing("$$$"(name,separator,parts.join(separator)),options) )
                  elseIf (options.is_recursive)
                    results.add( File.listing("$"(name),options) )
                  else
                    results.add( name )
                  endIf
                elseIf (parts.is_empty)
                  results.add( name )
                endIf
              else
                local subfolder = "$$$" (non_wild_path,separator,name)
                if (File.is_folder(subfolder))
                  if (parts.count)
                    results.add( File.listing("$$$"(subfolder,separator,parts.join(separator)),options) )
                  elseIf (options.is_recursive)
                    results.add( File.listing(subfolder, options) )
                  else
                    results.add( subfolder )
                  endIf
                elseIf (parts.is_empty)
                  results.add( subfolder )
                endIf
              endIf
            endIf
          endForEach
          return results
        endIf

      else
        return listing( folder, options, "", String[] )

      endIf

    method listing( folder:String, options:FileOptions, filepath:String, result:String[] )->String[]
      if (folder == ".") options = options.omit_path

      if (not options.omitting_path)
        if (options.is_absolute)
          filepath = File.absolute_filepath( folder )  # add absolute path to every entry
          folder = ""
          options = options.omit_path
        else
          filepath = folder
          folder = ""
          options = options.omit_path
        endIf
      endIf

      if (folder.count and not (folder.ends_with('/') or folder.ends_with('\\')))
        folder += separator
      endIf

      local native_folder = folder + filepath
      if (not is_folder(native_folder))
        if (File.exists(native_folder))
          if (not (is_hidden(native_folder) and options.ignoring_hidden))
            if (options.is_files)
              if (native_folder.count > 1 and (native_folder.ends_with('/') or native_folder.ends_with('\\')))
                native_folder = native_folder.leftmost( -1 )
              endIf
              result.add( native_folder )
            endIf
          endIf
        endIf
        return result
      endIf

      if (filepath.count and not (filepath.ends_with('/') or filepath.ends_with('\\')))
        filepath += File.separator
      endIf

      native @|#ifdef ROGUE_PLATFORM_WINDOWS

      local search_filepath = filepath + "*"

      native @|{
              |  WIN32_FIND_DATA entry;
              |  HANDLE dir;
              |
              |  dir = FindFirstFile( $search_filepath->utf8, &entry );
              |
              |  if (dir != INVALID_HANDLE_VALUE)
              |  {
              |    do
              |    {
              |      int keep = 1;
              |      if (entry.cFileName[0] == '.')
              |      {
              |        switch (entry.cFileName[1])
              |        {
              |          case 0:   // '.' / this folder
              |            keep = 0;
              |            break;
              |          case '.':
              |            keep = entry.cFileName[2] != 0;  // ".." / Parent Folder
              |            break;
              |        }
              |      }
              |      if (keep)
              |      {
                       block
                         local entry = native("RogueString_create_from_utf8(entry.cFileName,-1)")->String
                         if (not (is_hidden(entry) and options.ignoring_hidden))
                           entry = filepath + entry
                           local _is_folder = is_folder( folder + entry )
                           if (options.is_files_and_folders or
                               (_is_folder and options.is_folders) or
                               (not _is_folder and options.is_files))
                             result.add( entry )
                           endIf

                           if (_is_folder and options.is_recursive and entry.count)
                             listing( folder, options, entry, result )
                           endIf
                         endIf
                       endBlock
      native @|      }
              |    }
              |    while (FindNextFile(dir,&entry));
              |
              |    FindClose( dir );
              |  }
              |}
              |#else
              |// Mac/Linux
              |{
              |  DIR* dir;
              |  struct dirent* entry;
              |
              |  dir = opendir( (const char*) $native_folder->utf8 );
              |  if (dir)
              |  {
              |    entry = readdir( dir );
              |    while (entry)
              |    {
              |      int keep = 1;
              |      if (entry->d_name[0] == '.')
              |      {
              |        switch (entry->d_name[1])
              |        {
              |          case 0:   // '.' / this folder
              |            keep = 0;
              |            break;
              |          case '.':
              |            keep = entry->d_name[2] != 0;  // ".." / Parent Folder
              |            break;
              |        }
              |      }
              |      if (keep)
              |      {
                       block
                         local entry = native("RogueString_create_from_utf8(entry->d_name,-1)")->String
                         if (not (is_hidden(entry) and options.ignoring_hidden))
                           entry = filepath + entry
                           local _is_folder = is_folder( folder + entry )
                           if (options.is_files_and_folders or
                               (_is_folder and options.is_folders) or
                               (not _is_folder and options.is_files))
                             result.add( entry )
                           endIf

                           if (_is_folder and options.is_recursive and entry.count)
                             listing( folder, options, entry, result )
                           endIf
                         endIf
                       endBlock

      native @|
              |      }
              |      entry = readdir( dir );
              |    }
              |    closedir( dir );
              |  }
              |}
              |#endif // Windows vs Mac/Linux

      return result


    method load_as_bytes( filepath:String )->Byte[]
      local count = size( filepath )
      local bytes = Byte[]( count )
      local infile = reader( filepath )
      forEach (1..count) bytes.add( infile.read )
      infile.close
      return bytes

    method load_as_string( filepath:String )->String
      local count = size( filepath )
      local buffer = StringBuilder( count )
      local infile = reader( filepath )
      forEach (1..count)
        local b = infile.read
        buffer.utf8.add( b )
        if ((b & 0xC0) != 0x80) ++buffer.count
      endForEach
      infile.close
      return buffer->String

    method matches_wildcard_pattern( filepath:String, pattern:String )->Logical
      # Determines whether or not the given filepath matches the given
      # semi-Unix/Dos-style 'wildcard pattern'.  'pattern' is a
      # regular text string that may contain the following special
      # characters:
      #
      # *  - Matches any number of characters but does not match '/' or '\'
      # ** - Matches any number of characters including slashes
      # ?  - Matches any one character except '/' and '\'

      # Check non-wildcard characters at the end of pattern first as an easy out
      local last_wildcard = -1
      forEach (ch at i in pattern step -1)
        if (ch == '*' or ch == '?')
          last_wildcard = i
          escapeForEach
        endIf
      endForEach

      if (last_wildcard != -1)
        local end_count = pattern.count - (last_wildcard+1)
        if (end_count > 0)
          if (end_count > filepath.count) return false

          local i = last_wildcard + 1
          forEach (ch in filepath from filepath.count-end_count)
            if (ch != pattern[i]) return false
            ++i
          endForEach
        endIf
      endIf

      return _matches_wildcard_pattern( filepath, 0, filepath.count, pattern, 0, pattern.count )

    method _matches_wildcard_pattern( filepath:String, f0:Int32, fcount:Int32, pattern:String, p0:Int32, pcount:Int32 )->Logical
      if (pcount == 0) return (fcount == 0)

      local remaining_pattern = pattern
      local r0 = p0 + 1
      local rcount = pcount - 1
      local ch = pattern[p0]
      which (ch)
        case '*':
          if (rcount and remaining_pattern[r0] == '*')
            # Double asterisk - match all characters including '/' and '\'
            ++r0
            --rcount
            forEach (n in 0..fcount)
              if (_matches_wildcard_pattern(filepath,f0+n,fcount-n,remaining_pattern,r0,rcount)) return true
            endForEach
          else
            # Single asterisk - match any characters except '/' and '\'
            forEach (n in 0..<fcount)
              ch = filepath[ f0+n ]
              if (_matches_wildcard_pattern(filepath,f0+n,fcount-n,remaining_pattern,r0,rcount)) return true
              if (ch == '/' or ch == '\\') return false
            endForEach
            return _matches_wildcard_pattern( "", 0, 0, remaining_pattern, r0, rcount )
          endIf

        case '?':
          if (fcount == 0) return false
          ch = filepath[ f0 ]
          if (ch == '/' or ch == '\\') return false
          return _matches_wildcard_pattern( filepath, f0+1, fcount-1, remaining_pattern, r0, rcount )

        others:
          if (fcount == 0) return false
          if (ch == filepath[f0])
            return _matches_wildcard_pattern( filepath, f0+1, fcount-1, remaining_pattern, r0, rcount )
          endIf
      endWhich
      return false

    method options->FileOptions
      return FileOptions()

    method parent( filepath:String, level=1:Int32 )->String
      if (level <= 0) return filepath
      if (level == 1) return folder( filepath )
      return parent( folder(filepath), level-1 )

    method path( filepath:String )->String
      return folder( filepath )

    method reader( filepath:String )->FileReader
      return FileReader( filepath )

    method save( filepath:String, data:Byte[] )->Logical
      local outfile = writer( filepath )
      outfile.write( data )
      outfile.close
      return not outfile.error

    method save( filepath:String, data:String )->Logical
      local outfile = writer( filepath )
      outfile.write( data )
      outfile.close
      return not outfile.error

    method save( filepath:String, data:StringBuilder )->Logical
      local outfile = writer( filepath )
      outfile.write( data )
      outfile.close
      return not outfile.error

    method separator->Character
      native @|#if defined(ROGUE_PLATFORM_WINDOWS)
              |  return '\\';
              |#else
              |  return '/';
              |#endif

    method size( filepath:String )->Int64
      native @|if ( !$filepath ) return 0;
              |
              |FILE* fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !fp ) return 0;
              |
              |fseek( fp, 0, SEEK_END );
              |RogueInt64 size = (RogueInt64) ftell( fp );
              |fclose( fp );
              |
              |return size;

    method sync_from( source_folder:String, dest_folder:String, &verbose, &keep_unused, &dry_run )->Int32
      return sync_from( Files(source_folder).add("**"), dest_folder, &=verbose, &=keep_unused, &=dry_run )

    method sync_from( source_files:Files, dest_folder:String, &verbose, &keep_unused, &dry_run )->Int32
      if (dry_run) verbose = true
      dest_folder = File.fix_slashes( dest_folder )

      if (not exists(dest_folder) and not dry_run)
        create_folder( dest_folder )
        if (not is_folder(dest_folder))
          Console.error.println( "ERROR: File.sync_from() can not create destination folder $" (dest_folder) )
          return 0
        endIf
      endIf

      dest_folder = ensure_ends_with_separator( dest_folder )
      local dest_name = dest_folder
      if (dest_name.begins_with("./") or dest_name.begins_with(".\\")) dest_name = dest_name.from( 2 )

      if (dest_name == source_files.base_folder)
        Console.error.println( "ERROR: File.sync_from() has the same source and destination folders ($)."...
          (dest_folder.leftmost(-1)) )
        return 0
      endIf

      local width = 0
      width = width.or_larger( (forEach in source_files).count )
      width -= source_files.base_folder.count

      local dest_files = Files( dest_folder )
      if (not keep_unused) dest_files.add( "**" )
      local printed_header = false
      local modified = 0
      forEach (src_filepath in source_files)
        local relative_filepath = source_files.relative_filepath( src_filepath )
        local dest_filepath = dest_name + relative_filepath
        dest_files.remove( dest_filepath )
        local folder = File.folder( dest_filepath )
        while (dest_files.contains(folder))
          dest_files.remove( folder )
          folder = File.folder( folder )
        endWhile

        if (copy_newer(src_filepath,dest_filepath,&if_size_different,&=dry_run))
          ++modified
          if (verbose)
            if (not printed_header)
              printed_header = true
              local src = source_files.base_folder
              if (src.count) src = src.leftmost( -1 )
              else           src = "."
              local dest = dest_folder.leftmost( -1 )
              Console.println( "Copying $ -> $" (src,dest) )
            endIf
            Console.print( "  " ).println( relative_filepath )
          endIf
        endIf
      endForEach

      if (not keep_unused)
        printed_header = false
        forEach (filepath in dest_files)
          if (verbose)
            if (not printed_header)
              printed_header = true
              Console.println( "Deleting unused files" )
            endIf
            Console.print( "  " ).println( dest_files.relative_filepath(filepath) )
          endIf
          if (not dry_run) delete( filepath )
          ++modified
        endForEach
      endIf

      return modified

    method timestamp( filepath:String )->Real64
      # Returns the last modified time since Jan 1, 1970
      native @|#if defined(_WIN32)
              |  HANDLE handle = CreateFile( (const char*)$filepath->utf8, 0, 0, NULL, OPEN_EXISTING,
              |      FILE_ATTRIBUTE_NORMAL, NULL );
              |  if (handle != INVALID_HANDLE_VALUE)
              |  {
              |    BY_HANDLE_FILE_INFORMATION info;
              |    if (GetFileInformationByHandle( handle, &info ))
              |    {
              |      RogueInt64 result = info.ftLastWriteTime.dwHighDateTime;
              |      result <<= 32;
              |      result |= info.ftLastWriteTime.dwLowDateTime;
              |      result /= 10000; // convert from Crazyseconds to Milliseconds
              |      result -= 11644473600000;  // base on Jan 1, 1970 instead of Jan 1, 1601 (?!)
              |      CloseHandle(handle);
              |      return result / 1000.0;
              |    }
              |    CloseHandle(handle);
              |  }
              |
              |#elif defined(ROGUE_PLATFORM_UNIX_COMPATIBLE)
              |  int file_id = open( (const char*)$filepath->utf8, O_RDONLY );
              |  if (file_id >= 0)
              |  {
              |    struct stat info;
              |    if (0 == fstat(file_id, &info))
              |    {
              |#if defined(__APPLE__)
              |      RogueInt64 result = info.st_mtimespec.tv_sec;
              |      result *= 1000000000;
              |      result += info.st_mtimespec.tv_nsec;
              |      result /= 1000000;  // convert to milliseconds
              |#else
              |      RogueInt64 result = (RogueInt64) info.st_mtime;
              |      result *= 1000;  // convert to ms
              |#endif
              |      close(file_id);
              |      return result / 1000.0;
              |    }
              |    close(file_id);
              |  }
              |
              |#else
              |# error Must define File.timestamp() for this OS.
              |#endif
              |return 0.0;


    method writer( filepath:String )->FileWriter
      return FileWriter( filepath )

    method append_writer( filepath:String )->FileWriter
      return FileWriter( filepath, &append=true )

  PROPERTIES
    filepath : String

  METHODS
    method init( filepath:String )
      this.filepath = fix_slashes( filepath )

    method absolute_filepath->String
      return File.absolute_filepath( this.filepath )

    method before_wildcard_pattern->String
      return File.before_wildcard_pattern( this.filepath )

    method character_writer->CharacterToUTF8ByteWriter
      return CharacterToUTF8ByteWriter( this.writer )

    method copy( to_filepath:String, &if_newer, &if_size_different, &dry_run )->Logical
      return File.copy( this.filepath, to_filepath, if_newer, if_size_different, dry_run )

    method copy_newer( to_filepath:String, &if_size_different, &dry_run )->Logical
      return File.copy_newer( this.filepath, to_filepath, if_size_different, dry_run )

    method create_folder->Logical
      return File.create_folder( this.filepath )

    method ends_with_separator->Logical
      return File.ends_with_separator( this.filepath )

    method ensure_ends_with_separator->this
      if (not ends_with_separator) filepath += separator
      return this

    method delete->Logical
      return File.delete( this.filepath )

    method exists->Logical
      return File.exists( this.filepath )

    method extension->String
      return File.extension( this.filepath )

    method filename->String
      return filename( filepath )

    method fix_slashes->String
      return fix_slashes( filepath )

    method folder->String
      return File.folder( this.filepath )

    method is_folder->Logical
      return File.is_folder( this.filepath )

    method is_hidden->Logical
      return File.is_hidden( this.filepath )

    method is_newer_than( other_filepath:String )->Logical
      return File.is_newer_than( this.filepath, other_filepath )

    method listing( &ignore_hidden, &recursive, &absolute, &omit_path, &files, &folders )->String[]
      return File.listing( this.filepath, ignore_hidden, recursive, absolute, omit_path, files, folders )

    method listing( options:FileOptions )->String[]
      return File.listing( this.filepath, options )

    method load_as_bytes->Byte[]
      return File.load_as_bytes( this.filepath )

    method load_as_string->String
      return File.load_as_string( this.filepath )

    method matches_wildcard_pattern( pattern:String )->Logical
      return File.matches_wildcard_pattern( this.filepath, pattern )

    method parent( level=1:Int32 )->String
      return File.parent( this.filepath, level )

    method path->String
      return File.folder( this.filepath )

    method reader->FileReader
      return File.reader( this.filepath )

    method save( data:Byte[] )->Logical
      return File.save( this.filepath, data )

    method save( data:String )->Logical
      return File.save( this.filepath, data )

    method save( data:StringBuilder )->Logical
      return File.save( this.filepath, data )

    method size->Int64
      return File.size( this.filepath )

    method sync_from( source_folder:String, &verbose, &keep_unused, &dry_run )->Int32
      return File.sync_from( source_folder, this.filepath, verbose, keep_unused, dry_run )

    method sync_from( source_files:Files, &verbose, &keep_unused, &dry_run )->Int32
      return File.sync_from( source_files, this.filepath, verbose, keep_unused, dry_run )

    method timestamp->Real64
      return File.timestamp( this.filepath )

    method writer->FileWriter
      return File.writer( this.filepath )

    method append_writer->FileWriter
      return File.append_writer( this.filepath )

    method to->String
      return filepath
endClass

class FileOptions( flags=0:Int32 ) [compound]
  ENUMERATE
    FLAG_RECURSIVE          = 1
    FLAG_OMIT_PATH          = 2
    FLAG_ABSOLUTE           = 4
    FLAG_FILES              = 8
    FLAG_FOLDERS            = 16
    FLAG_BOTH               = 24
    FLAG_IGNORE_HIDDEN      = 32

  METHODS
    method absolute->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_ABSOLUTE )

    method ignore_hidden->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_IGNORE_HIDDEN )

    method ignoring_hidden->Logical [macro]
      (this.flags & FileOptions.FLAG_IGNORE_HIDDEN)

    method is_files_and_folders->Logical
      local f = (flags & FLAG_BOTH)
      return (f == 0) or (f == FLAG_BOTH)

    method is_files->Logical
      return (flags & FLAG_FILES) or not (flags & FLAG_BOTH)

    method is_folders->Logical
      return (flags & FLAG_FOLDERS) or not (flags & FLAG_BOTH)

    method is_absolute->Logical [macro]
      (this.flags & FileOptions.FLAG_ABSOLUTE)

    method files->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_FILES )

    method folders->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_FOLDERS )

    method include_path->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_OMIT_PATH )

    method includes_path->Logical [macro]
      ((this.flags & FileOptions.FLAG_OMIT_PATH) == 0)

    method is_limited->Logical [macro]
      (not (this.flags & FileOptions.FLAG_RECURSIVE))

    method is_recursive->Logical [macro]
      (this.flags & FileOptions.FLAG_RECURSIVE)

    method is_relative->Logical [macro]
      (not (this.flags & FileOptions.FLAG_ABSOLUTE))

    method limited->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_RECURSIVE )

    method omit_path->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_OMIT_PATH )

    method omitting_path->Logical [macro]
      (this.flags & FileOptions.FLAG_OMIT_PATH)

    method relative->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_ABSOLUTE )

    method recursive->FileOptions [macro]
      FileOptions( this.flags | FileOptions.FLAG_RECURSIVE )

    method showing_hidden->FileOptions [macro]
      FileOptions( this.flags & !FileOptions.FLAG_IGNORE_HIDDEN )

    method shows_hidden->Logical [macro]
      (not (this.flags & FileOptions.FLAG_IGNORE_HIDDEN))

endClass

class FileReader : Reader<<Byte>>
  PROPERTIES
    filepath        : String
    count           : Int32
    position        : Int32
    buffer_position : Int32
    buffer          = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String )
      if (not open(_filepath))
        throw IOError( "Unable to open $ for reading." (filepath) )
      endIf

    method on_cleanup
      close

    method close->this
      if (fp)
        native @|fclose( $this->fp );
                |$this->fp = 0;
      endIf

      position = 0
      count = 0
      return this

    method fp->IntPtr [macro]
      native "$this->fp"

    method has_another->Logical
      return (position < count)

    method open( filepath )->Logical
      close

      filepath = File.fix_slashes( filepath )

      native @|$this->fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !$this->fp ) return false;
              |
              |fseek( $this->fp, 0, SEEK_END );
              |$count = (RogueInt32) ftell( $this->fp );
              |fseek( $this->fp, 0, SEEK_SET );

      # Always close after the last byte is read, so if there are no
      # bytes then close right away.
      if (count == 0) close

      return true

    method peek->Byte
      if (position == count) return 0

      if (buffer_position == buffer.count)
        native @|$buffer->count = (RogueInt32) fread( $buffer->data->as_bytes, 1, 1024, $this->fp );
        buffer_position = 0
      endIf

      return buffer[ buffer_position ]

    method read->Byte
      if (position == count) return 0

      local result = peek

      ++position
      ++buffer_position
      if (position == count) close

      return result

    method remaining->Int32
      return count - position

    method reset->this
      if (not fp) return this
      count = native( "(RogueInt32)ftell($this->fp)" )->Int32
      return seek( 0 )

    method seek( pos:Int32 )->this
      if (not fp) return this

      if (pos < 0) pos = 0
      if (pos > count) pos = count

      position = pos
      native "fseek( $this->fp, $position, SEEK_SET );"

      buffer_position = 0
      buffer.clear
      return this
endClass


class FileWriter : Writer<<Byte>>
  PROPERTIES
    filepath : String
    error    : Logical
    buffer   = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String, append=false:Logical )
      if (not open(_filepath,append))
        throw IOError( "Unable to open $ for writing." (filepath) )
      endIf

    method on_cleanup
      close

    method close->this
      $if (target("Web")) nativeHeader extern "C" void Rogue_sync_local_storage();

      flush

      if (fp)
        native @|fclose( $this->fp ); $this->fp = 0;
        System.sync_storage
      endIf

      return this

    method flush->this
      if (buffer.count == 0 or not fp) return this

      native @|fwrite( $buffer->data->as_bytes, 1, $buffer->count, $this->fp );
              |fflush( $this->fp );

      buffer.clear
      return this

    method fp->IntPtr [macro]
      native( "$this->fp" )

    method open( filepath, append=false:Logical )->Logical
      close
      error = false

      filepath = File.fix_slashes( filepath )

      if (append)
        native @|$this->fp = fopen( (char*)$filepath->utf8, "ab" );
      else
        native @|$this->fp = fopen( (char*)$filepath->utf8, "wb" );
      endIf

      native "$this->error = !($this->fp);"

      return not error

    method reset->this
      if (not fp) return this
      flush
      return seek( 0 )

    method seek( pos:Int32 )->this
      if (not fp) return this
      flush
      if (pos < 0) pos = 0
      position = pos

      native "fseek( $this->fp, 0, SEEK_SET );"

      return this

    method seek_end()->this
      if (not fp) return this
      flush

      native "fseek( $this->fp, 0, SEEK_END );"
      position = native( "(RogueInt32)ftell( $this->fp )" )->Int32

      return this

    method write( ch:Byte )->this
      if (not fp) return this

      ++position
      buffer.add( ch )
      if (buffer.count == 1024) return flush

      return this

    method write( bytes:Byte[] )->this
      if (not fp) return this

      if (bytes.count < 1024)
        forEach (byte in bytes) write( byte )
      else
        flush
        position += bytes.count
        native @|fwrite( $bytes->data->as_bytes, 1, $bytes->count, $this->fp );
      endIf
      return this

    method write( data:String )->this
      if (not fp) return this

      if (data.count < 1024)
        forEach (i in 0..<data.byte_count) write( data.byte(i) )
      else
        flush
        position += data.byte_count
        native @|fwrite( $data->utf8, 1, $data->byte_count, $this->fp );
      endIf
      return this

    method write( builder:StringBuilder )->this
      return write( builder.utf8 )
endClass


class FDReader : Reader<<Byte>>
  GLOBAL METHODS
    method stderr->FDReader
      return FDReader( native("STDERR_FILENO")->Int32, &!auto_close )

    method stdin->FDReader
      return FDReader( native("STDIN_FILENO")->Int32, &!auto_close )

  PROPERTIES
    fd              : Int32
    position        : Int32
    buffer_position : Int32
    auto_close      : Logical
    buffer          = Byte[](1024)

  METHODS
    method init( fd, auto_close=true )

    method on_cleanup
      if (auto_close) close

    method buffer_more->Logical
      # Used by Process which needs to keep buffering from both the stdout and stderr of a process
      # to make sure the process doesn't get blocked.
      if (fd < 0) return false

      buffer.reserve( 1024 )
      local cur_count = buffer.count

      local n : Int32
      native @|$n = (RogueInt32) read( $fd, $buffer->data->as_bytes+$cur_count, 1024 );
      if (n <= 0)
        if (auto_close) close
        fd = -1
        return false
      endIf
      buffer.count += n

      return true

    method close->this
      if (fd >= 0)
        native @|close( $fd );
        fd = -1
      endIf
      return this

    method is_open->Logical
      return fd != -1

    method has_another->Logical
      return (fd >= 0 or buffer_position < buffer.count)

    method peek->Byte
      if (not has_another) return 0

      if (buffer_position == buffer.count)
        buffer.clear
        buffer_position = 0
        if (not buffer_more) return 0
      endIf

      return buffer[ buffer_position ]

    method read->Byte
      if (not has_another) return 0

      local result = peek

      ++position
      ++buffer_position

      return result

endClass


class FDWriter : Writer<<Byte>>
  GLOBAL METHODS
    method stdout->FDWriter
      return FDWriter( native("STDOUT_FILENO")->Int32, &!auto_close )

  PROPERTIES
    fd         : Int32
    auto_close : Logical
    error      : Logical
    buffer     = Byte[](1024)

  METHODS
    method init( fd, auto_close=true )

    method on_cleanup
      if (auto_close) close

    method close->this
      flush

      if (fd != -1)
        native @|close( $fd );
        fd = -1
      endIf

      return this

    method flush->this
      if (buffer.count == 0 or fd == -1) return this

      native @|if (-1 == write( $fd, $buffer->data->as_bytes, $buffer->count ))
              |{
              |  if ($auto_close) close( $fd );
              |  $fd = -1;
              |}

      buffer.clear
      return this

    method write( ch:Byte )->this
      ++position
      buffer.add( ch )
      if (buffer.count == 1024) return flush

      return this

    method write( bytes:Byte[] )->this
      if (fd == -1 or bytes.count == 0) return this

      if (bytes.count < 1024)
        forEach (byte in bytes) write( byte )
      else
        flush
        position += bytes.count
        native @|if (-1 == write( $fd, $bytes->data->as_bytes, $bytes->count ))
                |{
                |  if ($auto_close) close( $fd );
                |  $fd = -1;
                |}
      endIf

      return this

    method write( data:String )->this
      if (fd == -1 or data.count == 0) return this

      if (data.count < 1024)
        forEach (i in 0..<data.byte_count) write( data.byte(i) )
      else
        flush
        position += data.byte_count
        native @|if (-1 == write( $fd, $data->utf8, $data->byte_count ))
                |{
                |  if ($auto_close) close( $fd );
                |  $fd = -1;
                |}
      endIf

      return this

    method write( builder:StringBuilder )->this
      return write( builder.utf8 )
endClass

