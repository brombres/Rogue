library UI

class Component : Entity
  PROPERTIES
    position        : XY
    size            : XY

    anchor          : Anchor?
    content_alignment       : Anchor?
    sizing_mode     : SizingModeXY
    natural_size    : XY
    layout_size     : XY
    aspect_size     : XY
    content_offset  : XY
    weight          = XY(1,1)
    opacity         = 1.0
    content_opacity = 1.0
    font            : Font
    text_style      : TextStyle
    size_reference  : Component

    on_begin_layout_callback : Function(Component)

  METHODS # Overrides
    method init
      noAction

    method init( child:Component )
      add( child )

    method init( fixed_size:XY )
      this.fixed_size = fixed_size

    method on( e:KeyEvent )
      noAction

    method on( e:PointerEvent )
      noAction

    method on( e:ScrollEvent )
      noAction

    method on( e:TextEvent )
      noAction

    method on_begin_layout
      # Called at the beginning of layout
      noAction

    method on_begin_layout( on_begin_layout_callback )
      # Sets a callback that is called after this component's on_begin_layout()
      noAction

    method on_layout_size( layout_size:XY )
      # Called when this component's size has been set but before
      # child component sizes are set.
      noAction

    method on_unhandled( e:KeyEvent )
      noAction

    method on_unhandled( e:PointerEvent )
      noAction

    method on_unhandled( e:ScrollEvent )
      noAction

    method on_unhandled( e:TextEvent )
      noAction

    method on_end_layout
      noAction

    method on_release_keyboard_focus
      noAction

    method on_release_pointer_focus
      noAction

  METHODS # Public API
    method align_content( @content_alignment )
      noAction

    method align_content_top_left
      content_alignment = Anchor.TOP_LEFT

    method align_content_top
      content_alignment = Anchor.TOP

    method align_content_top_right
      content_alignment = Anchor.TOP_RIGHT

    method align_content_left
      content_alignment = Anchor.LEFT

    method align_content_center
      content_alignment = Anchor.CENTER

    method align_content_right
      content_alignment = Anchor.RIGHT

    method align_content_bottom_left
      content_alignment = Anchor.BOTTOM_LEFT

    method align_content_bottom
      content_alignment = Anchor.BOTTOM

    method align_content_bottom_right
      content_alignment = Anchor.BOTTOM_RIGHT

    method anchor->Anchor
      if local result = @anchor
        return result
      else
        if local parent_component = parent->(as Component)
          return parent_component.content_alignment
        else
          return Anchor.CENTER
        endIf
      endIf

    method anchor_top_left
      anchor = Anchor.TOP_LEFT

    method anchor_top
      anchor = Anchor.TOP

    method anchor_top_right
      anchor = Anchor.TOP_RIGHT

    method anchor_left
      anchor = Anchor.LEFT

    method anchor_center
      anchor = Anchor.CENTER

    method anchor_right
      anchor = Anchor.RIGHT

    method anchor_bottom_left
      anchor = Anchor.BOTTOM_LEFT

    method anchor_bottom
      anchor = Anchor.BOTTOM

    method anchor_bottom_right
      anchor = Anchor.BOTTOM_RIGHT

    method aspect_fit( aspect_size )
      sizing_mode = SizingModeXY( SizingMode.ASPECT_FIT, SizingMode.ASPECT_FIT )

    method aspect_fit_height( aspect_size )
      sizing_mode.y = SizingMode.ASPECT_FIT

    method aspect_fit_width( aspect_size )
      sizing_mode.x = SizingMode.ASPECT_FIT

    method content_alignment->Anchor
      if local result = @content_alignment
        return result
      else
        if local parent_component = parent->(as Component)
          return parent_component.content_alignment
        else
          return Anchor.CENTER
        endIf
      endIf

    method font->Font
      if (@font) return @font
      return parent->(as Component)?.font

    method font<<$AsType>>()->$AsType
      return font->(as $AsType)

    method begin_child_layout
      use components = WorkList<<Component>>
        collect_child_display_components( components )
        (forEach in components).begin_layout
      endUse

    method begin_layout( &only_children )
      if (not only_children)
        on_begin_layout_internal
        on_begin_layout
        if (on_begin_layout_callback) on_begin_layout_callback( this )
      endIf

      begin_child_layout

    method bg_color->Graphics::Color?
      return parent->(as Component)?.bg_color

    method bounds->Box
      return Box( position, size )

    method capture_pointer_focus->Logical
      if (UI.focus.pointer and UI.focus.pointer is not this) return false
      UI.focus.pointer = this
      return true

    method collect_child_display_components( list:Component[], &only_visible )
      # Collect child components that need to be laid out, skipping any meta-components.
      (forEach as Component in children).collect_display_components( list, &=only_visible )

    method collect_display_components( list:Component[], &only_visible )
      if (not only_visible or not attributes.invisible)
        if (is_display_component)
          list.add( this )
        else
          collect_child_display_components( list, &=only_visible )
        endIf
      endIf

    method color->Graphics::Color?
      return parent->(as Component)?.color

    method contains( at_position:XY )->Logical
      return find( at_position )?

    method contains( e:PointerEvent )->Logical
      return contains( e.position )

    method content_bounds->Box
      return Box( content_position, content_size )

    method content_opacity->Real
      if local parent_component = parent->(as Component)
        return parent_component.content_opacity * @content_opacity
      else
        return @content_opacity
      endIf

    method content_position->XY
      return XY.zero

    method content_size->XY
      return size

    method content_size_to_layout_size( content_size:XY )->XY
      return content_size

    $localMacro DISPATCH_EVENT
      # Send input events to children in reverse order because the top layer comes last
      next_component?.dispatch( e )
      if (e.is_consumed) return
      handle( e )
    $endLocalMacro

    method dispatch( e:KeyEvent )
      DISPATCH_EVENT

    method dispatch( e:PointerEvent )
      DISPATCH_EVENT

    method dispatch( e:ScrollEvent )
      DISPATCH_EVENT

    method dispatch( e:TextEvent )
      DISPATCH_EVENT

    method display_bounds->Box
      return Box( display_position, size )

    method content_display_bounds->Box
      return content_bounds + display_position

    method display_position->XY
      if local parent_component = parent->(as Component)
        return parent_component.display_position + parent_component.content_offset + position
      else
        return position
      endIf

    method end_layout( &only_children )
      if (not only_children)
        on_end_layout_internal
        on_end_layout
      endIf

      use components = WorkList<<Component>>
        collect_child_display_components( components )
        (forEach in components).end_layout
      endUse

    method expand_to_fill
      sizing_mode = SizingModeXY( SizingMode.EXPAND_TO_FILL, SizingMode.EXPAND_TO_FILL )

    method expand_to_fill_height
      sizing_mode.y = SizingMode.EXPAND_TO_FILL

    method expand_to_fill_width
      sizing_mode.x = SizingMode.EXPAND_TO_FILL

    method find( at_position:XY )->Entity
      if (not display_bounds.contains(at_position)) return null

      forEach (child as Component in children)
        if local result = child.find( at_position )
          return result
        endIf
      endForEach

      return this

    method find_h_split( max_width:Real )->Real?
      return null

    method first_child_component->Component
      forEach (child as Component in children)
        return child
      endForEach
      return null

    method handle( e:KeyEvent )
      if (attributes.intangible) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_unhandled( e )

    method handle( e:PointerEvent )
      if (attributes.intangible) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_unhandled( e )

    method handle( e:ScrollEvent )
      if (attributes.intangible) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_unhandled( e )

    method handle( e:TextEvent )
      if (attributes.intangible) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_unhandled( e )

    method has_keyboard_focus->Logical
      return UI.focus.keyboard is this

    method has_pointer_focus->Logical
      return UI.focus.pointer is this

    method is_br->Logical
      return false

    method is_display_component->Logical
      # If false, this component is considered an informational meta-component.
      return true

    method is_space->Logical
      return false

    method keyboard_focus->Component
      return UI.focus.keyboard

    method line_height->Real
      return size.y

    method manually_update_content_layout( setting=true:Logical )
      attributes.manually_update_content_layout = setting

    method minimum_layout_size( available_size:XY, &limited )->XY
      local sz : XY
      use components = WorkList<<Component>>
        collect_child_display_components( components )
        sz = sz.or_larger( (forEach in components).resolve_layout_size( available_size, &=limited ) )
      endUse
      return sz

    method next_component->Component
      local next_entity = next
      local next_component = next_entity->(as Component)
      while (next_entity and not next_component)
        next_entity = next_entity.next
        next_component = next_entity->(as Component)
      endWhile
      return next_component

    method on_begin_layout_internal
      noAction

    method on_end_layout_internal
      noAction

    method opacity->Real
      if local parent_component = parent->(as Component)
        return parent_component.content_opacity * @opacity
      else
        return @opacity
      endIf

    method operator+( rhs:Component )->Component
      return UIGeneratedHBox( this ).[ add(rhs) ]

    method operator/( rhs:Component )->Component
      return UIGeneratedVBox( this ).[ add(rhs) ]

    method operator|( rhs:Component )->Component
      return UIGeneratedStack( this ).[ add(rhs) ]

    method perform_layout( position )
      if (not attributes.manually_update_content_layout)
        perform_child_layout
      endIf

    method perform_child_layout
      localize anchor
      localize content_bounds
      use components = WorkList<<Component>>
        collect_child_display_components( components )
        forEach (component in components)
          local bounds = component.bounds.positioned_within(
            content_bounds,
            component.anchor
          )
          component.perform_layout( bounds.position )
        endForEach
      endUse

    method pointer_focus->Component
      return UI.focus.pointer

    method release_focus
      release_keyboard_focus
      release_pointer_focus

    method release_keyboard_focus
      if (UI.focus.keyboard is this)
        on_release_keyboard_focus
        UI.focus.keyboard = null
      endIf

    method release_pointer_focus
      if (UI.focus.pointer is this)
        on_release_pointer_focus
        UI.focus.pointer = null
      endIf

    method request_layout
      UI.needs_layout = true

    method request_redraw
      UI.needs_redraw = true

    method resolve_layout_size( available_size:XY, &limited )->XY
      local sz = available_size
      if (sizing_mode.x == SizingMode.ASPECT_FIT)
        if (sizing_mode.y == SizingMode.ASPECT_FIT)
          local scale_x = (available_size.x / (aspect_size.x || 1.0))
          local scale_y = (available_size.y / (aspect_size.y || 1.0))
          sz = aspect_size * scale_x.or_smaller( scale_y )
        elseIf (sizing_mode.y != SizingMode.SHRINK_TO_FIT)
          sz.y = .resolve_layout_height( available_size )
          local scale_y = (sz.y / (aspect_size.y || 1.0))
          sz.x = (aspect_size * scale_y).x
        endIf
      elseIf (sizing_mode.y == SizingMode.ASPECT_FIT)
        if (sizing_mode.x != SizingMode.SHRINK_TO_FIT)
          sz.x = .resolve_layout_width( available_size )
          local scale_x = (sz.x / (aspect_size.x || 1.0))
          sz.y = (aspect_size * scale_x).y
        endIf
      else
        sz.x = .resolve_layout_width( available_size )
        sz.y = .resolve_layout_height( available_size )
      endIf

      if (UI.snap_to_pixel_coordinates) sz .= floor
      size = sz

      if (attributes.manually_update_content_layout)
        on_layout_size( size )
      else
        sz = .resolve_shrink_to_fit_layout_size( &=limited )
        if (not limited)
          resolve_child_layout_sizes
        endIf
      endIf

      return sz

    method .resolve_layout_height( available_size:XY )->Real
      local h = available_size.y
      which (sizing_mode.y)
        case EXPAND_TO_FILL
          noAction
        case SHRINK_TO_FIT
          noAction
        case PROPORTIONAL
          if (size_reference) h = size_reference.size.y * layout_size.y
          else                h = available_size.y * layout_size.y
        case FIXED_SIZE
          h = layout_size.y
        case NATURAL_SIZE
          h = natural_size.y
      endWhich
      return h

    method .resolve_layout_width( available_size:XY )->Real
      local w = available_size.x
      which (sizing_mode.x)
        case EXPAND_TO_FILL
          noAction
        case SHRINK_TO_FIT
          noAction
        case PROPORTIONAL
          if (size_reference) w = size_reference.size.x * layout_size.x
          else                w = available_size.x * layout_size.x
        case FIXED_SIZE
          w = layout_size.x
        case  NATURAL_SIZE
          w = natural_size.x
      endWhich
      return w


    method .resolve_shrink_to_fit_layout_size( &limited )->XY
      local sz = @size

      if (sizing_mode.x == SizingMode.SHRINK_TO_FIT or sizing_mode.y == SizingMode.SHRINK_TO_FIT)
        local min_size = minimum_layout_size( content_size, &=limited )
        min_size = content_size_to_layout_size( min_size )

        if (sizing_mode.x == SizingMode.SHRINK_TO_FIT)
          sz.x = min_size.x
          if (sizing_mode.y == SizingMode.ASPECT_FIT)
            local scale_x = (sz.x / (aspect_size.x || 1.0))
            sz.y = (aspect_size * scale_x).y
          endIf
        endIf

        if (sizing_mode.y == SizingMode.SHRINK_TO_FIT)
          sz.y = min_size.y
          if (sizing_mode.x == SizingMode.ASPECT_FIT)
            local scale_y = (sz.y / (aspect_size.y || 1.0))
            sz.x = (aspect_size * scale_y).x
          endIf
        endIf

        if (UI.snap_to_pixel_coordinates) sz .= floor
        size = sz
      endIf

      return sz

    method update_content_layout
      begin_layout( &only_children )
      .resolve_shrink_to_fit_layout_size
      resolve_child_layout_sizes( content_size )
      perform_child_layout
      end_layout( &only_children )

    method resolve_child_layout_sizes
      on_layout_size( size )
      resolve_child_layout_sizes( content_size )

    method resolve_child_layout_sizes( available_size:XY )
      use components = WorkList<<Component>>
        collect_child_display_components( components )
        (forEach in components).resolve_layout_size( available_size )
      endUse

    method set_anchor( @anchor )
      noAction

    method set_content( content:Component )
      remove_children
      add( content )

    method set_content_offset( new_content_offset:XY )
      if (content_offset != new_content_offset)
        @content_offset = new_content_offset
        request_redraw
      endIf

    method set_content_opacity( @content_opacity )

    method set_fixed_size( layout_size )
      sizing_mode = SizingModeXY( SizingMode.FIXED_SIZE, SizingMode.FIXED_SIZE )
      size = layout_size

    method set_fixed_height( h:Real )
      layout_size.y = h
      sizing_mode.y = SizingMode.FIXED_SIZE
      size.y = h

    method set_fixed_width( w:Real )
      layout_size.x = w
      sizing_mode.x = SizingMode.FIXED_SIZE
      size.x = w

    method set_natural_size( @natural_size )
      sizing_mode = SizingModeXY( SizingMode.NATURAL_SIZE, SizingMode.NATURAL_SIZE )
      size = natural_size

    method set_natural_height( h:Real )
      natural_size.y = h
      sizing_mode.y = SizingMode.NATURAL_SIZE
      size.y = h

    method set_natural_width( w:Real )
      natural_size.x = w
      sizing_mode.x = SizingMode.NATURAL_SIZE
      size.x = w

    method set_opacity( @opacity )

    method set_proportional_size( layout_size )
      sizing_mode = SizingModeXY( SizingMode.PROPORTIONAL, SizingMode.PROPORTIONAL )

    method set_proportional_size( size_reference, layout_size:XY )
      set_proportional_size( layout_size )

    method set_proportional_height( h:Real )
      layout_size.y = h
      sizing_mode.y = SizingMode.PROPORTIONAL

    method set_proportional_height( size_reference, h:Real )
      set_proportional_height( h )

    method set_proportional_width( w:Real )
      layout_size.x = w
      sizing_mode.x = SizingMode.PROPORTIONAL

    method set_proportional_width( size_reference, w:Real )
      set_proportional_width( w )

    method set_structure_modified( setting:Logical ) [override]
      prior.set_structure_modified( setting )
      if (setting) request_layout

    method set_weight( @weight )

    method set_weight( weight:Real )
      @weight = XY( weight, weight )

    method shrink_to_fit
      sizing_mode = SizingModeXY( SizingMode.SHRINK_TO_FIT, SizingMode.SHRINK_TO_FIT )

    method shrink_to_fit_height
      sizing_mode.y = SizingMode.SHRINK_TO_FIT

    method shrink_to_fit_width
      sizing_mode.x = SizingMode.SHRINK_TO_FIT

    method split_h( split_position:Real, components:Component[], component_i:Int )
      noAction

    method text_style->TextStyle
      if (@text_style) return @text_style
      return parent->(as Component)?.text_style

    method use_natural_size
      sizing_mode = SizingModeXY( SizingMode.NATURAL_SIZE, SizingMode.NATURAL_SIZE )
      size = natural_size

    method use_natural_height
      sizing_mode.y = SizingMode.NATURAL_SIZE
      size.y = natural_size.y

    method use_natural_width
      sizing_mode.x = SizingMode.NATURAL_SIZE
      size.x = natural_size.x

    method .dispatch_draw [override]
      if (count)
        localize content_display_bounds
        local new_clip = which{ UI.clip:UI.clip & content_display_bounds || content_display_bounds }
        if (UI.snap_to_pixel_coordinates) new_clip .= floor
        temporarily UI.clip = new_clip
          use components = WorkList<<Component>>
            # Draw descendent Components
            collect_child_display_components( components, &only_visible )
            (forEach in components).draw

            # Draw non-Component child entities
            forEach (child in children)
              if (child not instanceOf Component)
                child.draw
              endIf
            endForEach

          endUse
        endTemporarily
      endIf

endClass

class UIGeneratedStack : Component
  # Special subclass for operator overrides
  METHODS
    method operator|( rhs:Component )->Component [override]
      add( rhs )
      return this
endClass
