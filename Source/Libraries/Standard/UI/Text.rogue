library UI

class Text : Component
  PROPERTIES
    value        : String
    scaling_mode = ScalingModeXY( ScalingMode.NONE, ScalingMode.NONE )
    sizing_mode  = SizingModeXY( SizingMode.FIXED_SIZE, SizingMode.FIXED_SIZE )

  METHODS
    method init( text=String():String )
      if (text.count <= 1)
        value = text
        return
      endIf

      use processed = StringPool
        local iterator = text.iterator
        local prev = -1
        local has_eol = false
        loop
          if local ch = iterator.read_another
            if (ch == '\r') nextIteration
            if (ch == '\n')     has_eol = true
            elseIf (ch == '\t') ch = ' '
            if (ch == ' ')
              if (prev == ' ') nextIteration
            endIf
            processed.print( ch )
            prev = ch
          else
            escapeLoop
          endIf
        endLoop

        if (processed.count <= 1)
          value = processed.cloned
          return
        endIf

        local has_edge_spaces = processed[0] == ' ' or processed.last == ' '
        if (not has_edge_spaces and not has_eol)
          value = processed.cloned
          return
        endIf

        use builder = StringPool
          forEach (ch in processed)
            if (ch == '\n')
              .add_builder( builder )
              add( Text('\n') )
            elseIf (ch == ' ' and not builder.count)
              # Leading space becomes its own element
              add( Text(" ") )
            else
              builder.print ch
            endIf
          endForEach
          .add_builder( builder )
        endUse

      endUse

      begin_layout  # set initial size

    method .add_builder( builder:String )
      if (builder.count)
        if (builder.last == ' ')
          # Make a trailing space its own element
          builder.remove_last
          add( Text(builder.cloned) )
          add( Text(" ") )
        else
          add( Text(builder.cloned) )
        endIf
        builder.clear
      endIf

    method aspect_fit_text_to_size
      aspect_fit_text_to_width
      aspect_fit_text_to_height

    method aspect_fit_text_to_height
      scaling_mode.y = ScalingMode.ASPECT_FIT
      sizing_mode.y = SizingMode.EXPAND_TO_FILL

    method aspect_fit_text_to_width
      scaling_mode.x = ScalingMode.ASPECT_FIT
      sizing_mode.x = SizingMode.EXPAND_TO_FILL

    method bg_color->Graphics::Color? [override]
      return text_style?.bg_color || prior.bg_color

    method color->Graphics::Color? [override]
      return text_style?.color || prior.color

    method description->String
      local result = ''Text($)''(value?.to_escaped_ascii||"")
      if (count)
        result.print '['
        forEach (child at i in children)
          if (i > 0) result.print ','
          result.print child
        endForEach
        result.print ']'
      endIf
      return result

    method display_position->XY
      if (is_display_component) return prior.display_position
      else                      return parent->(as Component)?.display_position

    method find_h_split( max_width:Real )->Real? [override]
      local font = font
      assert font
      forEach (ch at i in value step -1)
        if (ch == ' ' or ch == '\n' or ch == '\r' or ch == '\t')
          if (i == 0) return null
          local w = font.measure( value, 0, i )
          if (w < max_width) return i
        endIf
      endForEach
      return null

    method fixed_height_text
      scaling_mode.y = ScalingMode.NONE
      sizing_mode.y = SizingMode.FIXED_SIZE

    method fixed_size_text
      fixed_width_text
      fixed_height_text

    method fixed_width_text
      scaling_mode.x = ScalingMode.NONE
      sizing_mode.x = SizingMode.FIXED_SIZE

    method font->Font
      if (text_style and text_style.font)
        return text_style.font.value
      else
        return prior.font
      endIf

    method is_br->Logical [override]
      return value == "\n"

    method is_space->Logical [override]
      return value == " "

    method is_display_component->Logical [override]
      forEach (child as Component in children)
        if (child.is_display_component) return false
      endForEach
      return true

    method line_height->Real
      if local font = font
        return font.height * font.line_spacing
      else
        return 0.0
      endIf

    method minimum_layout_size( available_size:XY, &limited )->XY [override]
      if local font = font
        return font.measure( value )
      else
        return XY.zero
      endIf

    method on_begin_layout [override]
      local font = font

      local sz = font?.measure(value || "")

      if (sizing_mode.x == SizingMode.FIXED_SIZE)
        if (sizing_mode.y == SizingMode.FIXED_SIZE)
          fixed_size =  font?.measure(value || "")
          size = layout_size
        else
          fixed_width =  font?.measure(value || "").x
          size.x = layout_size.x
        endIf
      elseIf (sizing_mode.y == SizingMode.FIXED_SIZE)
        fixed_height = font?.measure(value || "").y
        size.y = layout_size.y
      endIf

    method on_draw [override]
      if local font = font
        font.draw( this )
      else
        println "ERROR: UI.default_font is undefined."
      endIf

    method set_bg_color( color:Graphics::Color? )
      ensure<<text_style>>
      text_style.bg_color = color

    method set_color( color:Graphics::Color? )
      ensure<<text_style>>
      text_style.color = color

    method set_value( new_value:String )
      if (not new_value) new_value = ""
      if (new_value != @value)
        @value = new_value
        request_layout
      endIf

    method shrink_to_fit_text_to_size
      shrink_to_fit_text_to_width
      shrink_to_fit_text_to_height

    method shrink_to_fit_text_to_height
      scaling_mode.y = ScalingMode.SHRINK_TO_FIT
      sizing_mode.y = SizingMode.EXPAND_TO_FILL

    method shrink_to_fit_text_to_width
      scaling_mode.x = ScalingMode.SHRINK_TO_FIT
      sizing_mode.x = SizingMode.EXPAND_TO_FILL

    method split_h( split_position:Real, components:Component[], component_i:Int ) [override]
      local left, center, right : Text

      local split_i = split_position->Int
      if (split_i) left = Text( value.substring(0, split_i) )
      center = Text( value[split_i] )
      if (split_i + 1 < value.count) right = Text( value.substring(split_i+1) )

      if (left) add( left )
      add( center )
      if (right) add( right )

      components.remove_at( component_i )
      if (right) components.insert( right, component_i )
      components.insert( center, component_i )
      if (left) components.insert( left, component_i )

      # Have the new child components set their size
      left?.begin_layout
      center.begin_layout
      right?.begin_layout

    method to->String
      return description

endClass
