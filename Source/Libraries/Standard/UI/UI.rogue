library UI

uses Collection/Node
uses Control
uses Entity
uses Geometry

$include UI/AspectRatioLayoutSwitcher
$include UI/Border
$include UI/Component
$include UI/ComponentSizeInfo
$include UI/Event
$include UI/Font
$include UI/HBox
$include UI/HFlow
$include UI/Label
$include UI/LimitedSize
$include UI/MetaComponent
$include UI/Overlay
$include UI/ScalingMode
$include UI/SizingMode
$include UI/Text
$include UI/TextBox
$include UI/TextStyle
$include UI/VBox
$include UI/VList
$include UI/VScrollView
$include UI/Widget

class UI : Component [singleton]
  PROPERTIES
    default_font   : Font

    clip           : Box?

    pointer_focus  : Component
    keyboard_focus : Component

    parameters     : Variant

    needs_layout   = true
    needs_redraw   = true

    snap_to_pixel_coordinates = true

  METHODS
    method init_object
      UI = this

    method drag_threshold->Real
      return 16

    method draw [override]
      temporarily UI = this
        prior.draw
      endTemporarily

    method filler( &h, &v )->Component
      local component = Component().[ weight=0 ]
      if (h xor v)
        if (h) component.fixed_height = 0  # horizontal filler has fixed height 0
        else   component.fixed_width  = 0  # vice-versa
      endIf
      return component

    method font->Font
      if (@font) return @font
      return default_font

    method handle( e:KeyEvent )
      temporarily UI = this
        on( e )
        if (e.is_consumed) return

        if (keyboard_focus)
          if (not keyboard_focus.attributes.intangible)
            keyboard_focus.handle( e )
          else
            keyboard_focus.release_keyboard_focus
            first_child_component?.dispatch( e )
          endIf
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:PointerEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (pointer_focus)
          if (not pointer_focus.attributes.intangible)
            pointer_focus.handle( e )
          else
            pointer_focus.release_pointer_focus
            first_child_component?.dispatch( e )
          endIf
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:ScrollEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (pointer_focus)
          pointer_focus.handle( e )
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:TextEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (keyboard_focus)
          keyboard_focus.handle( e )
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method set_clip( @clip )
      noAction

    method spacer( fixed_size:XY, content=null:Component )->Component
      local result = Component()
      if (content) result.add( content )
      result.fixed_size = fixed_size
      return result

    method spacer( content=null:Component, &h, &v )->Component [preferred]
      local component = Component()
      if (content) component.add( content )
      if (h xor v)
        if (h) component.fixed_height = 0  # horizontal spacer has fixed height 0
        else   component.fixed_width  = 0  # vice-versa
      endIf
      return component

    method spacer( content=null:Component, w=null:Real?, h=null:Real? )->Component
      local component = Component()
      if (content) component.add( content )
      if (w) component.fixed_width = w.value
      if (h) component.fixed_height = h.value
      return component

    method update( bounds:Box )
      temporarily UI = this
        update_layout( bounds )
        update
      endTemporarily

    method update_layout( bounds:Box )
      temporarily UI = this
        position = bounds.position
        if (needs_layout or bounds.size != size)
          loop 2
            #if (needs_layout)
            needs_layout = false
            needs_redraw = true
            #endIf
            begin_layout
            resolve_layout_size( bounds.size )
            perform_layout( position )
            end_layout

            if (not needs_layout) escapeLoop
          endLoop
        endIf
      endTemporarily

endClass
