library UI

uses Collection/Node
uses Control
uses Entity
uses Geometry

$include UI/AspectRatioLayoutSwitcher
$include UI/Border
$include UI/Component
$include UI/ComponentSizeInfo
$include UI/Event
$include UI/Focus
$include UI/Font
$include UI/HBox
$include UI/HFlow
$include UI/Label
$include UI/LimitedSize
$include UI/MetaComponent
$include UI/Overlay
$include UI/ScalingMode
$include UI/SizingMode
$include UI/Text
$include UI/TextBox
$include UI/TextStyle
$include UI/VBox
$include UI/VList
$include UI/VScrollView
$include UI/Widget

class UI : Component [singleton]
  GLOBAL PROPERTIES
    shared_focus = Focus()

  PROPERTIES
    default_font   : Font
    clip           : Box?
    focus          = shared_focus : Focus

    parameters     : Variant

    needs_layout   = true
    needs_redraw   = true

    snap_to_pixel_coordinates = true

  METHODS
    method init_object
      UI = this

    method container( content:Component, on_begin_layout=null:Function(Component), &h, &v )->Component [preferred]
      local container = spacer( &=h, &=v, &=on_begin_layout )
      container.add( content )
      return container

    method container( content:Component, w=null:Real?, h=null:Real?, on_begin_layout=null:Function(Component) )->Component
      local container = spacer( &=w, &=h )
      if (on_begin_layout) container.on_begin_layout( on_begin_layout )
      container.add( content )
      return container

    method drag_threshold->Real
      return 16

    method draw [override]
      temporarily UI = this
        prior.draw
      endTemporarily

    method filler( &h, &v )->Component
      local component = Component().[ weight=0.0 ]
      if (h xor v)
        if (h) component.fixed_height = 0  # horizontal filler has fixed height 0
        else   component.fixed_width  = 0  # vice-versa
      endIf
      return component

    method font->Font
      if (@font) return @font
      return default_font

    method handle( e:KeyEvent )
      temporarily UI = this
        on( e )
        if (e.is_consumed) return

        if (focus.keyboard)
          if (not focus.keyboard.attributes.intangible)
            focus.keyboard.handle( e )
          else
            focus.keyboard.release_keyboard_focus
            first_child_component?.dispatch( e )
          endIf
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:PointerEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (focus.pointer)
          if (not focus.pointer.attributes.intangible)
            focus.pointer.handle( e )
          else
            focus.pointer.release_pointer_focus
            first_child_component?.dispatch( e )
          endIf
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:ScrollEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (focus.pointer)
          focus.pointer.handle( e )
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method handle( e:TextEvent )
      temporarily UI = this
        UI = this

        on( e )
        if (e.is_consumed) return

        if (focus.keyboard)
          focus.keyboard.handle( e )
        else
          first_child_component?.dispatch( e )
        endIf
        if (e.is_consumed) return

        on_unhandled( e )
      endTemporarily

    method release_keyboard_focus [override]
      if (focus.keyboard)
        if (focus.keyboard is this)
          focus.keyboard = null
          on_release_keyboard_focus
        else
          focus.keyboard.release_keyboard_focus
        endIf
      endIf

    method release_pointer_focus [override]
      if (focus.pointer)
        if (focus.pointer is this)
          focus.pointer = null
          on_release_pointer_focus
        else
          focus.pointer.release_pointer_focus
        endIf
      endIf

    method set_clip( @clip )
      noAction

    method spacer( fixed_size:XY )->Component
      return Component().[ fixed_size=fixed_size ]

    method spacer( on_begin_layout=null:Function(Component), &h, &v )->Component [preferred]
      local component = Component()
      if (h xor v)
        if (h) component.fixed_height = 0  # horizontal spacer has fixed height 0
        else   component.fixed_width  = 0  # vice-versa
      endIf
      if (on_begin_layout) component.on_begin_layout( on_begin_layout )
      return component

    method spacer( w=null:Real?, h=null:Real? )->Component
      local component = Component()
      if (w) component.fixed_width = w.value
      if (h) component.fixed_height = h.value
      return component

    method update( bounds:Box )
      temporarily UI = this
        # ensure we've got a layout before the first update()
        update_layout( bounds )

        update

        # each update() may change things; call update_layout() a second time.
        # O(1) if update() did not set needs_layout flag.
        update_layout( bounds )
      endTemporarily

    method update_layout( bounds:Box )
      temporarily UI = this
        position = bounds.position
        if (needs_layout or bounds.size != size)
          needs_layout = false
          needs_redraw = true
          begin_layout
          resolve_layout_size( bounds.size )
          perform_layout( position )
          end_layout
        endIf
      endTemporarily

endClass
