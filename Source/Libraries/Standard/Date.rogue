#==============================================================================
# Date.rogue
#
# Represents a year/month/day date.
# Note: does not represent a date+time as Java/JS Date does.
#
# EXAMPLE
#   local today = Date.today
#   println "It's $ in the programming world" (today)
#   println "It's $ in the US" (today->String(&verbose))
#   println "and $ in Europe" (today->String("d month yyyy"))
#
#   local birthday = Date.ymd( 1973, 1, 27 )
#   local days = today - birthday
#   println "It's been $ days since my birthday" (days)
#   println "$ + $ days = $" (birthday,days,birthday+days)
#   println "$ - $ days = $" (today,days,today-days)
#
#   println "Yesterday was " + today.decremented
#   println "Tomorrow will be " + today.incremented
#
#   @trace today.year
#   @trace today.month
#   @trace today.day
#   @trace today.day_name
#   @trace today.day_of_week
#   @trace today.day_of_year
#   @trace today.days_in_month
#   @trace today.days_in_year
#
#   # Example output
#   It's 2020.03.15 in the programming world
#   It's March 15, 2020 in the US
#   and 15 March 2020 in Europe
#   It's been 17214 days since my birthday
#   1973.01.27 + 17214 days = 2020.03.15
#   2020.03.15 - 17214 days = 1973.01.27
#   Yesterday was 2020.03.14
#   Tomorrow will be 2020.03.16
#   today.year:2020
#   today.month:3
#   today.day:15
#   today.day_name:Sunday
#   today.day_of_week:0
#   today.day_of_year:74
#   today.days_in_month:31
#   today.days_in_year:366
#
# HISTORY
#   2020.03.15 - Created by Abe Pralle
#==============================================================================

class Date( year:Int32, month:Int32, day:Int32 ) [compound]
  # Uses algorithms from:
  #   http://www.herongyang.com/year/Program-Gregorian-Calendar-Algorithm.html
  #
  # January 1, 2000 is stored as year=2000, month=1, day=1
  ENUMERATE
    JANUARY   = 1
    FEBRUARY  = 2
    MARCH     = 3
    APRIL     = 4
    MAY       = 5
    JUNE      = 6
    JULY      = 7
    AUGUST    = 8
    SEPTEMBER = 9
    OCTOBER   = 10
    NOVEMBER  = 11
    DECEMBER  = 12

    SUNDAY    = 0
    MONDAY    = 1
    TUESDAY   = 2
    WEDNESDAY = 3
    THURSDAY  = 4
    FRIDAY    = 5
    SATURDAY  = 6

  GLOBAL METHODS
    method create( date:String )->Date
      local parts = String[]

      if (date.extract_strings("$(I).$(I).$(I)",parts) or
          date.extract_strings("$(I)/$(I)/$(I)",parts) or
          date.extract_strings("$(I)-$(I)-$(I)",parts))
        # 2018.10.27, 2018-10-27, 2018/10/27
        local a  = parts[0]->Int32
        local b  = parts[1]->Int32
        local c  = parts[2]->Int32
        local y, m, d : Int32
        if (a >= 100)
          # YYYY-MM-DD
          y = a
          m = b
          d = c
        elseIf (c >= 100)
          # MM-DD-YYYY
          m = a
          d = b
          y = c
        else
          # MM-DD-YY
          m = a
          d = b
          y = 2000 + c
        endIf
        return Date.ymd( y, m, d )

      elseIf (date.extract_strings("$ $(I), $(I)",parts) or
          date.extract_strings("$ $(I) $(I)",parts))
        # August 29, 2019
        # August 29 2019
        # Aug 29 2019
        local m  = month_name_to_index( parts[0]->String )
        local d  = parts[1]->Int32
        local y  = parts[2]->Int32
        return Date.ymd( y, m, d )

      elseIf (date.extract_strings("$(I) $, $(I)",parts) or
          date.extract_strings("$(I) $ $(I)",parts))
        # 29 August, 2019
        # 29 August 2019
        local d  = parts[0]->Int32
        local m  = month_name_to_index( parts[1]->String )
        local y  = parts[2]->Int32
        return Date.ymd( y, m, d )

      else
        throw SyntaxError( "Unsupported date format: " + date )
      endIf

    method day_of_year( year:Int32, month:Int32, day:Int32 )->Int32
      local n = 0
      forEach (m in 1..<month) n += days_in_month( year, m )
      n += day
      return n

    method days_in_month( year:Int32, month:Int32 )->Int32
      local n = standard_days_in_month[ month-1 ]
      if (month==2 and is_leap_year(year)) return n + 1
      return n

    method days_in_year( year:Int32 )->Int32
      local n = 0
      n += days_in_month( year, (forEach in 1..12) )
      return n

    method is_leap_year( year:Int32 )->Logical
      if (year % 400 == 0) return true
      if (year % 100 == 0) return false
      if (year %   4 == 0) return true
      return false

    method mdy( month:Int32, day:Int32, year:Int32 )->Date
      if (year < 100) year += (Timestamp.now->Date.year / 100) * 100
      return Date( year, month, day )

    method month_name_to_index( month_name:String )->Int32
      #January->1, December->12
      # Accepts partial month names e.g. "Jan"
      if (month_name.count >= 3)
        local ch0 = month_name[0].to_lowercase
        local ch1 = month_name[1].to_lowercase
        local ch2 = month_name[2].to_lowercase
        which (ch0)
          case 'j'
            if (ch1 == 'a') return JANUARY
            which (ch2)
              case 'n': return JUNE
              case 'l': return JULY
            endWhich
          case 'f': return FEBRUARY
          case 'm'
            which (ch2)
              case 'r': return MARCH
              case 'y': return MAY
            endWhich
          case 'a'
            which (ch1)
              case 'p': return APRIL
              case 'u': return AUGUST
            endWhich
          case 's': return SEPTEMBER
          case 'o': return OCTOBER
          case 'n': return NOVEMBER
          case 'd': return DECEMBER
        endWhich
      endIf
      throw SyntaxError( "Invalid month name: " + month_name )

    method today->Date
      return Timestamp.now->Date

    method ymd( year:Int32, month:Int32, day:Int32 )->Date
      if (year < 100) year += (Timestamp.now->Date.year / 100) * 100
      return Date( year, month, day )

  GLOBAL PROPERTIES
    month_names = [ "January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December" ]

    day_names = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ]

    standard_days_in_month = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ]

  METHODS
    method day_of_week->Int32
      # Returns a value 0..6
      local d = 0                    # 0001.01.01 is Monday, so base is Sunday
      local y = year
      y = (y-1) % 400 + 1            # Gregorian calendar cycle is 400 years
      local ly = (y-1)/4             # Leap years passed
      ly = ly - (y - 1) / 100
      ly = ly + (y - 1) / 400
      local ry = y - 1 - ly          # Regular years passed
      d = d + ry                     # Regular year has one extra week day
      d = d + 2 * ly                 # Leap year has two extra week days
      d = d + day_of_year(y,month,day)
      return d % 7

    method day_of_year->Int32
      # Returns a day 0..364/365
      local n = 0
      forEach (m in 1..<month) n += days_in_month( year, m )
      n += (day - 1)
      return n

    method days_in_year->Int32
      return days_in_year( year )

    method day_name->String
      return day_names[ day_of_week ]

    method days_in_month->Int32
      return days_in_month( year, month )

    method decremented->Date
      local y = year
      local m = month
      local d = day - 1
      if (d <= 0)
        --m
        if (m <= 0) return Date.ymd( y-1, 12, 31 )
        else        return Date.ymd( y, m, days_in_month(y,m) )
      else
        return Date.ymd( y, m, d )
      endIf

    method hash_code->Int32
      return (year * 10000 + month*100 + day)

    method incremented->Date
      local y = year
      local m = month
      local d = day + 1
      if (d > days_in_month)
        ++m
        if (m >= 13) return Date.ymd( y+1, 1, 1 )
        else         return Date.ymd( y, m, 1 )
      else
        return Date.ymd( y, m, d )
      endIf

    method month_name->String
      return month_names[ month.clamped(1,month_names.count) - 1 ]

    method operator+( days:Int32 )->Date
      if (days < 0) return this - (-days)
      local date = this

      # Add years at a time
      local next_year = Date( date.year+1, 1, 1 )
      local remaining_in_year = next_year - date
      while (days > 0 and days >= remaining_in_year)
          days -= remaining_in_year
          date = next_year
          remaining_in_year = date.days_in_year
          next_year = Date( date.year+1, 1, 1 )
      endWhile

      # Add months at a time
      local days_to_next_month = (date.days_in_month - date.day) + 1
      while (days > 0 and days >= days_to_next_month)
        days -= days_to_next_month
        if (date.month == 12) date = Date( date.year+1, 1, 1 )
        else                  date = Date( date.year, date.month+1, 1 )
        days_to_next_month = date.days_in_month
      endWhile

      # Add days at a time
      loop (days) date = date.incremented

      return date

    method operator-( days:Int32 )->Date
      if (days < 0) return this + (-days)
      local date = this
      local delta = date.day_of_year + 1

      # Subtract years at a time
      while (days > 0 and days >= delta)
          days -= delta
          date = Date( date.year-1, 12, 31 )
          delta = date.days_in_year
      endWhile

      # Subtract months at a time
      delta = date.day
      while (days > 0 and days >= delta)
        days -= delta
        if (date.month == 1)
          date = Date( date.year-1, 12, 31 )
          delta = 31
        else
          delta = days_in_month( date.year, date.month-1 )
          date = Date( date.year, date.month-1, delta )
        endIf
      endWhile

      # Subtract days at a time
      loop (days) date = date.decremented

      return date

    method operator-( other:Date )->Int32
      # Returns the number of days between the two dates
      local a = this
      local b = other
      if (a > b) swapValues(a,b)

      local diff = 0
      while (a.year < b.year)
        diff += a.days_in_year - a.day_of_year
        a = Date( a.year+1, 1, 1 )
      endWhile

      return diff + (b.day_of_year - a.day_of_year)

    method operator<( other:Date )->Logical
      return (hash_code < other.hash_code)

    method operator==( other:Date )->Logical
      return (hash_code == other.hash_code)
      # For Dates the hash code contains all necessary info so we can use it to compare safely

    method to->String
      return "$.$.$" (year,month.format("02"),day.format("02"))

    method to->String( format="yyyy.mm.dd":String, &verbose )
      # Format:
      #   yyyy  - 4-digit year
      #   yy    - 2-digit year
      #   mm    - Month with leading 0 if necessary
      #   m     - Month without any leading 0
      #   month - Month name spelled out
      #   mon   - 3-letter month name
      #   dd    - Day with leading 0 if necessary
      #   d     - Day without any leading 0
      if (verbose)
        # Standard American
        return "$ $, $" (month_name, day, year)
      endIf

      format = format.to_lowercase
      if (format.contains("yyyy"))  format = format.replacing("yyyy",year.format("04"))
      if (format.contains("yy"))    format = format.replacing("yy",(year%100).format("02"))
      if (format.contains("mm"))    format = format.replacing("mm",month.format("02"))
      if (format.contains("month")) format = format.replacing("month",month_name)
      if (format.contains("mon"))   format = format.replacing("mon",month_name.leftmost(3))
      if (format.contains("m"))     format = format.replacing("m",month->String)
      if (format.contains("dd"))    format = format.replacing("dd",day.format("02"))
      if (format.contains("d"))     format = format.replacing("d",day->String)

      return format

endClass
