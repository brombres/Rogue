$[include "Op.bard"]
$[include "CmdQuery.bard"]

class Cmd
  PROPERTIES
    t        : Token
    resolved : Logical

  METHODS
    method init( t )

    method clone->Cmd
      throw t.error( "clone() not defined for $." (type_name) )

    method clone( cmd:Cmd )->Cmd
      if (cmd is null) return null
      return cmd.clone

    method clone( args:CmdArgs )->CmdArgs
      if (args is null) return null
      return args.clone

    method clone( statements:CmdStatementList )->CmdStatementList
      if (statements is null) return null
      return statements.clone

    method dispatch( v:Visitor )->Cmd [propagated]
      return v.visit( this )

    method error( message:String )->BardError
      return t.error( message )

    method has_side_effects->Logical
      return false

    method contains_asynchronous_control->Logical
      return false

    method implicit_type->Type
      return null

    method is_complex_reference->Logical
      # Used to determine whether or not the context of a property op+assign should
      # be first stored into a separate local variable.
      return false

    method type->Type
      return null

    method instance_of( ancestor:Type)->Logical
      return type.instance_of( ancestor )

    method variable_name->String
      return null

    method print( buffer:StringBuilder )
      throw t.error( "print(StringBuilder) not defined for " + type_name + "." )

    method resolve->Cmd
      throw t.error( "resolve() not defined for " + type_name + "." )

    method resolve_with_type_hint( as_type:Type)->Cmd
      return resolve  # ignore the type hint by default

    method resolve_increment->Cmd
      throw error( "Cannot increment given value.  Target must be a local variable or a property." )

    method resolve_decrement->Cmd
      throw error( "Cannot decrement given value.  Target must be a local variable or a property." )

    method resolve_assignment( new_value:Cmd )->Cmd
      throw t.error( "Invalid target for assignment." )

    method to->String
      local buffer = StringBuilder()
      print( buffer )
      return buffer->String

    method require_logical->Cmd
      if (type? and type.is_Logical) return this
      throw t.error( "Logical true or false value expected." )

    method require_value->Cmd
      if (type is null)
        #trace StackTrace()
        troff
        throw t.error( "Value expected." )
      endIf
      return this

    method require_integer->Cmd
      if (type is null or type isNot Types.type_Integer)
        throw t.error( "Integer value expected." )
      endIf
      return this

      #{
    method require_value( allow_unchecked:Logical )->Cmd
      local _type = type
      if (type is null) throw t.error( "Value expected." )
      #if (type.possibly_null and not allow_unchecked)
      #throw t.error( "Null-checked value required." )
      #endIf
      return this
      }#

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (type is to_type) return this
      local result = CmdImplicitCastToType( cast_t, this, to_type )
      return result

    method common_type( lhs:Cmd, rhs:Cmd )->Type
      return common_type( lhs.type, rhs.type )

    method common_type( lhs_type:Type, rhs_type:Type )->Type
      if (lhs_type is rhs_type and not lhs_type.is_Character)
        #if (lhs_type is rhs_type)
        return lhs_type
      endIf

      if (lhs_type.is_primitive and rhs_type.is_primitive)
        if (lhs_type.is_Logical or rhs_type.is_Logical)
          throw t.error( "Invalid mix of and:Logical non-types:Logical." )
        endIf
        if (lhs_type.is_Real or rhs_type.is_Real) return Types.type_Real

        return Types.type_Integer
      else
        #{
        if (lhs_type is rhs_type def)
          # Mix of checked and unchecked values
          return lhs_type.unchecked_type
        endIf
        }#
        if (lhs_type.instance_of(rhs_type)) return rhs_type
        if (rhs_type.instance_of(lhs_type)) return lhs_type
        return Types.type_Object
      endIf
endClass

class CmdStatementList : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      add( statement1 ).add( statement2 )

    method has_side_effects->Logical
      forEach (cmd in this)
        if (cmd.has_side_effects) return true
      endForEach
      return false

    method clone->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this) result.add( cmd.clone )
      return result

    method dispatch( v:Visitor ) [propagated]
      v.visit( this )

    method print( buffer:StringBuilder )
      Analyzer.context.push_local_scope
      forEach (statement in this)
        buffer.print( "      " )
        buffer.print( statement.type_name )
        buffer.print( " " )
        statement.print( buffer )
        buffer.println
      endForEach
      Analyzer.context.pop_local_scope


    method resolve
      Analyzer.context.push_local_scope
      forEach (i in this.indices)
        this[i] = this[i].resolve
      endForEach
      Analyzer.context.pop_local_scope

endClass

class CmdArgs : CmdStatementList
  METHODS
    method clone->CmdArgs
      local result = CmdArgs( count )
      forEach (cmd in this) result.add( cmd.clone )
      return result

    method resolve
      forEach (i in this.indices)
        this[i] = this[i].resolve.require_value
      endForEach

    method print( buffer:StringBuilder )
      local first = true
      forEach (arg in this)
        if (first) first = false
        else       buffer.print(',')
        arg.print( buffer )
      endForEach

endClass

class CmdLiteral : Cmd
  METHODS
    method implicit_type->Type
      return type

    method resolve->Cmd
      return this

endClass

class CmdLiteralReal : CmdLiteral
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method clone->CmdLiteralReal
      return CmdLiteralReal( t, value )

    method type->Type
      return Types.type_Real

    method to->String
      return ""+value

    method print( buffer:StringBuilder )
      buffer.print( value )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Real) return this

      if (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Real )

      elseIf (to_type.is_Character)
        throw t.error( //Invalid conversion from Real to Character.// )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from Real to Logical.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

        #{
      elseIf (to_type is Types.type_Object)
        return CmdBoxReal( t, value )
        }#

      else
        throw t.error( //Invalid conversion from Real to $.// (to_type) )
      endIf

endClass

class CmdLiteralInteger : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )

    method clone->CmdLiteralInteger
      return CmdLiteralInteger( t, value )

    method type->Type
      return Types.type_Integer

    method to->String
      return "" + value

    method print( buffer:StringBuilder )
      buffer.print( value )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Integer) return this

      if (to_type.is_Real)
        return CmdLiteralReal( t, value )

      elseIf (to_type.is_Character)
        return CmdLiteralCharacter( t, value->Character )

      elseIf (to_type.is_Byte)
        return CmdLiteralByte( t, (value&255)->Byte )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from to:Logical:Integer.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      #elseIf (to_type.def is TypeDefs.type_IntegerObject or to_type.is_Object)
        #return CmdAccess( t, "IntegerObject", CmdArgs(this) ).resolve

      else
        throw t.error( "Invalid cast from Integer to " + to_type.name + "." )
      endIf

endClass

class CmdLiteralCharacter : CmdLiteral
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method clone->CmdLiteralCharacter
      return CmdLiteralCharacter( t, value )

    method type->Type
      return Types.type_Character

    method to->String
      if (value == '\'' or value == '\\') return "\\" + value
      if (value == '\n') return "\\n"
      if (value < 32 or (value > 126 and value <= 255)) return "\\" + value->Integer.to_hex_string(2)
      if (value >= 256) return "\\u" + value->Integer.to_hex_string(4)
      return ""+value

    method print( buffer:StringBuilder )
      buffer.print( '\'' )
      buffer.print( this->String )
      buffer.print( '\'' )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
# print(cast_t)
# println(to_type)
      if (to_type.is_Character) return this

      if (to_type.is_Real)
        throw t.error( //Invalid conversion from to:Character Real.// )

      elseIf (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Integer)

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from to:Character Logical.  Use "ch?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      else
        throw t.error( //Invalid conversion from Character to $.// (to_type) )
      endIf

endClass

class CmdLiteralByte : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )
      value &= 255

    method clone->CmdLiteralByte
      return CmdLiteralByte( t, value )

    method type->Type
      return Types.type_Byte

    method to->String
      return "" + value

    method print( buffer:StringBuilder )
      buffer.print( "Byte(" )
      buffer.print( value )
      buffer.print( ")" )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Byte) return this

      if (to_type.is_Real)
        return CmdLiteralReal( t, value )

      elseIf (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Integer )

      elseIf (to_type.is_Character)
        return CmdLiteralCharacter( t, value->Character )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from Byte to Logical.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      #elseIf (to_type.def is TypeDefs.type_IntegerObject or to_type.is_Object)
        #return CmdAccess( t, "IntegerObject", CmdArgs(this) ).resolve

      else
        throw t.error( "Invalid cast from Byte to " + to_type.name + "." )
      endIf

endClass

class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method clone->CmdLiteralLogical
      return CmdLiteralLogical( t, value )

    method type->Type
      return Types.type_Logical

    method to->String
      if (value) return "true"
      else       return "false"

    method print( buffer:StringBuilder )
      buffer.print( this->String )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Logical) return this

      if (to_type.is_Real)
        throw t.error( //Invalid conversion from to:Logical Real.// )

      elseIf (to_type.is_Integer)
        return CmdConvertLogicalToInteger( t, this )

      elseIf (to_type.is_Character)
        throw t.error( //Invalid conversion from to:Logical Character.// )

      elseIf (to_type.is_String)
        if (value) return CmdLiteralString( t, "true" )
        else       return CmdLiteralString( t, "false" )

      else
        throw t.error( //Invalid conversion from Logical to $.// (to_type) )
      endIf

endClass

class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method clone->CmdLiteralString
      return CmdLiteralString( t, value )

    method type->Type
      return Types.type_String

    method to->String
      return value

    method print( buffer:StringBuilder )
      #buffer.print( //"$"// (value) )
      buffer.print( //"// + value + //"// )

endClass

class CmdLiteralNull : CmdLiteral
  PROPERTIES
    of_type : Type

  METHODS
    method init( t )
      init( t, Types.type_Object )

    method init( t, of_type )

    method clone->CmdLiteralNull
      return CmdLiteralNull( t, of_type )

    method type->Type
      return of_type

    method instance_of( ancestor:Type)->Logical
      return ancestor.is_reference

    method to->String
      return "null"

    method print( buffer:StringBuilder )
      buffer.print( "null" )

    #method require_value( allow_unchecked:Logical ).Cmd
    method require_value->Cmd
      local _type = type
      if (type is null) throw t.error( "Value expected." )
      #if (not allow_unchecked)
      #throw t.error( "Non-null value required for method with a null-checked return type." )
      #endIf
      return this

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      of_type.resolve(t)
      return this

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_reference)
        of_type = to_type
      else
        #throw cast_t.error( "Cannot cast a null reference to type $." (to_type) )
        throw cast_t.error( "Cannot cast a null reference to type " + to_type.name + "." )
      endIf
      return this


endClass

class CmdLiteralList : CmdLiteral
  PROPERTIES
    args : CmdArgs

  METHODS
    method init( t )
      args = CmdArgs()

    method init( t, args )

    method clone->CmdLiteralList
      return CmdLiteralList( t, args.clone )

    method has_side_effects->Logical
      return (args.has_side_effects)

    method implicit_type->Type
      local common_type : Type

      forEach (arg in args)
        local arg_type = arg.implicit_type
        if (arg_type is null) return Types.reference(t,"PropertyList")

        if (common_type?)
          if (common_type isNot arg_type)
            return Types.reference(t,"PropertyList")
          endIf
        else
          common_type = arg_type
        endIf
      endForEach

      if (common_type is null) return Types.reference(t,"PropertyList")

      return Types.reference( t, common_type.name + "[]" ).resolve(t)

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print('[')
      local first = true
      forEach (arg in args)
        if (first) first = false
        else       buffer.print(',')
        arg.print( buffer )
      endForEach
      buffer.print(']')

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      local common_type : Type

      forEach (index in args.indices)
        local arg = args[index].resolve.require_value
        args[index] = arg

        local arg_type = arg.type

        if (common_type?)
          if (common_type isNot arg_type)
            return construct_property_list
          endIf
        else
          common_type = arg_type
        endIf
      endForEach

      if (common_type is null) return construct_property_list

      local all_literals = true
      forEach (index in args.indices)
        local arg = args[index]
        args[index] = arg.cast_to( arg.t, common_type )
        if (arg notInstanceOf CmdLiteral) all_literals = false
      endForEach

      if (common_type.is_Integer)
        return CmdNewObject( t, Types.reference(t,"Integer[]"), CmdArgs( CmdLiteralArray(t, "Integer", args, all_literals) ) ).resolve

      elseIf (common_type.is_Real)
        return CmdNewObject( t, Types.reference(t,"Real[]"), CmdArgs( CmdLiteralArray(t, "Real", args, all_literals) ) ).resolve

      elseIf (common_type.is_reference)
        return CmdNewObject( t, Types.reference(t,common_type.name+"[]"), CmdArgs( CmdLiteralArray(t, common_type.name, args, all_literals) ) ).resolve

      elseIf (common_type.is_Character)
        return CmdNewObject( t, Types.reference(t,"Character[]"),
          CmdArgs( CmdLiteralArray(t, "Character", args, all_literals) ) ).resolve

      elseIf (common_type.is_Logical)
        return CmdNewObject( t, Types.reference(t,"Logical[]"),
          CmdArgs( CmdLiteralArray(t, "Logical", args, all_literals) ) ).resolve

      endIf

      throw t.error( "TODO: CmdLiteralList of type " + common_type )

    method construct_property_list->Cmd
      local cmd : Cmd
      cmd = CmdNewObject( t, Types.reference(t,"PropertyList") )

      forEach (arg in args)
        cmd = CmdAccess( arg.t, cmd, "add", CmdArgs(arg) )
      endForEach

      return cmd.resolve
endClass


class CmdLiteralArray : Cmd
  PROPERTIES
    array_type   : Type
    element_type : Type
    elements     : CmdArgs
    all_literals : Logical

  METHODS
    method init( t, element_name:String, elements, all_literals )
      element_type = Types.reference( t, element_name )
      array_type = Types.reference( t, "Array<<" + element_name + ">>" )

    method init( t, array_type, element_type, elements, all_literals )

    method clone->CmdLiteralArray
      return CmdLiteralArray( t, array_type, element_type, elements, all_literals )

    method has_side_effects->Logical
      if (elements? and elements.has_side_effects) return true
      return false

    method implicit_type->Type
      return array_type

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( array_type )
      buffer.print( "[" )
      local first = true
      forEach (element in elements)
        if (first) first = false
        else       buffer.print(',')
        element.print( buffer )
      endForEach
      buffer.print( "]" )

    method type->Type
      return array_type

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      array_type.resolve
      element_type.resolve
      elements.resolve
      return this
endClass


class CmdLiteralTable : Cmd
  PROPERTIES
    keys   = CmdArgs()
    values = CmdArgs()

  METHODS
    method init( t )
      if (Types.type_PropertyTable is null)
        Types.type_PropertyTable = Types.reference( t, "PropertyTable" )
        Types.type_PropertyList = Types.reference( t, "PropertyList" )
      endIf

    method clone->CmdLiteralTable
      local result = CmdLiteralTable(t)
      result.keys   = clone( keys )
      result.values = clone( values )
      return result

    method has_side_effects->Logical
      return (keys.has_side_effects or values.has_side_effects)

    method implicit_type->Type
      return Types.type_PropertyTable

    method type->Type
      return Types.type_PropertyTable

    method print( buffer:StringBuilder )
      buffer.print( '{' )
      local first = true
      forEach (i of keys)
        if (first) first = false
        else       buffer.print(',')
        keys[i].print( buffer )
        buffer.print( ':' )
        values[i].print( buffer )
      endForEach
      buffer.print( '}' )

    method resolve->Cmd
      local table : Cmd
      table = CmdNewObject( t, Types.type_PropertyTable )
      forEach (i of keys)
        local key = keys[i].resolve.require_value
        local value = values[i].resolve.require_value

        if (not key.type.is_String) throw key.error( "Only strings can be used as property table keys." )

        table = CmdAccess( t, table, "put", CmdArgs(key,value) )
      endForEach
      table = table.resolve.require_value
      return table
      #return table.resolve.require_value
endClass


class CmdLiteralTableKey : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method clone->CmdLiteralTableKey
      return CmdLiteralTableKey( t, name )

    method has_side_effects->Logical
      return false

    method implicit_type->Type
      return Types.type_String

    method type->Type
      return Types.type_String

    method print( buffer:StringBuilder )
      buffer.print( name )

    method resolve->Cmd
      local this_type = Analyzer.context.this_type
      if (Analyzer.context.find_local(name)? or 
          this_type.find_property(name)? or
          this_type.find_setting(name)? or
          this_type.find_method(name,0)?)
        return CmdAccess( t, name ).resolve
      endIf
      return CmdLiteralString( t, name )
endClass


class CmdFormattedString( t, format:String, args:CmdArgs ) : Cmd
  METHODS
    method clone->CmdFormattedString
      return CmdFormattedString( t, format, args.clone )

    method print( buffer:StringBuilder )
      buffer.print( "CmdFormattedString(" )
      args.print( buffer )
      buffer.print( ")" )

    method has_side_effects->Logical
      forEach (arg in args)
        if (arg.has_side_effects) return true
      endForEach
      return false

    method implicit_type->Type
      return Types.type_String

    method type->Type
      return Types.type_String

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (args.count == 0) return CmdLiteralString( t, format )

      local builder = CmdNewObject( t, Types.type_StringBuilder ) : Cmd

      local remaining = format
      forEach (arg in args)
        local i1 = find_marker_start( remaining )
        if (i1 == -1) throw arg.t.error( "More arguments than format markers in formatted string." )
        local i2 = find_marker_end( remaining, i1 )

        arg = arg.resolve.require_value
        if (arg.type.is_compound) arg = CmdConvertToType( arg.t, arg, Types.type_String )

        if (i1 > 0)
          if (i1 > 1) builder = CmdAccess( t, builder, "print", CmdArgs(CmdLiteralString(t,remaining.leftmost(i1))) )
          else        builder = CmdAccess( t, builder, "print", CmdArgs(CmdLiteralCharacter(t,remaining[0])) )
        endIf

        if (i1 == i2 or i2 == i1+2)
          # '$' or "$()" - Default format
          builder = CmdAccess( t, builder, "print", CmdArgs(arg) )
          remaining = remaining.substring(i2+1)

        else
          # One of:
          #   $(N)
          #   $(N.D)
          #   $(0N)
          #   $(0N.D)
          builder = CmdAccess( t, builder, "mark", null )
          local options = remaining.substring(i1+2,i2-1)
          local zero_fill_option = false
          local left_justify = false
          local whole_digits = 1
          local decimal_digits = -1
          if (options.begins_with('0'))
            zero_fill_option = true
            options = options.substring(1)
          endIf
          local decimal_position = options.locate('.')
          if (decimal_position >= 0)
            local decimal_st = options.substring( decimal_position + 1 )
            options = options.leftmost( decimal_position )
            if (decimal_st.count?) decimal_digits = decimal_st->Integer
            else                   decimal_digits = 4
            arg = arg.cast_to( arg.t, Types.type_Real )
          endIf
          if (options.count?)
            whole_digits = options->Integer
          endIf

          local print_args = CmdArgs( arg )
          if (decimal_digits >= 0) print_args.add( CmdLiteralInteger(arg.t,decimal_digits) )
          builder = CmdAccess( t, builder, "print", print_args )

          if (left_justify) whole_digits = -whole_digits
          local align_args = CmdArgs( CmdLiteralInteger(arg.t,whole_digits) )
          if (zero_fill_option) align_args.add( CmdLiteralCharacter(arg.t,'0') )
          builder = CmdAccess( t, builder, "align", align_args )

          remaining = remaining.substring( i2 + 1 )
        endIf
      endForEach

      if (find_marker_start(remaining) != -1)
        throw arg.t.error( "More format markers than arguments in formatted string." )
      endIf

      if (remaining.count?)
        builder = CmdAccess( t, builder, "print", CmdArgs(CmdLiteralString(t,remaining)) )
      endIf

      builder = CmdConvertToType( builder.t, builder, Types.type_String )

      return builder.resolve


    method find_marker_start( st:String )->Integer
      forEach (i of st)
        if (st[i] == '$') return i
      endForEach
      return -1
      
    method find_marker_end( st:String, i1:Integer )->Integer
      local count = st.count
      local i2 = i1 + 1
      local found_period = false
      if (i2 == count or st[i2] != '(') return i1
      ++i2
      while (i2 < count)
        local ch = st[i2]
        if (ch == ')') return i2
        if (not ch.is_number) 
          if (ch == '.')
            if (found_period) escapeWhile  # found more than one period
            found_period = true
          else
            escapeWhile  # not a number or a period
          endIf
        endIf
        ++i2
      endWhile
      throw t.error( "Invalid format marker found." )
      
endClass


class CmdUnary : Cmd
  PROPERTIES
    operand     : Cmd
    opcode = -1 : Integer

  METHODS
    method init( t, operand )

    method init( operand )
      t = operand.t

    method has_side_effects->Logical
      return operand.has_side_effects

    method is_complex_reference->Logical
      return true

    method type->Type
      return operand.type

    method name->String
      return "[unnamed unary op]"

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      buffer.print( name )
      buffer.print( ' ' )
      operand.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local operand_type = operand.type

      if (operand instanceOf CmdLiteral)
        if (operand_type.is_Real)
          local result = resolve_for_literal_real_operand( (operand as CmdLiteralReal).value )
          if (result?) return result
        elseIf (operand_type.is_Integer)
          local result = resolve_for_literal_integer_operand( (operand as CmdLiteralInteger).value )
          if (result?) return result
        elseIf (operand_type.is_Logical)
          local result = resolve_for_literal_logical_operand( (operand as CmdLiteralLogical).value )
          if (result?) return result
        else
          local result = resolve_for_literal_operand
          if (result?) return result
        endIf
      endIf

      if (operand_type.is_reference)
        local result = resolve_for_reference_operand
        if (result?) return result
      endIf

      return resolve_for_operand_type( operand_type )

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return null

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return null

    method resolve_for_literal_operand->Cmd
      return null

    method resolve_for_operand_type( operand_type:Type )->Cmd
      return this

    method resolve_for_reference_operand->Cmd
      return null
endClass

class CmdLogicalNot : CmdUnary
  METHODS
    method clone->CmdLogicalNot
      return CmdLogicalNot( t, operand )

    method name->String
      return "not"

    method implicit_type->Type
      return Types.type_Logical

    method type->Type
      return Types.type_Logical

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      # TODO
      return null

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      # TODO
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

endClass

class CmdNegate : CmdUnary
  METHODS
    method clone->CmdNegate
      return CmdNegate( t, operand )

    method name->String
      return "-"

    method implicit_type->Type
      return operand.implicit_type

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return CmdLiteralReal( t, -operand_value )

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return CmdLiteralInteger( t, -operand_value )

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

    method resolve_for_reference_operand->Cmd
      return CmdAccess( t, operand, "operator-", null ).resolve.require_value

    method resolve_for_operand_type( operand_type:Type )->Cmd
      if (operand_type.is_Real or operand_type.is_Integer)
        return this
      elseIf (operand_type.is_Character or operand_type.is_Byte)
        local result = CmdNegate( t, operand.cast_to(t, Types.type_Integer) ).resolve
        return result
      endIf
      return this

endClass

class CmdBitwiseNot : CmdUnary
  METHODS
    method clone->CmdBitwiseNot
      return CmdBitwiseNot( t, operand )

    method name->String
      return "!"

    method implicit_type->Type
      return operand.implicit_type

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      # TODO
      # return CmdLiteralInteger( t, !operand_value )
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

    method resolve_for_integer_operand->Cmd
      opcode = Op.bitwise_not_integer
      return this

    method resolve_for_logical_operand->Cmd
      opcode = Op.logical_not
      return this

    method resolve_for_reference_operand->Cmd
      return CmdAccess( t, operand, "operator!", null ).resolve.require_value
endClass

class CmdLogicalize : CmdUnary
  METHODS
    method clone->CmdLogicalize
      return CmdLogicalize( t, operand )

    method name->String
      return "?"

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '?' )

    method implicit_type->Type
      return Types.type_Logical

    method type->Type
      return Types.type_Logical

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return CmdLiteralLogical( t, operand_value? )

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return CmdLiteralLogical( t, operand_value? )

    method resolve->Cmd
      if (resolved) return this

      operand = operand.resolve.require_value
      if (operand.type.is_Logical) return operand

      return prior.resolve

endClass


class CmdAccess : Cmd
  SETTINGS
    debug_count = 0

  PROPERTIES
    operand     : Cmd
    name        : String
    args        : CmdArgs
    resolved_on : Integer

  METHODS
    method init( t, name )

    method init( t, name, args )

    method init( t, operand, name, args )

    method init( t, operand_name:String, name, args=null )
      init( t, CmdAccess(t,operand_name), name, args )

    method init( operand, name, args=null )
      t = operand.t

    method init( v:Local )
      t = v.t
      name = v.name

    method init( property:Property )
      t = property.t
      name = property.name

    method init( property:Property, name, args=null )
      t = property.t
      operand = CmdAccess( t, property.name )

    method clone->CmdAccess
      return CmdAccess( t, clone(operand), name, clone(args) )

    method has_side_effects->Logical
      if (operand? and operand.has_side_effects) return true
      return (args? and args.has_side_effects)

    method implicit_type->Type
      local as_type = Types.find_type_or_template( t, name )
      if (as_type?)
        return as_type
      else
        if (operand is null and args is null and Analyzer.context?)
          local v = Analyzer.context.find_local( name )
          if (v?) return v.type
        endIf
      endIf
      return null

    method print( buffer:StringBuilder )
      if (operand?)
        operand.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( name )
      if (args?)
        buffer.print( '(' )
        args.print( buffer )
        buffer.print( ')' )
      endIf

    method resolve->Cmd
      return resolve_with_type_hint( null )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      if (operand?)
        operand = operand.resolve.require_value
      endIf

      local as_type = Types.find_type_or_template( t, name )

      if (operand?)
        # Explicit context
        operand = operand.resolve_with_type_hint( as_type ).require_value

        local operand_type = operand.type
        operand_type.resolve
        #{
        if (operand_type.is_primitive)
          # Primitive context
          if (as_type? and args is null)
            return operand.cast_to(t,as_type).resolve
          endIf
          throw t.error( "TODO: CmdAccess::resolve with primitive context" )
        else
          }#
          # Object context

          # An object is calling to-type for its own type (e.g. "ABC".String).
          # Strip the call.
          #if (operand_type is type_hint) return operand

          # Check for methods first
          local result = Analyzer.resolve_call( t, operand_type, operand, name, args, false, type_hint )
          if (result?) return result

          # Then check for property access
          local p = operand_type.find_property( name )
          if (p?) 
            return CmdReadProperty(t,operand,p).resolve
          endIf

          # Check for setting
          local s = operand_type.find_setting( name )
          if (s?) return CmdReadSetting(t,operand,s).resolve

          # Convert into dynamic access for types that allow it (e.g. table.x -> table.get("x"))
          if (operand_type.attributes.is_dynamic_access and (args is null or args.count==0))
            return CmdAccess( t, operand, "get", CmdArgs(CmdLiteralString(t,name)) ).resolve_with_type_hint(type_hint)
          endIf

          #println( "TODO: check for Object::[TypeName]." )

          # Throw an error while allowing possible candidate methods to print out
          result = Analyzer.resolve_call( t, operand_type, operand, name, args, true, type_hint )
          throw Error("FAIL")
          return null  # never happens

          #endIf

      else
        # Implicit/'this' context
        if (args is null)
          local v = Analyzer.context.find_local( name )
          if (v?)
            return CmdReadLocal( t, v )
          endIf
        endIf

        if (as_type?)
          if (args? or name.ends_with(']'))
            # New object
            if (args is null) args = CmdArgs()
            return CmdNewObject( t, as_type, args ).resolve
          else
            # Singleton access
            if (as_type.generic_base?) throw t.error( "Attempt to read generic-type singleton; generic types do not have singletons." )
            return CmdReadSingleton( t, as_type ).resolve
          endIf
        endIf

        # Check for a method call with an optional return type hint
        local result = Analyzer.resolve_call( t, Analyzer.context.this_type, null, name, args, false, type_hint )
        if (result?) return result

        # Check for property access
        local p = Analyzer.context.this_type.find_property( name )
        if (p?) return CmdReadProperty( t, null, p ).resolve

        # Check for setting access
        local s = Analyzer.context.this_type.find_setting( name )
        if (s?) return CmdReadSetting(t,null,s).resolve

        # Convert into dynamic access for types that allow it
        if (Analyzer.context.this_type.attributes.is_dynamic_access and (args is null or args.count == 0))
          return CmdAccess( t, "get", CmdArgs(CmdLiteralString(t,name)) ).resolve_with_type_hint(type_hint)
        endIf

        Analyzer.resolve_call( t, Analyzer.context.this_type, null, name, args, true, type_hint )  # will generate an error
      endIf

      println "In " + Analyzer.context.this_method.context_signature
      throw t.error( "TODO: CmdAccess::resolve()" )

    method resolve_increment->Cmd
      if (operand?)
        operand = operand.resolve
        operand.type.resolve( t )
        local p = operand.type.find_property( name )
        if (p?) return CmdIncrementProperty( t, operand, p ).resolve

        p = operand.type.must_find_setting( t, name )
        return CmdIncrementSetting( t, operand, p ).resolve
      else
        local v = Analyzer.context.find_local( name )
        if (v?)
          return CmdIncrementLocal(t,v).resolve
        endIf

        local this_type = Analyzer.context.this_type
        local p = this_type.find_property( name )
        if (p?) return CmdIncrementProperty( t, operand, p ).resolve

        p = this_type.must_find_setting( t, name )
        return CmdIncrementSetting( t, operand, p ).resolve
      endIf

    method resolve_decrement->Cmd
      if (operand?)
        operand = operand.resolve
        local p = operand.type.find_property( name )
        if (p?) return CmdDecrementProperty( t, operand, p ).resolve

        p = operand.type.must_find_setting( t, name )
        return CmdDecrementSetting( t, operand, p ).resolve
      else
        local v = Analyzer.context.find_local( name )
        if (v?)
          return CmdDecrementLocal(t,v).resolve
        endIf

        local this_type = Analyzer.context.this_type
        local p = this_type.find_property( name )
        if (p?) return CmdDecrementProperty( t, null, p ).resolve

        p = this_type.must_find_setting( t, name )
        return CmdDecrementSetting( t, operand, p ).resolve
      endIf

    method resolve_assignment( new_value:Cmd )->Cmd
      if (args?)
        throw t.error( "Illegal target for assignment." )
      endIf

      local context_type : Type
      if (operand?)
        # obj.x = y
        operand = operand.resolve.require_value
        context_type = operand.type
      else
        # x = y
        context_type = Analyzer.context.this_method.type_context
      endIf

      if (name[0] != '@')
        # Try "[obj.]name = value" -> "[obj.]set_name( value )"
        local set_name = "set_" + name
        if (context_type.find_method( set_name, 1 )?)
          local call_args = CmdArgs( new_value )
          local cmd = Analyzer.resolve_call( t, context_type, operand, set_name, call_args, false, null )
          if (cmd?) 
            return cmd
          endIf
          new_value = call_args.first  # avoid resolving 'new_value' twice
        endIf
      endIf

      if (operand?)
        operand = operand.resolve.require_value
        local operand_type = operand.type
        if (args is null)
          # Most likely to be a property so we'll check for that first
          local p = operand_type.find_property( name )
          if (p?)
            return CmdWriteProperty(t,operand,p,new_value).resolve
          endIf

          # Check for setting
          p = operand_type.find_setting( name )
          if (p?)
            return CmdWriteSetting(t,operand,p,new_value).resolve
          endIf

          # Convert into dynamic access for types that allow it
          if (operand_type.attributes.is_dynamic_access)
            return CmdAccess( t, operand, "set", CmdArgs(CmdLiteralString(t,name),new_value) ).resolve
          endIf

        endIf
        throw t.error( "Cannot find property '$' in CmdAccess::resolve_assignment().  TODO: add check for implicit write method." (name) )
      endIf

      # No context specified --------------------------------------------------

      # Check for local
      local v = Analyzer.context.find_local( name )
      if (v?)
        return CmdWriteLocal(t,v,new_value).resolve
      endIf

      # Check for property
      local p = Analyzer.context.this_type.find_property( name )
      if (p?)
        return CmdWriteProperty(t,null,p,new_value).resolve
      endIf

      # Check for setting
      local s = Analyzer.context.this_type.find_setting( name )
      if (s?)
        return CmdWriteSetting(t,null,s,new_value).resolve
      endIf

      # Check for Singleton
      local as_type = Types.find_type_or_template( t, name )
      if (as_type?)
        if (as_type.generic_base?) 
          throw t.error( "Cannot assign a value to a generic-type singleton; generic types do not have singletons." )
        endIf
        if (not as_type.attributes.is_singleton)
          throw t.error( "Type '$' must be declared as a [singleton] in order to be reassigned." (name) )
        endIf
        return CmdWriteSingleton( t, as_type, new_value ).resolve
      endIf

      # Convert into dynamic access for types that allow it
      if (Analyzer.context.this_type.attributes.is_dynamic_access)
        return CmdAccess( t, "set", CmdArgs(CmdLiteralString(t,name),new_value) ).resolve
      endIf

      #throw t.error( //"$" is undefined.// (name) )
      throw t.error( //"// + name + //" is undefined.// )


endClass

class CmdElementAccess : Cmd
  PROPERTIES
    operand : Cmd
    args    : CmdArgs

  METHODS
    method init( t, operand )
      args = CmdArgs()

    method init( t, operand, args )

    method clone->CmdElementAccess
      return CmdElementAccess( t, clone(operand), clone(args) )

    method has_side_effects->Logical
      return ((operand? and operand.has_side_effects) or args? and args.has_side_effects)

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print('[')
      args.print( buffer )
      buffer.print(']')

    method resolve->Cmd
      return Analyzer.resolve_call( t, null, operand, "get", args, true, null )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      return Analyzer.resolve_call( t, null, operand, "get", args, true, null )

    method resolve_assignment( new_value:Cmd )->Cmd
      args.add( new_value )
      return Analyzer.resolve_call( t, null, operand, "set", args, true, null )

    method resolve_increment->Cmd
      return CmdAssign( t, this.clone, CmdAdd(t,this,CmdLiteralInteger(t,1)) ).resolve

    method resolve_decrement->Cmd
      return CmdAssign( t, this.clone, CmdSubtract(t,this,CmdLiteralInteger(t,1)) ).resolve

endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdLocalDeclaration
      return CmdLocalDeclaration( t, local_info )

    method has_side_effects->Logical
      # We don't want the compiler stripping out these local variable declarations
      return true

    method print( buffer:StringBuilder )
      buffer.print( "local " )
      buffer.print( local_info.name )
      if (local_info.type?)
        buffer.print( " : " )
        buffer.print( local_info.type )
      endIf

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]

      if (local_info.type?) local_info.type.resolve

      local existing_p = Analyzer.context.this_type.find_property( local_info.name )
      if (existing_p?)
        #throw local_info.t.error( "A property named '$' already exists in class $." (local_info.name,Analyzer.context.this_type) )
        throw local_info.t.error( "A property named '" + local_info.name + "' already exists in class " +  Analyzer.context.this_type + "." )
      endIf

# print(local_info.name)
# print(" ")
# println(local_info.type)
# println
      Analyzer.add_local( local_info )
      return this

endClass

class CmdAssign : CmdStatementWithOperand
  PROPERTIES
    new_value : Cmd

  METHODS
    method init( t, operand, new_value )

    method init( t, operand_name:String, new_value )
      operand = CmdAccess( t, operand_name )

    method clone->CmdAssign
      return CmdAssign( t, clone(operand), clone(new_value) )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( " = " )
      new_value.print( buffer )

    method resolve->Cmd
      return operand.resolve_assignment( new_value )
endClass

class CmdReadLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method init( local_info )
      t = local_info.t

    method clone->CmdReadLocal
      return CmdReadLocal( t, local_info )

    method type->Type
      return local_info.type

    method variable_name->String
      return local_info.name

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )

    method resolve->Cmd
      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]
      return this

endClass

class CmdWriteLocal : CmdStatement
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method init( local_info, new_value )
      t = local_info.t

    method clone->CmdWriteLocal
      return CmdWriteLocal( t, local_info, clone(new_value) )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )
      buffer.print( " = " )
      new_value.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]

      new_value = new_value.resolve.require_value
      local new_value_type = new_value.type

      if (local_info.type is null)
        local_info.type = new_value_type
        new_value_type.resolve
      endIf

      if (local_info.type.is_reference or local_info.type.is_compound)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      #if (new_value_type.possibly_null and not local_info.type.possibly_null)
      #throw t.error( "'" + local_info.name + "' can only store null-checked references." )
      #endIf

      new_value = new_value.cast_to(t,local_info.type).resolve

      return this

    method resolve_reference_assignment->Cmd
      return null
      #if (local_info.type.find_method("assign",2)?)
      #  return Analyzer.resolve_call( t, null, CmdReadSingleton(t,local_info.type), "assign", CmdArgs(CmdReadLocal(local_info),new_value), true, null ).resolve
      #endIf

endClass

class CmdWriteLocalDefault : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )
      if (local_info.type is null)
        local_info.type = Types.type_Object
      endIf

    method clone->CmdWriteLocalDefault
      return CmdWriteLocalDefault( t, local_info )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )
      buffer.print( " = " )
      buffer.print( "(default value)" )

    method resolve->Cmd
      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]
      return this

endClass

class CmdIncrement : CmdStatementWithOperand
  METHODS
    method clone->CmdIncrement
      return CmdIncrement( t, clone(operand) )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      return operand.resolve_increment
endClass

class CmdIncrementLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdIncrementLocal
      return CmdIncrementLocal( t, local_info )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( local_info.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]

      if (local_info.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (local_info.type.is_reference)
        return CmdAccess( t, CmdReadLocal(t,local_info), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdIncrementSetting : Cmd
  PROPERTIES
    context  : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdIncrementSetting
      return CmdIncrementSetting( t, clone(context), setting )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( setting.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?) context = context.resolve

      if (setting.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (setting.type.is_reference)
        return CmdAccess( t, CmdReadSetting(t,context,setting), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdIncrementProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method clone->CmdIncrementProperty
      return CmdIncrementProperty( t, clone(context), property )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( property.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?) context = context.resolve

      if (property.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (property.type.is_reference)
        return CmdAccess( t, CmdReadProperty(t,context,property), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdDecrement : CmdStatementWithOperand
  METHODS
    method clone->CmdDecrement
      return CmdDecrement( t, clone(operand) )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      return operand.resolve_decrement
endClass

class CmdDecrementLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdDecrementLocal
      return CmdDecrementLocal( t, local_info )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( local_info.name )

    method resolve->Cmd
      # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
      local_info = Analyzer.context.this_method.locals[ local_info.index ]
      return this
endClass

class CmdDecrementSetting : Cmd
  PROPERTIES
    context : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdDecrementSetting
      return CmdDecrementSetting( t,clone(context), setting )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( setting.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?) context = context.resolve.require_value

      if (not (setting.type.is_primitive))
        throw t.error( "Cannot decrement a value of type " + setting.type.name + "." )
      endIf

      return this
endClass

class CmdDecrementProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method clone->CmdDecrementProperty
      return CmdDecrementProperty( t,clone(context), property )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( property.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?) context = context.resolve.require_value

      if (not (property.type.is_primitive))
        #throw t.error( "Cannot decrement a value of type $." (property.type) )
        throw t.error( "Cannot decrement a value of type " + property.type.name + "." )
      endIf

      return this
endClass

class CmdThis( t, this_type:Type ) : Cmd
  METHODS
    method clone->CmdThis
      return CmdThis( t, this_type )

    method type->Type
      return this_type

    method print( buffer:StringBuilder )
      buffer.print( "this" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Update type in case of propagated method
      this_type = Analyzer.context.this_type
      return this
endClass

class CmdReadSingleton : Cmd
  PROPERTIES
    of_type     : Type

  METHODS
    method init( t, of_type )

    method clone->CmdReadSingleton
      return CmdReadSingleton( t, of_type )

    method type->Type
      return of_type

    method implicit_type->Type
      return of_type

    method print( buffer:StringBuilder )
      buffer.print( of_type )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      of_type.resolve(t).mark_used

      return this

endClass

class CmdWriteSingleton : Cmd
  PROPERTIES
    of_type     : Type
    new_value   : Cmd

  METHODS
    method init( t, of_type, new_value )

    method clone->CmdWriteSingleton
      return CmdWriteSingleton( t, of_type, new_value )

    method print( buffer:StringBuilder )
      buffer.print( of_type.name )
      buffer.print( " = " )
      new_value.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      of_type.resolve(t).mark_used

      new_value = new_value.resolve.require_value.cast_to( t, of_type ).resolve.require_value

      return this

endClass

class CmdReadSetting : Cmd
  PROPERTIES
    context  : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdReadSetting
      return CmdReadSetting( t, clone(context), setting )

    method has_side_effects->Logical
      return (context? and context.has_side_effects)

    method type->Type
      return setting.type

    method variable_name->String
      return setting.name

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( setting.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      setting.type.resolve(t)
      if (context?)
        context = context.resolve
        #if (context.type.possibly_null) throw t.error( "Unchecked reference access." )
        if (context instanceOf CmdReadSingleton) context = null
      endIf

      if (context is null and setting.is_constant)
        return setting.initial_value.clone.resolve
      endIf

      return this
endClass

class CmdReadProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method init( local_info:Local, _property:Property )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), _property )

    method clone->CmdReadProperty
      return CmdReadProperty( t, clone(context), property )
      
    method has_side_effects->Logical
      return (context? and context.has_side_effects)

    method type->Type
      return property.type

    method variable_name->String
      return property.name

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( property.name )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?)
        context = context.resolve
        #if (context.type.possibly_null) throw t.error( "Unchecked reference access." )
      endIf
      property.type.resolve(t)
      return this
endClass

class CmdWriteSetting : Cmd
  PROPERTIES
    context   : Cmd
    setting   : Property
    new_value : Cmd

  METHODS
    method init( t, context, setting, new_value )

    method clone->CmdWriteSetting
      return CmdWriteSetting( t, clone(context), setting, clone(new_value) )

    method has_side_effects->Logical
      return true

    method type->Type
      return null

    method name->String
      return "="

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( setting.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      setting.type.resolve(t)
      new_value = new_value.resolve.require_value

      #if (new_value.type.possibly_null and not setting.type.possibly_null)
      #throw t.error( "'" + setting.name + "' can only store null-checked references." )
      #endIf

      if (context?) context = context.resolve

      if (setting.type.is_reference or setting.type.is_compound)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      new_value = new_value.resolve.cast_to(t,setting.type).resolve
      return this

    method resolve_reference_assignment->Cmd
      return null

endClass

class CmdWriteProperty : Cmd
  PROPERTIES
    context   : Cmd
    property  : Property
    new_value : Cmd

  METHODS
    method init( t, context, property, new_value )

    method clone->CmdWriteProperty
      return CmdWriteProperty( t, clone(context), property, clone(new_value) )

    method has_side_effects->Logical
      return true

    method is_op_assign->Logical
      return false

    method type->Type
      return null

    method name->String
      return "="

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( property.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      property.type.resolve(t)

      new_value = new_value.resolve.require_value

      #if (new_value.type.possibly_null and not property.type.possibly_null)
      #throw t.error( "'" + property.name + "' can only store null-checked references." )
      #endIf

      #{
      if (context?)
        context = context.resolve.require_value
        if (is_op_assign and context.is_complex_reference)
          # Refactor:
          #   context.property += result
          #
          # into:
          #   local temp = context
          #   temp.property += result
          #
          # so that it may also be written as:
          #   local temp = context
          #   temp.property = temp.property + result
        endIf
      endIf
      }#

      if (property.type.is_reference or property.type.is_compound)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      new_value = new_value.resolve.cast_to(t,property.type).resolve
      return this

    method resolve_reference_assignment->Cmd
      return null

endClass

class CmdNewObject : Cmd
  PROPERTIES
    of_type     : Type
    init_method : Method
    args        : CmdArgs

  METHODS
    method init( t, of_type )

    method init( t, of_type, args )

    method init( t, of_type, args, init_method )

    method clone->CmdNewObject
      return CmdNewObject( t, of_type, clone(args), init_method )

    method has_side_effects->Logical
      return true

    method implicit_type->Type
      return of_type

    method is_complex_reference->Logical
      return true

    method type->Type
      return of_type

    method print( buffer:StringBuilder )
      buffer.print( of_type )
      buffer.print( '(' )
      if (args?) args.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      of_type.resolve(t)
      of_type.mark_used

      if (of_type.is_aspect) throw t.error("Aspects cannot be instantiated as objects.")

      if (of_type.is_native)
        return CmdAccess( t, CmdReadSingleton(t,of_type), "create", args ).resolve
      endIf

      if (args?) args.resolve

      local create_method = Analyzer.find_method( t, of_type, null, "create", args, false )
      if (create_method? and create_method.type_context is of_type)
        args = create_method.validate_arguments( args )
        return CmdAccess( t, CmdReadSingleton(t,of_type), "create", args ).resolve
      endIf

      init_method = Analyzer.find_method( t, of_type, null, "init", args, false )
      if (init_method?)
        init_method.mark_referenced
        args = init_method.validate_arguments( args )
      else
        local buffer = StringBuilder()
        buffer.print( "No 'create' or 'init' method matching signature (" )
        if (args?)
          local first = true
          forEach (arg in args)
            if (first) first = false
            else       buffer.print(',')
            buffer.print( arg.type )
          endForEach
        endIf
        buffer.print( ") in class " )
        buffer.print( of_type )
        buffer.print( '.' )
        throw t.error( buffer->String )
      endIf
      return this

endClass

class CmdCall : Cmd
  PROPERTIES
    context           : Cmd
    method_info       : Method
    args              : CmdArgs
    #clone : Logical

  METHODS
    method init( t, context, method_info )
      args = Analyzer.empty_args

    method init( t, context, method_info, args )
      if (args is null) args = Analyzer.empty_args

    method clone->CmdCall
      return CmdCall( t, clone(context), method_info, clone(args) )

    method has_side_effects->Logical
      local m = method_info.x_method
      if (m.body.count? or m.type_context.is_aspect or m.attributes.is_native or m.inline_mapping? or 
          m.attributes.is_special or m.attributes.is_automatic) return true
      if (context? and context.has_side_effects) return true
      return (args? and args.has_side_effects)

    method is_complex_reference->Logical
      return true

    method type->Type
      return method_info.return_type

    method variable_name->String
      return method_info.name

    method print( buffer:StringBuilder )
      buffer.print( '(' )

      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf

      buffer.print( method_info.type_context.name )
      buffer.print( "::" )

      buffer.print( method_info.name )
      buffer.print( '(' )
      args.print( buffer )
      buffer.print( ')' )
      if (method_info.return_type?)
        buffer.print( "->" )
        buffer.print( method_info.return_type )
      endIf
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      method_info.mark_referenced
      if (context?)
        context = context.resolve.require_value
        context.type.resolve( t )
        #local context_type = context.type
        #if (context_type.possibly_null) throw t.error( "Unchecked reference access." )
      endIf

      args.resolve
      args = method_info.validate_arguments( args )

      return this

endClass

class CmdStaticCall : CmdCall
  # A static call is a non-dynamic call to a specific method on an arbitrary object
  # of a compatible type.  It is not a static call in the Java/C++ sense of a context-free
  # call.
  METHODS
    method clone->CmdStaticCall
      return CmdStaticCall( t, clone(context), method_info, clone(args) )
endClass

class CmdSingletonCall : CmdCall
  # A singleton call is a call to a specific singleton object.  Often the code is context-free
  # (does not access properties of the singleton) and can be inlined.
  PROPERTIES
    singleton_type : Type

  METHODS
    method init( t, singleton_type, method_info, args )
      if (args is null) args = Analyzer.empty_args

    method clone->CmdSingletonCall
      return CmdSingletonCall( t, singleton_type, method_info, clone(args) )
endClass

class CmdDynamicCall : CmdCall
  METHODS
    method init( t, context, method_info )
      args = Analyzer.empty_args

    method init( t, context, method_info, args )
      if (args is null) args = Analyzer.empty_args

    method init( local_info:Local, method_info )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), method_info, null )

    method init( local_info:Local, method_info, args )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), method_info, args )

    method clone->CmdDynamicCall
      return CmdDynamicCall( t, clone(context), method_info, clone(args) )

    method has_side_effects->Logical
      return true

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (context?)
        context = context.resolve.require_value
        context.type.resolve( t )

        if (context instanceOf CmdReadSingleton and not context.type.extended)
          return CmdSingletonCall( t, context.type, method_info, args ).resolve
        endIf
      endIf

      if (method_info.name == "create" or method_info.is_initializer) return CmdStaticCall( t, context, method_info, args ).resolve

      args.resolve
      args = method_info.validate_arguments( args )

      method_info.mark_referenced
      return this
endClass

class CmdPriorCall( t, name:String, args:CmdArgs ) : Cmd
  METHODS
    method clone->CmdPriorCall
      return CmdPriorCall( t, name, clone(args) )

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      if (resolved) return this
      resolved = true
      return resolve_with_type_hint( null )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      local cur_m = Analyzer.find_method( t, Analyzer.context.this_type, null, name, args, true )
      if (not cur_m.type_context.instance_of(Analyzer.context.this_type))
        # The given method is not defined in the current class and so
        # 'prior' is being used to statically select the call context.
        return CmdStaticCall( t, null, cur_m, args ).resolve

      else
        local cur_type = cur_m.type_context
        #if (cur_type.base_types.count == 0) throw t.error( "No prior definition of $::$." (cur_type,cur_m.full_signature) )
        if (cur_type.base_types.count == 0) throw t.error( "No prior definition of " + cur_type.name + "::" + cur_m.full_signature + "." )
        local m = Analyzer.find_method( t, cur_type.base_types.first, null, name, args, true )
        return CmdStaticCall( t, null, m, args ).resolve
      endIf
endClass

class CmdStatement : Cmd
  METHODS
    method type->Type
      return null

    method resolve->Cmd
      return this
endClass

class CmdControlStructure : CmdStatement
  ENUMERATE
    type_anonymous
    type_if
    type_which
    type_contingent
    type_try

    type_iteration
    type_while
    type_for_each
    type_loop

  PROPERTIES
    structure_type                   : Integer
    control_id = Analyzer.unique_id  : String
    control_id_used_in_nested_code   : Logical
endClass

class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    body                : CmdStatementList
    elseIf_conditions   = Cmd[]
    elseIf_bodies       = CmdStatementList[]
    else_body           : CmdStatementList

  METHODS
    method init( t, condition )
      structure_type = CmdControlStructure.type_if
      body = CmdStatementList()

    method init( condition )
      init( condition.t, condition )

    method clone->CmdIf
      local result = CmdIf( t, clone(condition) )
      result.structure_type = structure_type
      result.body = clone(body)
      forEach (elseIf_c in elseIf_conditions) result.elseIf_conditions.add( clone(elseIf_c) )
      forEach (elseIf_b in elseIf_bodies) result.elseIf_bodies.add( clone(elseIf_b) )
      result.else_body = clone( else_body )
      return result

    method has_side_effects->Logical
      if (condition.has_side_effects) return true
      if (body.has_side_effects) return true
      forEach (c in elseIf_conditions)
        if (c.has_side_effects) return true
      endForEach
      forEach (b in elseIf_bodies)
        if (b.has_side_effects) return true
      endForEach
      if (else_body? and else_body.has_side_effects) return true
      return false

    method print( buffer:StringBuilder )
      buffer.print( "if (" )
      condition.print( buffer )
      buffer.println( ')' )

      body.print( buffer )

      forEach (index in elseIf_conditions.indices)
        buffer.print( "      elseIf (" )
        elseIf_conditions[index].print( buffer )
        buffer.println( ")" )
        elseIf_bodies[index].print( buffer )
      endForEach

      if (else_body?)
        buffer.println( "      else" )
        else_body.print( buffer )
      endIf

      buffer.println( "      endIf" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      condition = condition.resolve.require_value
      local condition_type = condition.type
      #{
      if (condition_type.is_reference)
        return CmdIfNonNull( t, condition, body, else_body ).resolve
      endIf
      }#

      condition.require_logical

      Analyzer.context.control_structure_stack.add( this )
      body.resolve

      forEach (index in elseIf_conditions.indices)
        elseIf_conditions[index] = elseIf_conditions[index].resolve.require_value
        elseIf_bodies[index].resolve
      endForEach

      if (else_body?) else_body.resolve

      Analyzer.context.control_structure_stack.remove_last
      return this
endClass

class CmdWhich : CmdControlStructure
  PROPERTIES
    expression       : Cmd
    cases            = CmdWhichCase[](1)
    others_case      : CmdStatementList

    which_is = false : Logical

  METHODS
    method init( t, expression, which_is )
      structure_type = CmdControlStructure.type_which

    method clone->CmdWhich
      local result = CmdWhich( t, clone(expression), which_is )
      result.structure_type = structure_type
      forEach (c in cases) result.cases.add( clone(c) as CmdWhichCase )
      result.others_case = clone( others_case )
      return result

    method has_side_effects->Logical
      if (expression.has_side_effects) return true
      forEach (c in cases)
        if (c.has_side_effects) return true
      endForEach
      return (others_case? and others_case.has_side_effects)

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      expression = expression.resolve

      Analyzer.context.control_structure_stack.add( this )

      local cmd_if : CmdIf
      forEach (c in cases)
        local ors : Cmd
        forEach(v in c.values)
          local cmp:Cmd
          if (not which_is) cmp = CmdCompareEQ( t, expression, v)
          else              cmp = CmdCompareIs( t, expression, v)

          if (ors?) ors = CmdLogicalOr(t, ors, cmp ) # "Append" next or to expression
          else      ors = cmp
        endForEach

        if (cmd_if?)
          cmd_if.elseIf_conditions.add( ors )
          cmd_if.elseIf_bodies.add( c.body )
        else
          cmd_if = CmdIf( t, ors )
          cmd_if.structure_type = structure_type
          cmd_if.body = c.body
        endIf
      endForEach

      if (others_case?)
        cmd_if.else_body = others_case
      endIf

      local result = cmd_if.resolve

      Analyzer.context.control_structure_stack.remove_last
      return result

endClass

class CmdWhichCase : Cmd
  PROPERTIES
    values    = Cmd[](1)
    body      : CmdStatementList

  METHODS
    method init( t )
      body = CmdStatementList()

    method clone->CmdWhichCase
      local result = CmdWhichCase( t )
      forEach (v in values) result.values.add( clone(v) )
      result.body = clone( body )
      return result

    method has_side_effects->Logical
      forEach (v in values)
        if (v.has_side_effects) return true
      endForEach
      return (body.has_side_effects)

    method resolve->Cmd
      throw t.error( "resolve() not implemented for CmdWhichCase." )

endClass

class CmdContingent : CmdControlStructure
  PROPERTIES
    body             : CmdStatementList
    satisfied_body   : CmdStatementList
    unsatisfied_body : CmdStatementList

  METHODS
    method init( t )
      structure_type = CmdControlStructure.type_contingent
      body = CmdStatementList()

    method init( t, body )
      structure_type = CmdControlStructure.type_contingent

    method clone->CmdContingent
      local result = CmdContingent( t, clone(body) )
      result.structure_type = structure_type
      result.satisfied_body = clone( satisfied_body )
      result.unsatisfied_body = clone( unsatisfied_body )
      return result

    method has_side_effects->Logical
      if (body.has_side_effects) return true
      if (satisfied_body? and satisfied_body.has_side_effects) return true
      if (unsatisfied_body? and unsatisfied_body.has_side_effects) return true
      return false

    method print( buffer:StringBuilder )
      buffer.println( "contingent" )
      body.print( buffer )
      if (satisfied_body?)
        buffer.println( "satisfied" )
        satisfied_body.print( buffer )
      endIf

      if (unsatisfied_body?)
        buffer.println( "unsatisfied" )
        unsatisfied_body.print( buffer )
      endIf

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      Analyzer.context.control_structure_stack.add( this )
      body.resolve

      if (satisfied_body?) satisfied_body.resolve
      if (unsatisfied_body?) unsatisfied_body.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this
endClass

class CmdContingentControlStructure : CmdStatementWithOperand
  PROPERTIES
    label     : String
    target_id : String
endClass

class CmdNecessary : CmdContingentControlStructure
  METHODS
    method clone->CmdNecessary
      return CmdNecessary( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "necessary " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_contingent)
          target_id = control_structure.control_id
          operand = operand.resolve.require_logical
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'contingent' for 'necessary' clause." )
endClass

class CmdSufficient : CmdContingentControlStructure
  METHODS
    method clone->CmdSufficient
      return CmdSufficient( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "sufficient " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_contingent)
          target_id = control_structure.control_id
          operand = operand.resolve.require_logical
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach
      throw t.error( "No enclosing 'contingent' for 'sufficient' clause." )
endClass

class CmdAnonymousBlock : CmdControlStructure
  PROPERTIES
    body : CmdStatementList

  METHODS
    method init( t )
      structure_type = CmdControlStructure.type_anonymous
      body=CmdStatementList()

    method init( t, body )
      structure_type = CmdControlStructure.type_anonymous

    method clone->CmdAnonymousBlock
      local result = CmdAnonymousBlock( t, clone(body) )
      result.structure_type = structure_type
      return result

    method has_side_effects->Logical
      return body.has_side_effects

    method print( buffer:StringBuilder )
      body.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      body.resolve
      return this
endClass

class CmdUnqualifiedDelegateSelector : Cmd
  PROPERTIES
    context       : Cmd
    method_name : String

  METHODS
    method init( t, context, method_name )

    method clone->CmdUnqualifiedDelegateSelector
      return CmdUnqualifiedDelegateSelector( t, context, method_name )

    method has_side_effects->Logical
      return (context.has_side_effects)

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      context = context.resolve.require_value

      local matching_m : Method
      forEach (m in context.type.method_list)
        if (m.name == method_name)
          if (matching_m?) throw t.error( //Ambiguous unqualified reference to method "$" - write e.g. "$" or "$" instead.// (method_name,matching_m.signature, m.signature) )
          matching_m = m
        endIf
      endForEach

      if (matching_m is null) throw t.error( //No such method "$" in type "$".// (method_name,context.type.name) )

      local param_types = Type[]
      forEach (param in matching_m.parameters) param_types.add( param.type )

      local delegate_class_names = Analyzer.get_delegate_class_names( method_name, context.type, param_types, matching_m.return_type )
      return CmdDelegate( t, context, method_name, matching_m.signature,
        delegate_class_names[0], delegate_class_names[1], param_types, matching_m.return_type ).resolve
endClass

class CmdDelegate : Cmd
  PROPERTIES
    context_cmd         : Cmd
    param_types         : Type[]
    ret_type            : Type
    method_name         : String
    base_class_name     : String
    extended_class_name : String
    method_signature    : String

  METHODS
    method init( t, context_cmd, method_name, method_signature, ...
        base_class_name, extended_class_name, param_types, ret_type )

    method clone->CmdDelegate
      return CmdDelegate( t, context_cmd, method_name, method_signature,
      base_class_name, extended_class_name, param_types, ret_type )

    method has_side_effects->Logical
      return (context.has_side_effects)

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      local buffer = StringBuilder()
      context_cmd = context_cmd.resolve

      if (Templates.find( base_class_name ) is null)
        Analyzer.create_base_delegate_type( t, base_class_name, param_types, ret_type )
      endIf


      local obj_class = context_cmd.type
      # println("found method with signature: " + obj_class.find_method( method_signature ))
      # println("and param_types: " + obj_class.find_method( method_signature ).parameters[0].type)
      # println(obj_class.find_methods_with_name(method_name))

      local extended_delegate_type   = Types.reference( t, extended_class_name )
      local extended_class_string : String
      if (not extended_delegate_type.is_defined)
        local call_buffer = StringBuilder()
        buffer.println( "class " + extended_class_name + " : " + base_class_name )
        buffer.println( "  PROPERTIES" )
        buffer.println( "    context : " + context_cmd.type.name )
        buffer.println( "  METHODS" )
        buffer.println( "    method init( context )" )
        buffer.print( "    method call( " )
        if (ret_type?) call_buffer.print( "      return context." + method_name )
        else call_buffer.print( "      context." + method_name )
        call_buffer.print( "( " )
        local i = 0
        if(param_types? and param_types.count?)
          while (i < param_types.count - 1)
            buffer.print( "p" + i + ":" + param_types[i].name + ", " )
            call_buffer.print( "p" + i + ", " )
            ++i
          endWhile
          buffer.print( "p" + (param_types.count-1) + ":" + param_types.last.name + " )" )
          call_buffer.print( "p" + (param_types.count-1) + " )" )
        else
          buffer.print( " )" )
          call_buffer.print( " )" )
        endIf
        if (ret_type?) buffer.println( "->" + ret_type.name )
        else buffer.println
        buffer.println(call_buffer)
        buffer.println( "endClass" )

        extended_class_string = buffer->String
        #trace extended_class_string
        Parser( "[Internal]", extended_class_string ).parse_content
        extended_delegate_type = Types.reference(t,extended_class_name).resolve
        buffer.clear
      endIf

      return CmdNewObject( t, extended_delegate_type, CmdArgs(context_cmd) ).resolve

endClass


class CmdIterationControlStructure : CmdControlStructure
  PROPERTIES
    body : CmdStatementList

  METHODS
    method has_side_effects->Logical
      return body.has_side_effects
endClass

class CmdWhile : CmdIterationControlStructure
  PROPERTIES
    condition         : Cmd

  METHODS
    method init( t, condition )
      structure_type = CmdControlStructure.type_while
      body=CmdStatementList()

    method init( t, condition, body )
      structure_type = CmdControlStructure.type_while

    method clone->CmdWhile
      local result = CmdWhile( t, clone(condition), clone(body) )
      result.structure_type = structure_type
      return result

    method has_side_effects->Logical
      return (condition.has_side_effects or body.has_side_effects)

    method print( buffer:StringBuilder )
      buffer.print( "while (" )
      condition.print( buffer )
      buffer.println( ')' )

      body.print( buffer )

      buffer.println( "      endWhile" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      condition = condition.resolve.require_value
      local condition_type = condition.type
      #{
      if (condition_type.is_reference)
        return CmdIfNonNull( t, condition, body, else_body ).resolve
      endIf
      }#

      condition.require_logical

      Analyzer.context.control_structure_stack.add( this )

      body.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this

endClass

class CmdForEach : CmdIterationControlStructure
endClass

class CmdForEachElementInCollection : CmdForEach
  PROPERTIES
    element_t    : Token
    element_name : String
    #element_info   : Local
    collection   : Cmd
    step_size=1  : Integer

  METHODS
    method init( t, element_t, element_name, collection )
      structure_type = CmdControlStructure.type_for_each
      body = CmdStatementList()

    method init( t, element_t, element_name, collection, body )
      structure_type = CmdControlStructure.type_for_each

    method clone->CmdForEachElementInCollection
      local result = CmdForEachElementInCollection( t, element_t, element_name, clone(collection), clone(body)  )
      result.structure_type = structure_type
      result.step_size = step_size
      return result

    method has_side_effects->Logical
      return (collection.has_side_effects or body.has_side_effects)

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      #buffer.print( ':' )
      #buffer.print( element_info.type )
      buffer.print( " in " )
      collection.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      collection = collection.resolve.require_value

      local collection_type = collection.type
      collection_type.resolve

      local m_count = collection_type.find_method( "count()" )
      local p_count : Property
      if (m_count is null) p_count = collection_type.find_property( "count" )
      local has_count = m_count? or p_count?

      local m_get   = collection_type.find_method( "at(Integer)" )
      if (m_get is null) m_get = collection_type.find_method( "get(Integer)" )
 
      if (has_count and m_get?)
        if (m_get.return_type is null) throw collection.error( "Implicit call to $ returns nil." (m_get.context_signature) )
        local element_info = Local( element_t, element_name, m_get.return_type )

        local index_name = "_index_" + Analyzer.unique_id
        local index_info = Local( t, index_name, Types.type_Integer)

        local collection_name = "_collection_" + Analyzer.unique_id
        local collection_info = Local( collection.t, collection_name, collection_type )

        Analyzer.context.this_method.add_local( index_info )
        Analyzer.context.this_method.add_local( collection_info )
        Analyzer.context.this_method.add_local( element_info )

        Analyzer.add_local( index_info )
        Analyzer.add_local( collection_info )
        Analyzer.add_local( element_info )

        local count_cmd:Cmd
        if (m_count?) count_cmd = CmdDynamicCall( collection_info, m_count )
        else          count_cmd = CmdReadProperty( collection_info, p_count )

        local condition = CmdCompareLT( index_info.t, CmdReadLocal(index_info), count_cmd )

        local cmd_while = CmdWhile( t, condition, body )
        cmd_while.structure_type = this.structure_type  # keep looking like a forEach for escapeForEach purposes.

        body.insert( CmdIncrementLocal( index_info.t, index_info ) )
        body.insert( CmdWriteLocal( element_info, CmdDynamicCall(collection_info,m_get,CmdArgs(CmdReadLocal(index_info))) ) )
        body.insert( CmdLocalDeclaration(t,element_info) )

        local result = CmdStatementList()
        result.add( CmdLocalDeclaration(t,index_info) )
        result.add( CmdLocalDeclaration(t,collection_info) )
        result.add( CmdWriteLocalDefault(t,index_info) )
        result.add( CmdAssign( collection.t, CmdAccess(collection.t,collection_name), collection ) )
        result.add( cmd_while )

        return CmdAnonymousBlock( t, result ).resolve

      else
        local m_has_another = collection_type.find_method( "has_another()" )
        local m_read = collection_type.find_method( "read()" )

        if (m_has_another is null or m_read is null)
trace m_has_another?, m_read?
collection_type.print
          throw collection.error( "forEach only operates on readers and on collections that are indexed or readable." )
        endIf

        if (m_has_another.return_type is null or not m_has_another.return_type.is_Logical) 
          throw collection.error( "Collection's has_another() method must return a Logical value." )
        endIf

        if (m_read.return_type is null) throw collection.error( "Implicit call to $ returns nil." (m_read.context_signature) )

        local element_info = Local( element_t, element_name, m_read.return_type )

        local collection_name = "_collection_" + Analyzer.unique_id
        local collection_info = Local( collection.t, collection_name, collection_type )

        Analyzer.context.this_method.add_local( collection_info )
        Analyzer.context.this_method.add_local( element_info )

        Analyzer.add_local( collection_info )
        Analyzer.add_local( element_info )

        local condition = CmdDynamicCall( collection_info, m_has_another )

        local cmd_while = CmdWhile( t, condition, body )
        cmd_while.structure_type = this.structure_type  # keep looking like a forEach for escapeForEach purposes.

        body.insert( CmdWriteLocal( element_info, CmdDynamicCall(collection_info,m_read,CmdArgs()) ) )
        body.insert( CmdLocalDeclaration(t,element_info) )

        local result = CmdStatementList()
        result.add( CmdLocalDeclaration(t,collection_info) )
        result.add( CmdAssign( collection.t, CmdAccess(collection.t,collection_name), collection ) )
        result.add( cmd_while )

        return CmdAnonymousBlock( t, result ).resolve
      endIf


      #Analyzer.context.push_local_scope
      #Analyzer.add_local( element_info )
      #body.resolve
      #Analyzer.context.pop_local_scope
      #return this

endClass

class CmdForEachIndexOfCollection : CmdForEach
  PROPERTIES
    element_t    : Token
    element_name : String
    element_info : Local
    collection   : Cmd
    step_size=1  : Integer

  METHODS
    method init( t, element_t, element_name, collection )
      structure_type = CmdControlStructure.type_for_each
      body=CmdStatementList()

    method init( t, element_t, element_name, collection, body )
      structure_type = CmdControlStructure.type_for_each

    method clone->CmdForEachIndexOfCollection
      local result = CmdForEachIndexOfCollection( t, element_t, element_name, clone(collection), clone(body)  )
      result.structure_type = structure_type
      result.step_size = step_size
      return result

    method has_side_effects->Logical
      return (collection.has_side_effects or body.has_side_effects)

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      if (element_info? and element_info.type?)
        buffer.print( ':' )
        buffer.print( element_info.type )
      endIf
      buffer.print( " of " )
      collection.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (element_info?) return this

      collection = collection.resolve.require_value

      local collection_type = collection.type
      collection_type.resolve

      local m_count = collection_type.find_method( "count()" )
      local p_count : Property
      if (m_count is null) p_count = collection_type.find_property( "count" )
      local has_count = m_count? or p_count?

      local m_get   = collection_type.find_method( "at(Integer)" )
      if (m_get is null) m_get = collection_type.find_method( "get(Integer)" )

      if (has_count and m_get?)
        #if (m_get.return_type is null) throw collection.error( "Implicit call to $ returns nil." (m_get.full_signature) )
        if (m_get.return_type is null) throw collection.error( "Implicit call to " + m_get.full_signature + " returns nil." )
        element_info = Local( element_t, element_name, m_get.return_type )
      else
        throw t.error( "TODO: forEach-of with non-indexed collection." )
      endIf

      element_info = Local( t, element_name, Types.type_Integer)

      local collection_name = "_collection_" + Analyzer.unique_id
      local collection_info = Local( collection.t, collection_name, collection_type )

      Analyzer.context.this_method.add_local( collection_info )
      Analyzer.context.this_method.add_local( element_info )

      Analyzer.add_local( collection_info )
      Analyzer.add_local( element_info )

      local count_cmd:Cmd
      if (m_count?) count_cmd = CmdDynamicCall( collection_info, m_count )
      else          count_cmd = CmdReadProperty( collection_info, p_count )

      # The loop counter starts at -1 and is incremented at the beginning of
      # the loop so that nextIteration commands work correctly.
      #   n = -1
      #   while (n < count-1)
      #     ++n
      #     ...
      #   endWhile
      local con_t = element_info.t
      local condition = CmdCompareLT( con_t, CmdReadLocal(element_info),
        CmdSubtract(con_t, count_cmd, CmdLiteralInteger(con_t,1)) )

      local cmd_while = CmdWhile( t, condition, body )
      cmd_while.structure_type = this.structure_type  # keep looking like a forEach for escapeForEach purposes.

      body.insert( CmdIncrementLocal( element_info.t, element_info ) )

      local result = CmdStatementList()
      result.add( CmdLocalDeclaration(t,element_info) )
      result.add( CmdLocalDeclaration(t,collection_info) )
      result.add( CmdWriteLocal(element_info,CmdLiteralInteger(element_info.t,-1)) )
      result.add( CmdAssign( collection.t, CmdAccess(collection.t,collection_name), collection ) )
      result.add( cmd_while )

      return CmdAnonymousBlock( t, result ).resolve

endClass


class CmdForEachValueInRangeUpTo : CmdForEach
  PROPERTIES
    element_t        : Token
    element_name     : String
    range_t          : Token
    first_expression : Cmd
    last_expression  : Cmd
    inclusive        : Logical

  METHODS
    method init( t, element_t, element_name, range_t, first_expression, last_expression, inclusive )
      if (element_t is null) element_t = t
      if (element_name is null) element_name = "_cur_" + Analyzer.unique_id
      structure_type = CmdControlStructure.type_for_each
      body = CmdStatementList()

    method init( t, element_t, element_name, range_t, first_expression, last_expression, inclusive, body, structure_type )
      if (element_t is null) element_t = t
      if (element_name is null) element_name = "_cur_" + Analyzer.unique_id

    method clone->CmdForEachValueInRangeUpTo
      local result = CmdForEachValueInRangeUpTo( t, element_t, element_name, range_t, first_expression, last_expression, inclusive, clone(body), structure_type )
      return result

    method has_side_effects->Logical
      return (body.has_side_effects or first_expression.has_side_effects or last_expression.has_side_effects)

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      buffer.print( " in " )
      first_expression.print( buffer )
      buffer.print( ".." )
      last_expression.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Convert this:
      #
      #   forEach (n in first..last)
      #
      # To this:
      #
      #   local cur = first_expression - 1
      #   local last = last_expression - 1
      #   while (cur <= last)
      #     ++cur
      #     ...
      #   endWhile

      first_expression = first_expression.resolve.require_value
      last_expression  = last_expression.resolve.require_value
      
      local common_type = common_type( first_expression, last_expression )

      if (common_type is null or not (common_type.is_Real or common_type.is_Integer or common_type.is_Character or common_type.is_Byte))
        throw range_t.error( "Range must be defined using primitive numerical types." )
      endIf

      local cur_info  = Local( element_t, element_name, common_type )
      local last_info = Local( range_t, "_last_" + Analyzer.unique_id, common_type )

      Analyzer.context.this_method.add_local( cur_info )
      Analyzer.context.this_method.add_local( last_info )

      Analyzer.add_local( cur_info )
      Analyzer.add_local( last_info )

      local condition : Cmd
      if (inclusive) condition = CmdCompareLE( range_t, CmdReadLocal(cur_info), CmdReadLocal(last_info) )
      else           condition = CmdCompareLT( range_t, CmdReadLocal(cur_info), CmdReadLocal(last_info) )

      local cmd_while = CmdWhile( t, condition, body )
      cmd_while.structure_type = this.structure_type  # keep looking like the previous structure type for escape purposes

      body.insert( CmdIncrementLocal( cur_info.t, cur_info ) )

      local result = CmdStatementList()
      result.add( CmdLocalDeclaration(t,cur_info) )
      result.add( CmdLocalDeclaration(t,last_info) )
      result.add( CmdWriteLocal(cur_info, CmdSubtract(range_t,first_expression,CmdLiteralInteger(range_t,1))) )
      result.add( CmdWriteLocal(last_info, CmdSubtract(range_t,last_expression,CmdLiteralInteger(range_t,1))) )
      result.add( cmd_while )

      return CmdAnonymousBlock( t, result ).resolve

endClass


class CmdForEachValueInRangeDownTo : CmdForEach
  PROPERTIES
    element_t        : Token
    element_name     : String
    range_t          : Token
    first_expression : Cmd
    last_expression  : Cmd
    inclusive        : Logical

  METHODS
    method init( t, element_t, element_name, range_t, first_expression, last_expression, inclusive )
      if (element_t is null) element_t = t
      if (element_name is null) element_name = "_cur_" + Analyzer.unique_id
      structure_type = CmdControlStructure.type_for_each
      body = CmdStatementList()

    method init( t, element_t, element_name, range_t, first_expression, last_expression, inclusive, body, structure_type )
      if (element_t is null) element_t = t
      if (element_name is null) element_name = "_cur_" + Analyzer.unique_id

    method clone->CmdForEachValueInRangeDownTo
      local result = CmdForEachValueInRangeDownTo( t, element_t, element_name, range_t, first_expression, last_expression, inclusive, clone(body), structure_type )
      return result

    method has_side_effects->Logical
      return (body.has_side_effects or first_expression.has_side_effects or last_expression.has_side_effects)

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      buffer.print( " in " )
      first_expression.print( buffer )
      if (inclusive) buffer.print( " downTo " )
      else           buffer.print( "..>" )
      last_expression.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      # Convert this:
      #
      #   forEach (n in first..last)
      #
      # To this:
      #
      #   local cur = first_expression - 1
      #   local last = last_expression - 1
      #   while (cur <= last)
      #     ++cur
      #     ...
      #   endWhile

      first_expression = first_expression.resolve.require_value
      last_expression  = last_expression.resolve.require_value
      
      local common_type = common_type( first_expression, last_expression )

      if (common_type is null or not (common_type.is_Real or common_type.is_Integer or common_type.is_Character or common_type.is_Byte))
        throw range_t.error( "Range must be defined using primitive numerical types." )
      endIf

      local cur_info  = Local( element_t, element_name, common_type )
      local last_info = Local( range_t, "_last_" + Analyzer.unique_id, common_type )

      Analyzer.context.this_method.add_local( cur_info )
      Analyzer.context.this_method.add_local( last_info )

      Analyzer.add_local( cur_info )
      Analyzer.add_local( last_info )

      local condition : Cmd
      if (inclusive) condition = CmdCompareGE( range_t, CmdReadLocal(cur_info), CmdReadLocal(last_info) )
      else           condition = CmdCompareGT( range_t, CmdReadLocal(cur_info), CmdReadLocal(last_info) )

      local cmd_while = CmdWhile( t, condition, body )
      cmd_while.structure_type = this.structure_type  # keep looking like the previous structure type for escape purposes

      body.insert( CmdDecrementLocal( cur_info.t, cur_info ) )

      local result = CmdStatementList()
      result.add( CmdLocalDeclaration(t,cur_info) )
      result.add( CmdLocalDeclaration(t,last_info) )
      result.add( CmdWriteLocal(cur_info,  CmdAdd(range_t,first_expression,CmdLiteralInteger(range_t,1))) )
      result.add( CmdWriteLocal(last_info, CmdAdd(range_t,last_expression,CmdLiteralInteger(range_t,1))) )
      result.add( cmd_while )

      return CmdAnonymousBlock( t, result ).resolve

endClass


class CmdLoop : CmdIterationControlStructure
  PROPERTIES
    count_expression : Cmd

  METHODS
    method init( t )
      structure_type = CmdControlStructure.type_loop
      body=CmdStatementList()

    method init( t, body )
      structure_type = CmdControlStructure.type_loop

    method clone->CmdLoop
      local result = CmdLoop( t, clone(body) )
      result.structure_type = structure_type
      if (count_expression?) result.count_expression = count_expression.clone
      return result

    method print( buffer:StringBuilder )
      buffer.print( "loop" )
      if (count_expression?)
        buffer.print( " " )
        count_expression.print( buffer )
      endIf
      buffer.println
      body.print( buffer )
      buffer.println( "      endLoop" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (count_expression?)
        local ct = count_expression.t
        return CmdForEachValueInRangeUpTo( t, t, null, ct, CmdLiteralInteger(ct,1), count_expression, true, body, structure_type ).resolve
      endIf

      Analyzer.context.control_structure_stack.add( this )
      body.resolve
      Analyzer.context.control_structure_stack.remove_last
      return this

endClass

class CmdTry : CmdControlStructure
  PROPERTIES
    body      : CmdStatementList
    catches   = CmdCatch[]

  METHODS
    method init( t )
      structure_type = CmdControlStructure.type_try
      body=CmdStatementList()

    method init( t, body )

    method clone->CmdTry
      local result = CmdTry( t, clone(body) )
      result.structure_type = structure_type
      forEach (c in catches) result.catches.add( clone(c) as CmdCatch )
      return result

    method has_side_effects->Logical
      if (body.has_side_effects) return true
      forEach (c in catches)
        if (c.has_side_effects) return true
      endForEach
      return false

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      Analyzer.context.control_structure_stack.add( this )

      body.resolve
      forEach (cur_catch in catches) cur_catch.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this
endClass

class CmdCatch : Cmd
  PROPERTIES
    parent     : CmdTry
    local_name : String
    local_type : Type
    local_info : Local
    body       : CmdStatementList

  METHODS
    method init( t, parent )
      body = CmdStatementList()

    method init( t, parent, body )

    method clone->CmdCatch
      local result = CmdCatch( t, parent, clone(body) )
      result.local_name = local_name
      result.local_type = local_type
      result.local_info = local_info
      return result

    method has_side_effects->Logical
      return (body.has_side_effects)

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (local_info is null)
        local_type.resolve
        local_info = Local( t, local_name, local_type )
        Analyzer.context.this_method.add_local( local_info )
      else
        # Make sure we've got a referece to the correct local_info object after possible aspect method cloning.
        local_info = Analyzer.context.this_method.locals[ local_info.index ]
      endIf

      Analyzer.context.push_local_scope
      Analyzer.add_local( local_info )

      body.resolve

      Analyzer.context.pop_local_scope
      return this
endClass


class CmdThrow : CmdStatementWithOperand
  METHODS
    method clone->CmdThrow
      return CmdThrow( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "throw " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      operand.type.resolve(t)
      if (not operand.type.instance_of(Types.type_Exception))
        throw operand.t.error( "Thrown object must be instance of Exception." )
      endIf
      return this
endClass


class CmdControlReset : CmdStatement
  PROPERTIES
    label     : String
    target_id : String
endClass


class CmdEscapeContingent : CmdControlReset
  METHODS
    method init ( t )

    method clone->CmdEscapeContingent
      return CmdEscapeContingent( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeContingent" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_contingent)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach
      throw t.error( "No enclosing 'contingent' to escape from." )
endClass

class CmdEscapeForEach : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeForEach
      return CmdEscapeForEach( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeForEach" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_for_each)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'forEach' to escape from." )
endClass

class CmdEscapeIf : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeIf
      return CmdEscapeIf( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeIf" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_if)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'if' to escape from." )
endClass

class CmdEscapeLoop : CmdControlReset
  METHODS
    method init( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeLoop" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_loop)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'loop' to escape from." )
endClass

class CmdEscapeWhich : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeWhich
      return CmdEscapeWhich( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeWhich" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_which)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'which' to escape from." )
endClass


class CmdEscapeTry : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeTry
      return CmdEscapeTry( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeTry" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type == CmdControlStructure.type_try)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'try' to escape from." )
endClass

class CmdEscapeWhile : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeWhile
      return CmdEscapeWhile( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeWhile" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdWhile)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'while' to escape from." )
endClass

class CmdNextIteration : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdNextIteration
      return CmdNextIteration( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeNextIteration" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure.structure_type >= CmdControlStructure.type_iteration)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing iterator to escape from." )
endClass

class CmdStatementWithOperand : CmdStatement
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method has_side_effects->Logical
      return (operand.has_side_effects)

    method type->Type
      return null

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      return this
endClass

class CmdTrace : CmdStatement
  PROPERTIES
    method_context : Method
    labels         = String[]
    expressions    = Cmd[]
    command        : Cmd

  METHODS
    method init( t, method_context )

    method clone->CmdTrace
      local result = CmdTrace( t, method_context )
      result.labels = labels.clone
      result.expressions = expressions.clone
      result.command = clone(command)
      return result

    method has_side_effects->Logical
      if (command? and command.has_side_effects) return true
      forEach (expr in expressions)
        if (expr.has_side_effects) return true
      endForEach
      return false

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (command?) return this

      #command = CmdLiteralString( t, "[$ line $, $::$]  " (File(t.filepath).filename,t.line,method_context.type_context,method_context.full_signature) )
      command = CmdLiteralString( t, "[" + File(t.filepath).filename + " line " + t.line + ", " + method_context.type_context.name + "::" + method_context.full_signature + "]  " )

      forEach (i in expressions.indices)
        local expression = expressions[i].resolve.require_value
        if (expression instanceOf CmdLiteralString)
          command = CmdAdd( t, command, expression )
        else
          command = CmdAdd( t, command, CmdLiteralString(t,labels[i]+":") )
          command = CmdAdd( t, command, expression )
        endIf
      endForEach

      local result = CmdAccess( t, CmdReadSingleton(t,Types.type_Global), "println", CmdArgs(command) ).resolve
      return result

    method print( buffer:StringBuilder )
      buffer.println "trace ..."
endClass

class CmdThrowMissingReturn : CmdStatement
  METHODS
    method clone->CmdThrowMissingReturn
      return CmdThrowMissingReturn( t )

    method print( buffer:StringBuilder )
      buffer.print( "throw MissingReturnError()" )
endClass

class CmdTron : CmdStatement
  METHODS
    method clone->CmdTron
      return CmdTron( t )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "tron" )
endClass

class CmdTroff : CmdStatement
  METHODS
    method clone->CmdTroff
      return CmdTroff( t )

    method has_side_effects->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( "troff" )
endClass

class CmdReturn : CmdStatement
  METHODS
    method clone->CmdReturn
      return CmdReturn( t )

    method has_side_effects->Logical
      return true
endClass

class CmdReturnNil : CmdReturn
  METHODS
    method clone->CmdReturnNil
      return CmdReturnNil( t )

    method print( buffer:StringBuilder )
      buffer.print( "return" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      local m = Analyzer.context.this_method
      if (m.name == "init" or m.attributes.auto_return_this)
        return CmdReturnThis( t, Analyzer.context.this_method.type_context ).resolve
      endIf

      if (m.return_type? and (not m.is_task or m.yield_type?))
        throw t.error( "A return value must be specified." )
      endIf

      return this
endClass

class CmdReturnNull : CmdReturn
  METHODS
    method clone->CmdReturnNull
      return CmdReturnNull( t )

    method print( buffer:StringBuilder )
      buffer.print( "return null" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      local return_type = Analyzer.context.this_method.return_type
      local m = Analyzer.context.this_method
      if (return_type is null or (m.is_task and m.yield_type is null))
        throw t.error( "Method is not declared as returning a value." )
      endIf
      #if (not return_type.possibly_null) throw t.error( "Non-null return value required." )
      return this

endClass

class CmdReturnThis : CmdReturn
  PROPERTIES
    return_type : Type

  METHODS
    method init( t, return_type )

    method clone->CmdReturnThis
      return CmdReturnThis( t, return_type )

    method print( buffer:StringBuilder )
      buffer.print( "return this" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      return_type.resolve(t)
      local m = Analyzer.context.this_method
      if (return_type is null or (m.is_task and m.yield_type is null))
        throw t.error( "Method is not declared as returning a value." )
      endIf
      return this

endClass

class CmdReturnValue : CmdReturn
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method clone->CmdReturnValue
      return CmdReturnValue( t, clone(operand) )

    method type->Type
      return null

    method print( buffer:StringBuilder )
      buffer.print( "return " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value

      local m = Analyzer.context.this_method
      local return_type = Analyzer.context.this_method.return_type
      if (m.is_task) return_type = m.yield_type

      if (return_type is null or (m.is_task and m.yield_type is null))
        throw t.error( "Method is not declared as returning a value." )
      endIf
      operand.require_value

      return_type.resolve
      operand.type.resolve

      operand = operand.cast_to( t, return_type ).resolve
      return this

endClass

class CmdYield : CmdStatement
  METHODS
    method has_side_effects->Logical
      return true

    method contains_asynchronous_control->Logical
      return true
endClass

class CmdYieldNil : CmdYield
  METHODS
    method clone->CmdYieldNil
      return CmdYieldNil( t )

    method print( buffer:StringBuilder )
      buffer.print( "yield" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (not Analyzer.context.this_method.is_task)
        throw t.error( "'yield' can only be used in 'task' definitions." )
      endIf

      if (Analyzer.context.this_method.yield_type?)
        throw t.error( "A value must be specified." )
      endIf

      return this
endClass

class CmdYieldValue : CmdYield
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method clone->CmdYieldValue
      return CmdYieldValue( t, clone(operand) )

    method type->Type
      return null

    method print( buffer:StringBuilder )
      buffer.print( "yield " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (not Analyzer.context.this_method.is_task)
        throw t.error( "'yield' can only be used in 'task' definitions." )
      endIf

      operand = operand.resolve.require_value
      local return_type = Analyzer.context.this_method.yield_type
      if (return_type is null)
        throw t.error( "Method is not declared as returning a value." )
      endIf

      return_type.resolve
      operand.type.resolve

      operand = operand.cast_to( t, return_type ).resolve
      return this

endClass

class CmdYieldAndWait : CmdYield
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method clone->CmdYieldAndWait
      return CmdYieldAndWait( t, clone(operand) )

    method type->Type
      return null

    method print( buffer:StringBuilder )
      buffer.print( "yieldAndWait " )
      operand.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (not Analyzer.context.this_method.is_task)
        throw t.error( "'yieldAndWait' can only be used in 'task' definitions." )
      endIf
      if (Analyzer.context.this_method.yield_type?)
        throw t.error( "'yieldAndWait' cannot be used in tasks that yield or return values." )
      endIf

      operand = operand.resolve.require_value.cast_to( t, Types.type_Real ).resolve
      return this

endClass

class CmdCast : CmdUnary
  METHODS
    method is_complex_reference->Logical
      return true

endClass

class CmdImplicitCastToType : CmdCast
  # In Bard terminology a 'cast' can be either a conversion or a coercion.
  # Operations such as variable assignments and method calls convert their
  # operands and arguments to a specific target type using an 'implicit cast'
  # that resolves to either a conversion, a coercion, or an error.
  #
  # IMPLICIT CAST MECHANISMS USED
  #
  # SRC TYPE  | TARGET TYPE
  #           | Object       Reference    Primitive    Compound
  # Object    | N/A          to->:Type    to->:Type    to->Type
  # Reference | Generalize   Generalize/E ERROR        ERROR
  # Primitive | Box          ERROR        Convert      ERROR
  # Compound  | Box          ERROR        ERROR        ERROR
  #
  PROPERTIES
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method clone->CmdImplicitCastToType
      return CmdImplicitCastToType( t, clone(operand), to_type )

    method type->Type
      return to_type

    method implicit_type->Type
      return to_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( " castTo " )
      buffer.print( to_type )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      to_type.resolve(t)

      operand = operand.resolve_with_type_hint(to_type).require_value
      local from_type = operand.type
      from_type.resolve( t )

      if (from_type is to_type) return operand

      if (from_type.is_primitive and to_type.is_primitive)
        return CmdConvertToType( t, operand, to_type ).resolve
      endIf

      if (from_type is Types.type_Object)
        return CmdAccess( t, operand, "to_"+to_type, null ).cast_to(t,to_type).resolve

      elseIf (from_type.is_reference)
        if (to_type.is_reference)
          if (from_type.instance_of( to_type)) return CmdGeneralizeReference( t, operand,  to_type).resolve
          else throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicitly convert obj->" + to_type.name + " or recast (obj as " + to_type.name + ")." )

          #else throw t.error( "Type $ cannot be implicitly cast to type $.  Explicitly convert obj->$ or recast (obj as $)." (from_type,to_type,to_type,to_type) )
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      elseIf (from_type.is_primitive)
        #println( "From $ to $" (from_type,to_type))
        #println( System.stack_trace )
        if (to_type is Types.type_Object)
          throw t.error( "TODO: box primitive as Object (1)." )
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      else
        # from_type is compound
        if (from_type.find_method("to_"+to_type.name)?)
          return CmdAccess( t, operand, "to_" + to_type.name, null ).resolve
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      endIf

      throw t.error( "Unhandled cast: " + from_type.name + "->" + to_type.name )
endClass

class CmdConvertToType : CmdCast
  PROPERTIES
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method clone->CmdConvertToType
      return CmdConvertToType( t, clone(operand), to_type )

    method type->Type
      return to_type

    method implicit_type->Type
      return to_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->" )
      buffer.print( to_type )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      to_type.resolve(t)

      operand = operand.resolve_with_type_hint(to_type).require_value
      local from_type = operand.type
      if (from_type is to_type) return operand

      #{
      if (from_type.def is to_type.def)
        #if (to_type.possibly_null) return CmdGeneralizeReference( t, operand, to_type )
        throw t.error( "Cannot cast a possibly null reference to a non-null reference type." )
      endIf
      }#

      #{
      if (from_type.is_primitive and to_type.is_reference)
        if (to_type.def is Types.type_IntegerObject or to_type.is_Object)
          return CmdAccess( t, "IntegerObject", CmdArgs(operand) ).resolve
        endIf
      endIf
      }#

      if (from_type.is_primitive and to_type.is_primitive)
        if (to_type.is_Real)
          if (from_type.is_Integer) return CmdConvertIntegerToReal( t, operand ).resolve
        elseIf (to_type.is_Integer)
          if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
          elseIf (from_type.is_Character) return CmdConvertCharacterToInteger( t, operand ).resolve
          elseIf (from_type.is_Byte)      return CmdConvertByteToInteger( t, operand ).resolve
          elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
        elseIf (to_type.is_Character)
          if     (from_type.is_Integer)   return CmdConvertIntegerToCharacter( t, operand ).resolve
          else                            return operand.cast_to(t,Types.type_Integer).cast_to(t,Types.type_Character).resolve
        elseIf (to_type.is_Byte)
          if     (from_type.is_Integer)   return CmdConvertIntegerToByte( t, operand ).resolve
          else                            return operand.cast_to(t,Types.type_Integer).cast_to(t,Types.type_Byte).resolve
        endIf

      else
        # "obj->Type" -> "obj.to()->Type"
        local cmd = Analyzer.resolve_call( t, null, operand, "to_"+to_type, null, false, to_type )
        if (cmd?) return cmd

        #throw t.error( //:Type$ does not define conversion "method to->$".// (from_type,to_type) )
      endIf

      throw t.error( //Type // + from_type.name + // does not define conversion "method to->// + to_type.name + //".// )
endClass

class CmdRecastAsType : CmdCast
  PROPERTIES
    as_type : Type

  METHODS
    method init( t, operand, as_type )

    method clone->CmdRecastAsType
      return CmdRecastAsType( t, clone(operand), as_type )

    method type->Type
      return as_type

    method implicit_type->Type
      return as_type

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      operand.print( buffer )
      buffer.print( " as " )
      buffer.print( as_type )
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      as_type.resolve(t)

      operand = operand.resolve_with_type_hint(as_type).require_value
      local from_type = operand.type
      if (from_type is as_type) return operand

      if (from_type.is_reference and as_type.is_reference)
        if (from_type.instance_of( as_type)) return CmdGeneralizeReference( t, operand,  as_type)
        else                                 return CmdSpecializeReference( t, operand,  as_type)
      endIf

      if (from_type.is_reference and not as_type.is_reference)
        #throw t.error( //Cannot recast a reference to a non-reference type.  You can write "ref->$" to call the to->$()() conversion method of the reference.// (as_type,as_type)  )
        throw t.error( //Cannot recast a reference to a non-reference type.  You can write "ref->// + as_type.name + //" to call the to->// + as_type.name + //()() conversion method of the reference.// )
      endIf

      if (not from_type.is_reference and as_type.is_reference)
        #throw t.error( //Cannot recast a value type to a reference type.  You can write "value->$" to call "$.create_from(value)" (compiler's first choice) or "$.to(value)->$()()" (compiler's second choice).// (as_type,as_type,from_type,as_type) )
        throw t.error( //Cannot recast a value type to a reference type.  You can write "value->// + as_type.name + //" to call "// + as_type.name + //.create_from(value)" (compiler's first choice) or "// + from_type.name + //.to(value)->// + as_type.name + //()()" (compiler's second choice).// )
      endIf

      #{
      if (as_type.is_Real)
        #if (from_type.is_Integer) return CmdConvertIntegerToReal( t, operand ).resolve
      elseIf (as_type.is_Integer)
        #if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
        if (from_type.is_Character) return CmdCharacterAsInteger( t, operand, as_type ).resolve
        #elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
      elseIf (as_type.is_Character)
        #if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
        if (from_type.is_Integer)   return CmdIntegerAsCharacter( t, operand, as_type ).resolve
        #elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
      endIf
      }#

      throw t.error( "Unhandled recast: " + from_type.name + " as " + as_type.name )
endClass

#{
class CmdCharacterAsInteger : CmdRecastAsType
  METHODS
    method resolve->Cmd
      operand = operand.resolve.require_value
      local literal_operand = operand as CmdLiteralCharacter
      if (literal_operand?)
        return CmdLiteralInteger( t, Integer(literal_operand.value) )
      endIf
      return this
endClass

class CmdIntegerAsCharacter : CmdRecastAsType
  METHODS
    method resolve->Cmd
      operand = operand.resolve.require_value
      local literal_operand = operand as CmdLiteralInteger
      if (literal_operand?)
        return CmdLiteralCharacter( t, literal_operand.value->Character )
      endIf
      return this
endClass
}#

class CmdGeneralizeReference : CmdRecastAsType
  METHODS
    method clone->CmdGeneralizeReference
      return CmdGeneralizeReference( t, clone(operand), as_type )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      return this

endClass

class CmdSpecializeReference : CmdRecastAsType
  METHODS
    method clone->CmdSpecializeReference
      return CmdSpecializeReference( t, clone(operand), as_type )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      return this

endClass

class CmdConvertIntegerToReal : CmdCast
  METHODS
    method type->Type
      return Types.type_Real

    method clone->CmdConvertIntegerToReal
      return CmdConvertIntegerToReal( t, clone(operand) )

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Real" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral) return CmdLiteralReal( t, (operand as CmdLiteralInteger).value )
      return this

endClass

class CmdConvertRealToInteger : CmdCast
  METHODS
    method clone->CmdConvertRealToInteger
      return CmdConvertRealToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral) return CmdLiteralInteger( t, (operand as CmdLiteralReal).value )
      return this

endClass

class CmdConvertCharacterToInteger : CmdCast
  METHODS
    method clone->CmdConvertCharacterToInteger
      return CmdConvertCharacterToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local character_operand = (operand as CmdLiteralCharacter)
      if (character_operand?)
        return CmdLiteralInteger( t, character_operand.value->Integer )
      endIf
      return this

endClass

class CmdConvertByteToInteger : CmdCast
  METHODS
    method clone->CmdConvertByteToInteger
      return CmdConvertByteToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local byte_operand = (operand as CmdLiteralByte)
      if (byte_operand?)
        return CmdLiteralInteger( t, byte_operand.value->Integer )
      endIf
      return this

endClass

class CmdConvertIntegerToCharacter : CmdCast
  METHODS
    method clone->CmdConvertIntegerToCharacter
      return CmdConvertIntegerToCharacter( t, clone(operand) )

    method type->Type
      return Types.type_Character

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Character" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local integer_operand = (operand as CmdLiteralInteger)
      if (integer_operand?)
        return CmdLiteralCharacter( t, integer_operand.value->Character )
      endIf
      return this

endClass

class CmdConvertIntegerToByte : CmdCast
  METHODS
    method clone->CmdConvertIntegerToByte
      return CmdConvertIntegerToByte( t, clone(operand) )

    method type->Type
      return Types.type_Byte

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Byte" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local integer_operand = (operand as CmdLiteralInteger)
      if (integer_operand?)
        return CmdLiteralByte( t, integer_operand.value & 255 )
      endIf
      return this

endClass

class CmdConvertLogicalToInteger : CmdCast
  METHODS
    method clone->CmdConvertLogicalToInteger
      return CmdConvertLogicalToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral)
        local value = 0
        if ((operand as CmdLiteralLogical).value) value = 1
        return CmdLiteralInteger( t, value )
      endIf
      return this

endClass

class CmdTypeManipulation : Cmd
  PROPERTIES
    operand : Cmd
    target_type : Type

  METHODS
    method init( t, operand, target_type )

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      target_type.resolve(t)
      return this

endClass

class CmdInstanceOf : CmdTypeManipulation
  METHODS
    method clone->CmdInstanceOf
      return CmdInstanceOf( t, clone(operand), target_type )

    method type->Type
      return Types.type_Logical

    method implicit_type->Type
      return Types.type_Logical

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      operand.print( buffer )
      buffer.print( " instanceOf " )
      buffer.print( target_type )
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve.require_value
      local operand_type = operand.type

      if (operand_type.instance_of(target_type)) return CmdLiteralLogical( t, true )

      if (operand_type.is_functional or not operand_type.is_reference) return CmdLiteralLogical( t, false )
      if (target_type.is_functional or not target_type.is_reference) return CmdLiteralLogical( t, false )

      return this

endClass


class CmdBinary : Cmd
  PROPERTIES
    lhs     : Cmd
    rhs     : Cmd
    opcode = -1 : Integer

  METHODS
    method init( t, lhs, rhs )

    method has_side_effects->Logical
      return (lhs.has_side_effects or rhs.has_side_effects)

    method implicit_type->Type
      local lhs_type = lhs.implicit_type
      local rhs_type = rhs.implicit_type
      if (lhs_type is null or rhs_type is null) return null
      return common_type( lhs_type, rhs_type )

    method is_complex_reference->Logical
      return true

    method type->Type
      return lhs.type

    method name->String
      return "[unnamed binary op]"

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      lhs.print( buffer )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      rhs.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      lhs = lhs.resolve.require_value
      rhs = rhs.resolve.require_value
      local lhs_type = lhs.type
      local rhs_type = rhs.type

      return resolve_for_operand_types( lhs_type, rhs_type )

    method resolve_for_operand_types( lhs_type:Type, rhs_type:Type )->Cmd
      local result:Cmd

      if (lhs_type.is_reference) result = resolve_with_lhs_reference
      if (result?) return result

      if (rhs_type.is_reference) result = resolve_with_rhs_reference
      if (result?) return result

      if (lhs_type.is_compound)  result = resolve_with_lhs_reference
      if (result?) return result

      if (rhs_type.is_compound)  result = resolve_with_rhs_reference
      if (result?) return result

      local common_type = common_type( lhs, rhs )
      cast_to_common_type( common_type )
      return resolve_for_common_type( common_type )

    method resolve_with_lhs_reference->Cmd
      return null

    method resolve_with_rhs_reference->Cmd
      return null

    method resolve_for_common_type( common_type:Type )->Cmd
      if (common_type is null) common_type = common_type( lhs, rhs )

      if (lhs instanceOf CmdLiteral and rhs instanceOf CmdLiteral)
        if (common_type.is_Real)
          local result = combine_literal_Real_operands( (lhs as CmdLiteralReal).value, (rhs as CmdLiteralReal).value )
          if (result?) return result
        elseIf (common_type.is_Integer)
          local result = combine_literal_Integer_operands( (lhs as CmdLiteralInteger).value, (rhs as CmdLiteralInteger).value )
          if (result?) return result
        elseIf (common_type.is_Logical)
          local result = combine_literal_Logical_operands( (lhs as CmdLiteralLogical).value, (rhs as CmdLiteralLogical).value )
          if (result?) return result
        else
          local result = combine_literal_operands( common_type )
          if (result?) return result
        endIf
      endIf

      return this

    method cast_to_common_type( common_type:Type )
      lhs = lhs.cast_to( lhs.t, common_type ).resolve
      rhs = rhs.cast_to( rhs.t, common_type ).resolve

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return null

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return null

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return null

    method combine_literal_operands( common_type:Type )->Cmd
      return null

endClass

class CmdConcatenateStrings : CmdBinary
  PROPERTIES
    builder : Cmd
    # visited in Visitor::visit(CmdConcatenateStrings)

  METHODS
    method clone->CmdConcatenateStrings
      local result = CmdConcatenateStrings( t, clone(lhs), clone(rhs) )
      result.builder = clone( builder )
      return result

    method name->String
      return "+"

    method type->Type
      return Types.type_String

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      if (lhs.type.is_compound) lhs = CmdAccess( t, lhs, "to_String", null ).cast_to(t,Types.type_String).resolve
      if (rhs.type.is_compound) rhs = CmdAccess( t, rhs, "to_String", null ).cast_to(t,Types.type_String).resolve

      if (lhs instanceOf CmdConcatenateStrings)
        builder = CmdAccess( t, (lhs as CmdConcatenateStrings).builder, "print", CmdArgs(rhs) ).resolve
      else
        builder = CmdNewObject( t, Types.type_StringBuilder )
        builder = CmdAccess( t, builder, "print", CmdArgs(lhs) )
        builder = CmdAccess( t, builder, "print", CmdArgs(rhs) )
        builder = CmdAccess( t, builder, "to_String", null ).cast_to(t,Types.type_String)
        builder = builder.resolve
      endIf
      return this
endClass

class CmdAdd : CmdBinary
  METHODS
    method clone->CmdAdd
      return CmdAdd( t, clone(lhs), clone(rhs) )

    method name->String
      return "+"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value + rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value + rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        local lhs_value = (lhs as CmdLiteralCharacter).value
        local rhs_value = (rhs as CmdLiteralCharacter).value
        return CmdLiteralString( t, StringBuilder().print(lhs_value).print(rhs_value)->String )

      elseIf (common_type.is_String)
        return CmdLiteralString( t, (lhs as CmdLiteralString).value + (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve->Cmd
      if (resolved) return this

      lhs = lhs.resolve.require_value
      rhs = rhs.resolve.require_value

      local lhs_type = lhs.type
      local rhs_type = rhs.type

      if (lhs instanceOf CmdLiteral and rhs instanceOf CmdLiteral)
        local lhs_is_string = lhs_type.instance_of(Types.type_String)
        local rhs_is_string = rhs_type.instance_of(Types.type_String)
        if (lhs_is_string or rhs_is_string)
          return CmdLiteralString( t, lhs->String + rhs->String )
        else
          return prior.resolve
        endIf
      endIf

      if (lhs_type.instance_of(Types.type_String) or rhs_type.instance_of(Types.type_String))
        return CmdConcatenateStrings( t, lhs, rhs ).resolve
      else
        return prior.resolve
      endIf

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator+", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator+", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator+", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdSubtract : CmdBinary
  METHODS
    method clone->CmdSubtract
      return CmdSubtract( t, clone(lhs), clone(rhs) )

    method name->String
      return "-"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value - rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value - rhs_value )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator-", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator-", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator-", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdMultiply : CmdBinary
  METHODS
    method clone->CmdMultiply
      return CmdMultiply( t, clone(lhs), clone(rhs) )

    method name->String
      return "*"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value * rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value * rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator*", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator*", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator*", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdDivide : CmdBinary
  METHODS
    method clone->CmdDivide
      return CmdDivide( t, clone(lhs), clone(rhs) )

    method name->String
      return "/"

    method implicit_type->Type
      local lhs_type = lhs.implicit_type
      local rhs_type = rhs.implicit_type
      if (lhs_type is null or rhs_type is null) return null
      local result = common_type( lhs, rhs )
      if (result.is_Integer) return Types.type_Real
      return result

    method common_type( lhs:Cmd, rhs:Cmd )->Type
      local ctype = prior.common_type( lhs, rhs )
      if (ctype.is_Integer or ctype.is_Character) return Types.type_Real
      return ctype

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value / rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralReal( t, lhs_value->Real / rhs_value->Real )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator/", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator/", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator/", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdMod : CmdBinary
  METHODS
    method clone->CmdMod
      return CmdMod( t, clone(lhs), clone(rhs) )

    method name->String
      return "%"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value % rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value % rhs_value )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator%", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator%", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator%", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdPower : CmdBinary
  METHODS
    method clone->CmdPower
      return CmdPower( t, clone(lhs), clone(rhs) )

    method name->String
      return "^"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value ^ rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value ^ rhs_value )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator^", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator^", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator^", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseAnd : CmdBinary
  METHODS
    method clone->CmdBitwiseAnd
      return CmdBitwiseAnd( t, clone(lhs), clone(rhs) )

    method name->String
      return "&"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value & rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_and_integer
      return this

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator&", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator&", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator&", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseOr : CmdBinary
  METHODS
    method clone->CmdBitwiseOr
      return CmdBitwiseOr( t, clone(lhs), clone(rhs) )

    method name->String
      return "|"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value | rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_or_integer
      return this

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator|", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator|", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator|", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseXor : CmdBinary
  METHODS
    method clone->CmdBitwiseXor
      return CmdBitwiseXor( t, clone(lhs), clone(rhs) )

    method name->String
      return "~"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value ~ rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, (lhs_value and not rhs_value) or (not lhs_value and rhs_value) )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_xor_integer
      return this

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator~", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator~", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator~", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseSHL : CmdBinary
  METHODS
    method clone->CmdBitwiseSHL
      return CmdBitwiseSHL( t, clone(lhs), clone(rhs) )

    method name->String
      return ":<<:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :<<: rhs_value )

    method resolve_with_lhs_reference->Cmd
      local result = Analyzer.resolve_call( t, null, lhs, "operator:<<:", CmdArgs(rhs), false, null )
      if (result?) return result

      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator:<<:", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator:<<:", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseSHR : CmdBinary
  METHODS
    method clone->CmdBitwiseSHR
      return CmdBitwiseSHR( t, clone(lhs), clone(rhs) )

    method name->String
      return ":>>:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :>>: rhs_value )

endClass

class CmdBitwiseSHRX : CmdBinary
  METHODS
    method clone->CmdBitwiseSHRX
      return CmdBitwiseSHRX( t, clone(lhs), clone(rhs) )

    method name->String
      return ":>>>:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :>>>: rhs_value )

endClass

class CmdLogicalAnd : CmdBinary
  METHODS
    method init( t, lhs, rhs )

    method clone->CmdLogicalAnd
      return CmdLogicalAnd( t, clone(lhs), clone(rhs) )

    method name->String
      return "and"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_for_Logical_operands->Cmd
      return this
endClass

class CmdLogicalOr : CmdBinary
  METHODS
    method clone->CmdLogicalOr
      return CmdLogicalOr( t, clone(lhs), clone(rhs) )

    method name->String
      return "or"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method resolve_for_operand_types( lhs_type:Type, rhs_type:Type )->Cmd
      local common_type = common_type( lhs, rhs )

      if (common_type.is_reference)
        throw error( "TODO: || with reference types." )
        #{
        local lhs_type = lhs.type
        local rhs_type = rhs.type
        if (lhs_type.is_reference and rhs_type.is_reference)
          if (not lhs_type.possibly_null) return lhs
          #if (not rhs_type.possibly_null and common_type.possibly_null) common_type = common_type.checked_type
          return CmdEitherOr( t, lhs, rhs, common_type ).resolve
        endIf
        }#
      endIf

      cast_to_common_type( common_type )
      return resolve_for_common_type( common_type )

    method resolve_for_Logical_operands->Cmd
      return this

endClass

#{
class CmdEitherOr : CmdBinary
  PROPERTIES
    common_type : Type

  METHODS
    method init( t, lhs, rhs, common_type )

    method name->String
      return "or"

    method type->Type
      return common_type

    method resolve->Cmd
      # lhs and rhs have already been individually resolved
      if (lhs instanceOf CmdLiteralNull) return rhs
      if (rhs instanceOf CmdLiteralNull) return lhs
      return this

      #{
    method compile( writer:BCWriter )
      local label = writer.next_control_id + ""
      lhs.compile( writer )
      writer.write( Op.jump_if_not_null )
      writer.write_address( label )
      rhs.compile( writer )
      writer.define_label( label )
      }#
endClass
}#

class CmdRange : Cmd
  PROPERTIES
    first_expression : Cmd
    last_expression  : Cmd
    step_expression  : Cmd

  METHODS
    method init( t, first_expression, last_expression, step_expression=null )

    method has_side_effects->Logical
      if (step_expression? and step_expression.has_side_effects) return true
      return (first_expression.has_side_effects or last_expression.has_side_effects)

    method type->Type
      local result = common_type( first_expression, last_expression )
      if (step_expression?) return common_type( result, step_expression.type )
      else                  return result
endClass

class CmdRangeUpTo : CmdRange
  METHODS
    method clone->CmdRangeUpTo
      return CmdRangeUpTo( t, first_expression, last_expression, step_expression )

    method resolve->Cmd
      throw t.error( "TODO: CmdRangeUpTo -> RangeUpTo object." )
endClass

class CmdRangeUpToLessThan : CmdRange
  METHODS
    method clone->CmdRangeUpToLessThan
      return CmdRangeUpToLessThan( t, first_expression, last_expression, step_expression )

    method resolve->Cmd
      throw t.error( "TODO: CmdRangeUpToLessThan -> RangeUpToLessThan object." )
endClass

class CmdRangeDownTo : CmdRange
  METHODS
    method clone->CmdRangeDownTo
      return CmdRangeDownTo( t, first_expression, last_expression, step_expression )

    method resolve->Cmd
      throw t.error( "TODO: CmdRangeDownTo -> RangeDownTo object." )
endClass

class CmdRangeDownToGreaterThan : CmdRange
  METHODS
    method clone->CmdRangeDownToGreaterThan
      return CmdRangeDownToGreaterThan( t, first_expression, last_expression, step_expression )

    method resolve->Cmd
      throw t.error( "TODO: CmdRangeDownToGreaterThan -> RangeDownToGreaterThan object." )
endClass

class CmdLogicalXor : CmdBinary
  METHODS
    method clone->CmdLogicalXor
      return CmdLogicalXor( t, clone(lhs), clone(rhs) )

    method name->String
      return "xor"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, (lhs_value and not rhs_value) or (not lhs_value and rhs_value) )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_xor_integer
      return this

    method resolve->Cmd
      if (resolved) return this

      lhs = lhs.resolve.require_logical
      rhs = rhs.resolve.require_logical
      return prior.resolve
endClass

class CmdComparison : CmdBinary
  METHODS
    method type->Type
      return Types.type_Logical

    method implicit_type->Type
      return Types.type_Logical

endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method clone->CmdCompareEQ
      return CmdCompareEQ( t, clone(lhs), clone(rhs) )

    method name->String
      return "=="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value == (rhs as CmdLiteralCharacter).value )

      elseIf (common_type.is_Byte)
        return CmdLiteralLogical( t, (lhs as CmdLiteralByte).value == (rhs as CmdLiteralByte).value )

      elseIf (common_type.is_String)
        return CmdLiteralLogical( t, (lhs as CmdLiteralString).value == (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, lhs, "equals", CmdArgs(rhs) ).resolve.require_logical

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, rhs, "equals", CmdArgs(lhs) ).resolve.require_logical

endClass

class CmdCompareIs : CmdComparison
  METHODS
    method clone->CmdCompareIs
      return CmdCompareIs( t, clone(lhs), clone(rhs) )

    method name->String
      return "is"

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      lhs = lhs.resolve
      rhs = rhs.resolve

      local lhs_type = lhs.type
      local rhs_type = rhs.type

      if (not lhs_type.is_reference or not rhs_type.is_reference)
        return CmdCompareEQ(t, lhs, rhs).resolve
      endIf

      if (lhs instanceOf CmdLiteralNull)
        if (rhs instanceOf CmdLiteralNull) return CmdLiteralLogical( t, true )
      endIf

      return this


    # method resolve_with_lhs_reference.Cmd
    #   return CmdAccess( t, lhs, "==", CmdArgs(rhs) ).resolve.require_logical

    # method resolve_with_rhs_reference.Cmd
    #   return null

endClass

class CmdCompareNE : CmdComparison
  METHODS
    method clone->CmdCompareNE
      return CmdCompareNE( t, clone(lhs), clone(rhs) )

    method name->String
      return "!="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value != (rhs as CmdLiteralCharacter).value )

      elseIf (common_type.is_String)
        return CmdLiteralLogical( t, (lhs as CmdLiteralString).value != (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve_with_lhs_reference->Cmd
      return CmdLogicalNot( t, CmdAccess(t, lhs, "equals", CmdArgs(rhs)).resolve.require_logical ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdLogicalNot( t, CmdAccess(t, rhs, "equals", CmdArgs(lhs)).resolve.require_logical ).resolve

endClass

class CmdCompareIsNot : CmdComparison
  METHODS
    method clone->CmdCompareIsNot
      return CmdCompareIsNot( t, clone(lhs), clone(rhs) )

    method name->String
      return "isNot"

endClass

class CmdCompareLT : CmdComparison
  METHODS
    method clone->CmdCompareLT
      return CmdCompareLT( t, clone(lhs), clone(rhs) )

    method name->String
      return "<"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value < rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value < rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value < (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareLT( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareGT( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareGT : CmdComparison
  METHODS
    method clone->CmdCompareGT
      return CmdCompareGT( t, clone(lhs), clone(rhs) )

    method name->String
      return ">"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value > rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value > rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value > (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareGT( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareLT( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareLE : CmdComparison
  METHODS
    method clone->CmdCompareLE
      return CmdCompareLE( t, clone(lhs), clone(rhs) )

    method name->String
      return "<="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value <= rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value <= rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value <= (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareLE( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareGE( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareGE : CmdComparison
  METHODS
    method clone->CmdCompareGE
      return CmdCompareGE( t, clone(lhs), clone(rhs) )

    method name->String
      return ">="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value >= rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value >= rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value >= (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareGE( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareLE( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCreateArray( t, array_type:Type, element_type:Type, size_expression:Cmd ) : Cmd
  METHODS
    method clone->CmdCreateArray
      return CmdCreateArray( t, array_type, element_type, size_expression )

    method has_side_effects->Logical
      return true

    method is_complex_reference->Logical
      return true

    method type->Type
      return array_type

    method print( buffer:StringBuilder )
      buffer.print( array_type.name )
      buffer.print( '(' )
      size_expression.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      array_type.resolve.mark_used
      element_type.resolve
      size_expression = size_expression.resolve.require_integer
      return this
endClass

class CmdArrayCount( t, operand ) : CmdUnary
  METHODS
    method clone->CmdArrayCount
      return CmdArrayCount( t, operand )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( ".count" )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve
      return this
endClass

class CmdReadArrayElement( t, operand, index_expression:Cmd, element_type:Type ) : CmdUnary
  METHODS
    method clone->CmdReadArrayElement
      return CmdReadArrayElement( t, operand, index_expression, element_type )

    method type->Type
      return element_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '[' )
      index_expression.print( buffer )
      buffer.print( ']' )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve
      index_expression = index_expression.resolve.require_integer
      element_type.resolve
      return this
endClass

class CmdWriteArrayElement( t, array_type:Type, element_type:Type, operand, index_expression:Cmd, new_value:Cmd) : CmdUnary
  METHODS
    method clone->CmdWriteArrayElement
      return CmdWriteArrayElement( t, array_type, element_type, operand, index_expression, new_value )

    method has_side_effects->Logical
      return true

    method type->Type
      return array_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '[' )
      index_expression.print( buffer )
      buffer.print( "] = " )
      new_value.print( buffer )

    method resolve->Cmd
      if (resolved) return this
      resolved = true

      operand = operand.resolve
      index_expression = index_expression.resolve.require_integer
      new_value = new_value.resolve
      array_type.resolve
      element_type.resolve
      return this
endClass

class CmdFunction : Cmd
  PROPERTIES
    parameter_names = String[]
    body : CmdStatementList

  METHODS
    method init( t, body=CmdStatementList() )

    method type->Type
      return Types.type_Function

    method clone->CmdFunction
      local result = CmdFunction( t, body.clone )
      result.parameter_names.add( parameter_names )
      return result

    method has_side_effects->Logical
      return true

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      return this

    method convert_to_delegate( delegate_type:Type )->Cmd
      local m_call = delegate_type.find_method( "call", parameter_names.count )
      if (m_call is null) return this
      if (m_call.return_type is null) return this

      local arg_signature = m_call.full_signature.from_first('(')

      local fn_type_name = "Function_" + Analyzer.unique_id
      local buffer = StringBuilder()
      buffer.print( "class " ).print( fn_type_name ).print( " : Delegate" )
      buffer.println( arg_signature )
      #buffer.println( Analyzer.get_delegate_class_names(null,null,m_call.parameters,m_call.return_type).first )
      buffer.println( "  METHODS" )
      buffer.print( "    method call( " )
      local first = true
      forEach (i of parameter_names)
        if (first) first = false
        else       buffer.print(',')
        buffer.print( parameter_names[i] ).print(':').print(m_call.parameters[i].type.name)
      endForEach
      buffer.print(")->").println( m_call.return_type.name )
      buffer.println( "endClass" )

      # Uncomment to debug
      # println buffer->String

      Parser( "[fn$]"(arg_signature), buffer->String ).parse_content
      local fn_type = Types.reference( t, fn_type_name ).resolve
      m_call = fn_type.find_method( "call", parameter_names.count )
      if (m_call is null) return this

      m_call.body = body.clone

      return CmdReadSingleton( t, fn_type ).resolve
endClass

